---
title: "A Philosophy of Software Designの読書メモ"
date: 2025-04-29T19:21:37+09:00
author: "Naoya Furudono"
draft: true
tags:
    - "daily"
    - "tech"
    - "book"
    - "idea"
---

各章のまとめをする。随時僕の思ったことを差し込む。なのでこのドキュメントを読んであの本を読んだ気になってはいけないし、あの本と同じくらいに信頼してはいけない。

# Chapter 1. Introduction (It's all about complexity)

## 良いソフトウェアをいい感じに作るためには複雑さに対処することが必要

- ソフトウェアはそれがどんなものであるかを表現できれば作れたも同然である。例えば筋肉がなくても作れる
- そのためソフトウェアを作るためにボトルネックになる能力は作ろうとしているものがどんなものであるかを理解する能力である
- 残念なことにプログラムを成長させていくに連れて複雑さは増していく。
- 複雑さを増すとそのソフトウェアを理解することは難しくなり、成長させる速度やコストは増す
- まあ複雑さはどう頑張っても増えるものではあるのだけど、設計をシンプルにしておけばソフトウェアがでかく強力になってもまだ耐えられるようにできる（程度の問題だが設計の複雑さを減らすことで良い方向に持っていける）

## 複雑さを減らすためには二つのアプローチがある

- コードをシンプルで明らかにすること: こっちはまあそうでしょう、と思える
  - 名前の付け方に一貫性を持たせる
  - 特別扱いを減らす
- 複雑性をカプセル化する。(moduler designと呼ぶらしい)
  - 分割統治をするということ
  - 丁寧に説明すると、でかい問題を解決するために部分問題の証明を忘れられるようにすること

## 開発者はソフトウェアの複雑さに対処し続ける必要がある

橋とかのデザインと違って、ソフトウェアはずっと設計を変え続けるもの。この考え方に足していないのがウォーターフォールな開発で、一度に全体を設計したらそれを開発の過程で変更することはなく、もし微妙なところが出ても書く開発対象の範囲内で対処する。

アジャイル開発は設計を変え続けるアプローチに即している。将来的に開発したいでかいものは見据えつつ全体の設計は後回しにして欲しいソフトウェアのサブセットをまずは設計して開発する。
開発の段階でまずそうとわかった設計は、次の開発の前に変更してまずさを潰す。こうすることで設計の問題が小さいうちに課題を発見し解決できる見込みが増える。

こういうイテレーティブな開発では設計が終わることはなくて、開発者は常に設計に気をかける必要があるし改善する必要がある。改善するために小さく刻んで開発しているのだからそれはそう。
設計を改善できないのならば、アジャイルに開発する意味がない。

今日ではアジャイルな開発をしているわけで、開発者常に設計の課題について考える必要がある。つまりソフトウェアの複雑さを発見しそれを減らす必要がある。

# Chapter 2. The Nature of Complexity

この章では複雑さとは何かや、どのようにシステムが不必要に複雑であるかを見分けるかを議論する。
設計がシンプルかを見分けるだけでは設計をシンプルに作ることはできないが、その判断をもとにシンプルに作るためのアプローチをできる。

設計方針を色々試してみれば良くて、その結果いい感じになるやつを使えば良い。そのいい感じになるかの評価をできるようにすることがこの章の目的である。

## 複雑さの定義

この本で議論を進めるために以下のように複雑さを定義する: 複雑さはソフトウェアシステムの構造に関するもののうち、システムの理解や修正を難しくするものである。

例えば以下のような例がある

- コード片がどのように動作しているか理解できない
- システムのどこを修正して良いかわからない
- 他に影響を与えずにバグ修正をするのがむずい

要するに、理解と修正が難しければそのソフトウェアシステムは複雑であるということ。それが簡単だったらシンプル。

システムの複雑さは、コンポーネントの複雑さをその変更頻度で重み付けした上での総和であると思える。

また、読み手にとっての複雑さと書き手にとっての複雑さは異なる。書き手にとってシンプルであっても読み手にとって複雑であればそれは複雑である。
自分がそういうコードの書き手であったら、その分断が起きた理由を探ると良いだろう。そのギャップを埋める必要がこの仕事にはあるのだから。

## 複雑さの症状

一般的に三つの兆しがあって、開発を辛くする

- 変更範囲の拡大: 簡単にできそうな変更が思ったより大変なパターン。メンタルモデルとその実現方法があっていないときに生じる。メンタルモデルを表現する力が足りていない
- 認知負荷: うまく使うためにやらないといけないことが多いことが原因
- unknow unknown: 変更する必要性に気がつけなくなっていること

unknown unknownが特に辛い。変更範囲が広いのはめんどいのは間違い無いのだけど、全部対処すれば自信を持って変更を完遂できる。
一方でunknown unknownは自信を持つために全てのコードを読む必要があって辛い。システムがでかいとそもそも無理。

設計の目標の一つにシステムを明らかにすることがある。認知負荷とunknown unknownを減らすことにつながる。理解もコーディングもシュッとできるのがいい。
何かを考えてそれが実際に通じるかの判断も簡単になる。

## 複雑さの原因

複雑さの症状をざっと見て、なんでソフトウェア開発が辛くなるのかを議論した。次に複雑さの原因を議論してシステムに問題が入らないように設計できるようになりたい。

複雑さは依存と不明瞭さによって生じる。
ここではそれらをざっくり語って、後の章では細々とした設計での意思決定がどのようにそれらと関係するかをみる。

### 依存

扱う対象がそれ単体では理解できない、変更できないときに一緒に変更するやつに依存するという。
頻繁に変更するコンポーネントが他のコンポーネントに依存していると、依存されているコンポーネントまで頻繁に変更するハメになる。そこで以下のシステムの複雑さの定義の言い換えを思い出す。

> システムの複雑さは、コンポーネントの複雑さをその変更頻度で重み付けした上での総和であると思える。

依存が多いシステムではたくさんのコンポーネントの変更頻度が上がるため、システムの複雑さも大きい。

特に複雑なコンポーネントを他の変更が多いコンポーネントから依存させないことがシステム全体の複雑さを抑えるために効く。

### 不明瞭さ

大事な要素が明らかになっていないことを指す。例えば数値の単位がわからないとか、名前がなんの意味も表してないとか。あるいは依存が存在することが明らかじゃ無いのもそう。
一貫性のなさもこの要因で、同じ名前が異なる用途に使われているとやばい。

ドキュメントがやばいことが多くの原因で、コメントをちゃんと書けばよかったりする。
デザインが良ければそもそも明らかであってドキュメントを不要にすることもできる。

めっちゃコメントがいるような場合はデザインがまずいことの兆しだし、明瞭さを増すためにはシステムの設計を改善するのが正攻法。

依存は変更範囲の拡大と認知負荷に作用して、不明瞭さはunknown unknownと認知負荷に作用する。
依存と不明瞭さを下げる設計技法が手に入ればソフトフェアの複雑さを下げられるはずだ。

## 複雑さはシステム全体のもの

一個一個の細かい要因が全体を壊すほどの複雑さ単独で生むわけではなくて、複数が重なり合って首が回らなくなるもの。
対処するためには "zero tolerance" philosophy に従うべきらしい。

複雑さは既存のコードベースを修正することを難しく、またリスキーにする。
