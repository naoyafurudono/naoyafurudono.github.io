---
date: 2022-01-19
updated: 2022-01-19T13:39
title: Questions
author: "Naoya Furudono"
---

<!-- # 気になっていること -->

## 静的型付け言語のマクロはどのくらいなものが存在するのだろうか

- 理論、実装の両方が気になる
- 型システムの能力とマクロ定義や展開器の能力がどの程度かも気になる。
  - Typed Racketは Gradual typing をしていてマクロはRacketのそれと同じだった気がする。
  - Rustはどうだなのだろうか。Rustも衛生的なマクロを書けるが、検査はどの程度？

## コンパイラの内部表現と表面言語

- LispやJuliaでは、コンパイラの内部表現を表面言語で記述したり操作したりできる。マクロ変換器はその機能を用いて実装され、処理系のマクロ展開器がそれを呼び出す。こういうデザインは割と決定的なのではないかと思う。マクロ変換器がコードをレキシムを受け取ってパースする能力はおまけなのではなかろうか。もちろん変換対象のプログラムデータに変換する方法は必要でマクロの使い勝手のために重要だろうけれど。
  - マクロ展開器のパースと変換は分けてコンパイラに実装すべき、という考え。書いてから思ったけどどの実装者も気がついて実装しているかもしれない。TODO サーベイする。
- 言語によって内部表現が異なる。Scheme系はsyntax objectと呼ばれるもで、CLとかはS式（少なくともマクロが触る内部表現はそうだろう）。Juliaは `Expr`型の値。
- Haskellみたいな関数型言語にこういう手法でマクロを入れようと思ったら、どういう表現が良いだろうか。
  - Haskell の上の方の内部表現は Core と呼ばれる System F+α みたいな言語。
  - 型の束縛関係にマクロがどう影響を与えるか（意図せず与えようとしてしまうか）とか
    - 束縛自体の難しさはこれまでほどではないだろう。ただマクロ展開と型検査のタイミングが難しくなりそう。割とデザインチョイスが必要で、上手にまとめられると一歩先へ行けそう。
