<!doctype html><html lang=ja-jp><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>Golang の変数キャプチャ | nfurudono</title><link rel=apple-touch-icon sizes=57x57 href=/images/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/images/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/images/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/images/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/images/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/images/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/images/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/images/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/images/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/images/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=manifest href=/images/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/images/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://naoyafurudono.github.io/css/main.min.e34415025514319010e741089e6920454053855755ba465f66943ad102d2cb08.css></head><body><nav><header><div class=site-title><a href=/>nfurudono</a></div></header><div class=nav-menu><a class="color-link nav-link" href=https://naoyafurudono.github.io/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons></div><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p><script src=https://naoyafurudono.github.io/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></nav><div id=content class=content-container><h1 class=post-title>Golang の変数キャプチャ</h1><time>June 28, 2022</time><div><p><p>Golangの変数キャプチャを勉強する。</p><p>追記: 最初、変数キャプチャではなくメモリモデルを勉強しようとしていた。勉強してみて、求めている概念では無いことに気がついたのでタイトルなどを修正した。
メモリモデル自体は知れて良かった。非同期処理へのコンパイラ最適化が及ぼす影響を知れる（<a href=https://go.dev/ref/mem>公式サイト</a> におせわになった）。
変数キャプチャの説明は<a href=https://eli.thegreenplace.net/2019/go-internals-capturing-loop-variables-in-closures/>これ</a> を読む。３年前に僕と同じことを思ったひとがいたようだ。</p><h2 id=overview>Overview</h2><p>クロージャをforループ内で生成してデータ構造や高階関数に渡すような処理を書いた。
そこで変数の扱い（メモリモデル）でエラーを出したことがことの始まり。
解決策はシンプルなのだが、イマイチしっくりこないので勉強したくなった。
クロージャの変数キャプチャは言語によりけりだし、特徴が現れるように思う。
Golangがどうなっているか知るのが楽しみ。</p><h2 id=動機となったミス>動機となったミス</h2><p>問題のコードはこんな感じ
<a href=https://go.dev/play/p/unayMJyn_3g>(The Go Playground)</a>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>words</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;foo&#34;</span>, <span style=color:#e6db74>&#34;boo&#34;</span>, <span style=color:#e6db74>&#34;bang&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>func</span>(){}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>words</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>arr</span> = append(<span style=color:#a6e22e>arr</span>, <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d: %s\n&#34;</span>, <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>elem</span>)
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>結果は次の通り。</p><pre tabindex=0><code>2: bang
2: bang
2: bang
</code></pre><p>期待していたのはこれ。</p><pre tabindex=0><code>0: foo
1: boo
2: bang
</code></pre><p>こうすると期待通りの出力を得られる
<a href=https://go.dev/play/p/xO9C4G03a0k>(The Go Playground)</a>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>words</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;foo&#34;</span>, <span style=color:#e6db74>&#34;boo&#34;</span>, <span style=color:#e6db74>&#34;bang&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>func</span>(){}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>words</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>arr</span> = append(<span style=color:#a6e22e>arr</span>, <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d: %s\n&#34;</span>, <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>elem</span>)
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=理解>理解</h2><p>どういう理屈で振る舞いが変わったのだろうか？一般的な理屈が知りたい。
２つの要素がある。for文のスコープとクロージャの変数束縛だ。</p><h3 id=for-文のスコープ>for 文のスコープ</h3><p><a href=https://go.dev/ref/spec#For_range>言語仕様 (<code>range</code>つきfor文)</a> によると、<code>range</code> 節を伴ったfor文では、宣言した変数が使い回されるらしい。</p><blockquote><p>The iteration variables may be declared by the &ldquo;range&rdquo; clause using a form of short variable declaration (:=). In this case their types are set to the types of the respective iteration values and their scope is the block of the &ldquo;for&rdquo; statement; they are re-used in each iteration. If the iteration variables are declared outside the &ldquo;for&rdquo; statement, after execution their values will be those of the last iteration.</p></blockquote><h3 id=クロージャの変数束縛>クロージャの変数束縛</h3><p><a href=https://go.dev/ref/spec#Function_literals>言語仕様 (関数リテラル)</a>
によると関数リテラル（クロージャ）は定義もとの変数を共有するとのこと。</p><blockquote><p>Function literals are closures: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.</p></blockquote><h3 id=問題の説明>問題の説明</h3><p>最初の例では、forループで宣言された変数 <code>i</code> をすべての関数リテラルが共有した。
最初のforループが終わったあとの変数 <code>i</code> の値は最後の繰り返しでの値になる。なのですべて 2: bang` と表示した。</p><p>２つ目の例では、forループの中で、毎回変数 <code>i</code> を宣言、定義した。for文が代入する変数<code>i</code>は、for文がイテレーションで定義したものではなく、はじめに定義したものなのでそれぞれのクロージャは影響を受けない（クロージャはfor文の各繰り返しのブロックと変数を共有するが、ブロックはすぐに終了してそれぞれのクロージャだけが変数にアクセスしうるようになる）。
したがってそれぞれのクロージャは別々の値をプリントする。</p><h2 id=あとがき>あとがき</h2><p>すっきりした。嬉しい。</p><p>GolangのキャプチャはC++の参照キャプチャと思ってよさそうだろうか。
クロージャの側は多分良いけど、変数の生存期間が違うので類推しないのが安全か。</p><p>言語の理解が進むとその言語をもっと好きになるみたいだ。</p></p></div><div class=page-footer></div></div><footer class=footer-mobile><div class=social-icons></div><div class=footer-mobile-links><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p></div><script src=https://naoyafurudono.github.io/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script></footer></body></html>