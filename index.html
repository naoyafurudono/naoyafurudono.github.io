<!doctype html><html lang=ja><head><meta name=generator content="Hugo 0.147.9"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>ツイートするには長すぎる</title><link rel=apple-touch-icon sizes=57x57 href=/images/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/images/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/images/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/images/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/images/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/images/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/images/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/images/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/images/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/images/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=manifest href=/images/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/images/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><meta property="og:url" content="https://blog.nfurudono.com/"><meta property="og:site_name" content="ツイートするには長すぎる"><meta property="og:title" content="ツイートするには長すぎる"><meta property="og:locale" content="ja"><meta property="og:type" content="website"><meta property="og:image" content="https://blog.nfurudono.com/images/thumbnail.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.nfurudono.com/images/thumbnail.png"><meta name=twitter:title content="ツイートするには長すぎる"><meta name=description content><meta property="og:description" content><meta name=twitter:description content><link rel=stylesheet href=https://blog.nfurudono.com/css/main.min.680546ad85e4ae010fb2c6d6e29f48227e146cc09f57f4dc75b7ae0782d1139e.css><link rel=alternate type=application/rss+xml href=https://blog.nfurudono.com/index.xml title=ツイートするには長すぎる><script async src="https://www.googletagmanager.com/gtag/js?id=G-ES42FPF4D5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ES42FPF4D5")}</script></head><body><nav><header><div class=site-title><a href=/>ツイートするには長すぎる</a></div></header><div class=nav-menu><a class="color-link nav-link" href=/profile/>Profile</a>
<a class="color-link nav-link" href=/tags/>Tags</a>
<a class="color-link nav-link" href=/about/>about</a>
<a class="color-link nav-link" href=/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons><a class=social-icon href=https://twitter.com/furudono2 target=_blank rel=noopener title=Twitter><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M8.991284 24.971612c10.189152.0 15.761088-8.441388 15.761088-15.761088C24.752372 8.970656 24.747512 8.731868 24.736496 8.494376 25.818008 7.712564 26.758256 6.737 27.5 5.62622c-.992628.440856-2.060748.738072-3.181248.871992 1.14372-.685584 2.02176-1.770768 2.435832-3.064176-1.070496.6345-2.25558 1.095984-3.517344 1.344492-1.010772-1.076652-2.450412-1.75014-4.043412-1.75014-3.059424.0-5.540292 2.480868-5.540292 5.539104.0.434808.0487079999999995.857412.14364 1.26306C9.19346 9.599108 5.11106 7.39472 2.3792 4.04294c-.476172.818424-.750168 1.769688-.750168 2.784132.0 1.921968.97794 3.61854 2.464992 4.61106C3.185528 11.41016 2.331788 11.160464 1.585184 10.745096 1.583888 10.768208 1.583888 10.791428 1.583888 10.815728c0 2.683152 1.909764 4.922856 4.4442 5.43078C5.562932 16.373084 5.07326 16.44134 4.56782 16.44134 4.210988 16.44134 3.863876 16.406024 3.526484 16.34144c.70524 2.200824 2.750112 3.802356 5.174928 3.8475-1.896264 1.485756-4.284576 2.37114-6.879924 2.37114C1.374476 22.56008.93362 22.534592.5 22.4834c2.451708 1.571076 5.362524 2.488212 8.491284 2.488212"/></svg>
</a><a class=social-icon href=https://www.instagram.com/donofuru/ target=_blank rel=noopener title=Instagram><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M14.0000238 2.00378571c3.2579524.0 3.6664762.0138095300000001 4.946.0721904800000002C20.222881 2.13421429 21.0949286 2.33702381 21.8579762 2.63359524 22.6468333 2.94011905 23.3158333 3.35030952 23.9827857 4.01721429 24.6496905 4.68416667 25.059881 5.35316667 25.3664524 6.14202381 25.6629762 6.90507143 25.8657857 7.77711905 25.9240238 9.05397619 25.9824048 10.3335 25.9962143 10.7420238 25.9962143 14.0000238 25.9962143 17.2579762 25.9824048 17.6665 25.9240238 18.9460238 25.8657857 20.222881 25.6629762 21.0949286 25.3664524 21.8579762 25.059881 22.6468333 24.6496905 23.3158333 23.9827857 23.9827857 23.3158333 24.6496905 22.6468333 25.059881 21.8579762 25.3664524 21.0949286 25.6629762 20.222881 25.8657857 18.9460238 25.9240238 17.6665 25.9824048 17.2579762 25.9962143 14.0000238 25.9962143 10.7420238 25.9962143 10.3335 25.9824048 9.05397619 25.9240238 7.77711905 25.8657857 6.90507143 25.6629762 6.14202381 25.3664524 5.35316667 25.059881 4.68416667 24.6496905 4.01721429 23.9827857c-.66690477-.6669524-1.07709524-1.3359524-1.38361905-2.1248095-.29657143-.7630476-.49938095-1.6350952-.55761905-2.9119524C2.01759524 17.6665 2.00378571 17.2579762 2.00378571 14.0000238 2.00378571 10.7420238 2.01759524 10.3335 2.07597619 9.05397619 2.13421429 7.77711905 2.33702381 6.90507143 2.63359524 6.14202381c.30652381-.78885714.71671428-1.45785714 1.38361905-2.12480952.66695238-.66690477 1.33595238-1.07709524 2.12480952-1.38361905C6.90507143 2.33702381 7.77711905 2.13421429 9.05397619 2.07597619 10.3335 2.01759524 10.7420238 2.00378571 14.0000238 2.00378571zm0 2.16147619C10.796881 4.1652619 10.4174524 4.1775 9.1525 4.23521429 7.98288095 4.28854762 7.34769048 4.48397619 6.92497619 4.6482619 6.36502381 4.86588095 5.96540476 5.12583333 5.54564286 5.54564286c-.41980953.4197619-.67976191.81938095-.89738096 1.37933333-.16428571.42271429-.35971428 1.05790476-.41304761 2.22752381C4.1775 10.4174524 4.1652619 10.796881 4.1652619 14.0000238 4.1652619 17.203119 4.1775 17.5825476 4.23521429 18.8475 4.28854762 20.017119 4.48397619 20.6523095 4.6482619 21.0750238 4.86588095 21.6349762 5.12588095 22.0345952 5.54564286 22.4543571 5.96540476 22.8741667 6.36502381 23.134119 6.92497619 23.3517381 7.34769048 23.5160238 7.98288095 23.7114524 9.1525 23.7647857 10.4173095 23.8225 10.7966429 23.8347381 14.0000238 23.8347381 17.2033571 23.8347381 17.5827381 23.8225 18.8475 23.7647857 20.017119 23.7114524 20.6523095 23.5160238 21.0750238 23.3517381 21.6349762 23.134119 22.0345952 22.8741667 22.4543571 22.4543571 22.8741667 22.0345952 23.134119 21.6349762 23.3517381 21.0750238 23.5160238 20.6523095 23.7114524 20.017119 23.7647857 18.8475 23.8225 17.5825476 23.8347381 17.203119 23.8347381 14.0000238 23.8347381 10.796881 23.8225 10.4174524 23.7647857 9.1525 23.7114524 7.98288095 23.5160238 7.34769048 23.3517381 6.92497619 23.134119 6.36502381 22.8741667 5.96540476 22.4543571 5.54564286 22.0345952 5.12583333 21.6349762 4.86588095 21.0750238 4.6482619 20.6523095 4.48397619 20.017119 4.28854762 18.8475 4.23521429 17.5825476 4.1775 17.203119 4.1652619 14.0000238 4.1652619zm0 13.8334762c2.2084286.0 3.9987143-1.7902857 3.9987143-3.9987143.0-2.2084762-1.7902857-3.9987619-3.9987143-3.9987619-2.2084762.0-3.9987619 1.7902857-3.9987619 3.9987619.0 2.2084286 1.7902857 3.9987143 3.9987619 3.9987143zm0-10.15895239c3.4021905.0 6.1601905 2.75799999 6.1601905 6.16023809.0 3.4021905-2.758 6.1601905-6.1601905 6.1601905-3.4022381.0-6.16023809-2.758-6.16023809-6.1601905.0-3.4022381 2.75799999-6.16023809 6.16023809-6.16023809zm7.8431429-.24338095c0 .79504762-.644523800000002 1.43952381-1.4395715 1.43952381C19.6085952 9.03592857 18.9640714 8.39145238 18.9640714 7.59640476S19.6085952 6.15683333 20.4035952 6.15683333c.795047699999998.0 1.4395715.64452381 1.4395715 1.43957143z"/></svg>
</a><a class=social-icon href=https://www.linkedin.com/in/naoya-furudono target=_blank rel=noopener title=LinkedIn><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M2 3.654102c0-.95502059.79442509-1.73012354 1.77383592-1.73012354H24.2261641C25.2058917 1.92397846 26 2.69908141 26 3.654102V24.3462148C26 25.3015521 25.2058917 26.0760215 24.2261641 26.0760215H3.77383592C2.79442509 26.0760215 2 25.3015521 2 24.3465315V3.65378524 3.654102zM9.27526132 22.1415901V11.2356668H5.65030092V22.1415901H9.27557808 9.27526132zM7.46341463 9.74691162c1.2638581.0 2.05068103-.83750395 2.05068103-1.88406715C9.49033893 6.79252455 8.72727273 5.97846056 7.48748812 5.97846056c-1.24073487.0-2.05099778.81406399-2.05099778 1.88438391.0 1.0465632.78650618 1.88406715 2.00316756 1.88406715h.02343998H7.46341463zM11.2815965 22.1415901h3.6246436v-6.089642C14.9062401 15.7263225 14.9299968 15.4000634 15.0256573 15.1675641c.261957499999999-.6515679.8584099-1.3259423 1.8599936-1.3259423 1.3113716.0 1.836237 1 1.836237 2.4662654v5.8337029h3.6246436V15.8885017c0-3.349699-1.7880899-4.9084574-4.172949-4.9084574-1.9553373.0-2.814064 1.0928097-3.2910991 1.8371872H14.9065569v-1.581248H11.2819132C11.3291099 12.2591067 11.2815965 22.1419069 11.2815965 22.1419069V22.1415901z"/></svg>
</a><a class=social-icon href=https://github.com/naoyafurudono target=_blank rel=noopener title=GitHub><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M13.9988029 1.32087331C6.82105037 1.32087331 1 7.14112562 1 14.3212723c0 5.7436386 3.72454649 10.6157955 8.89038951 12.3348169C10.5408085 26.7757983 10.7778323 26.374374 10.7778323 26.0296121 10.7778323 25.7215609 10.7666595 24.9035493 10.760275 23.8189856 7.14426471 24.6042767 6.38131925 22.0760223 6.38131925 22.0760223c-.59136253-1.5019491-1.44369072-1.9017772-1.44369072-1.9017772C3.75729765 19.3682044 5.02701126 19.3841656 5.02701126 19.3841656 6.33183953 19.4759425 7.01817121 20.7241085 7.01817121 20.7241085c1.15958133 1.9863716 3.04300319 1.4125664 3.78360289 1.0797753.1181129-.8395592.4540962-1.4125663.8251942-1.7373768C8.74038491 19.7385043 5.70536235 18.6228163 5.70536235 13.6413251c0-1.4189508.50676816-2.5801283 1.33834679-3.4883207C6.90963504 9.82420367 6.46351945 8.50181809 7.17139875 6.71256734c0 0 1.09094816-.34955032 3.57451115 1.33276037C11.78259 7.75642995 12.8950858 7.61277914 14.000399 7.60719272 15.1049142 7.61277914 16.2166119 7.75642995 17.2548881 8.04532771c2.4819669-1.68231069 3.571319-1.33276037 3.571319-1.33276037C21.5356825 8.50181809 21.0895669 9.82420367 20.9562909 10.1530044 21.7894656 11.0611968 22.2922435 12.2223743 22.2922435 13.6413251c0 4.9942601-3.039811 6.0931889-5.935173 6.4148071.4660671.401424200000001.8818564 1.194696.8818564 2.4077473C17.2389269 24.2012564 17.2229657 25.603448 17.2229657 26.0296121 17.2229657 26.3775663 17.4575954 26.7821827 18.116793 26.6552912 23.2786458 24.9322794 27 20.0633148 27 14.3212723 27 7.14112562 21.1789496 1.32087331 13.9988029 1.32087331"/></svg></a></div><p><a href=https://github.com/naoyafurudono/naoyafurudono.github.io target=_blank rel=noopener>source of this site</a></p><p><a href=https://gohugo.io target=_blank rel=noopener></a></p><p>©2025 Naoya Furudono</p><script src=https://blog.nfurudono.com/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script><a target=_blank rel="noopener noreferrer" href=https://github.com/naoyafurudono/naoyafurudono.github.io/actions><img src=https://github.com/naoyafurudono/naoyafurudono.github.io/actions/workflows/gh-pages.yml/badge.svg alt="github pages deploy status" style=max-width:100%></a><p><a href="https://www.amazon.jp/hz/wishlist/ls/1JBRXP4JZZ21T?ref_=wl_share">欲しい本リスト</a></p><p><a href="https://www.amazon.jp/hz/wishlist/ls/3TT5GR81VZPHP?ref_=wl_share">欲しいものリスト</a></p></footer></nav><div id=content class=content-container><div class=article-content><div><a href=https://zenn.dev/nfurudono>Zenn</a>を試しに使って見ています。最新の記事はZennを参照してください。</div><article><h1><a href=https://blog.nfurudono.com/posts/ai-management/>生成AIとマネジメント階層の平坦化</a></h1><div><p><p>「アート・オブ・プロジェクトマネジメント」を読んでいる。https://www.oreilly.co.jp/books/9784873112992/
大体のタスクには1/3の法則が適用できるとしている。つまり、タスクは設計・実装・テストの3段階に別れていて、ざっくりスケジュールも3等分できる、みたいな主張（記憶で書いているので正確なことは本を参照してください）をしている。</p><p>ここからは100%僕の自論。マネジメントする人は基本的に実装フェーズをマネジメント対象の人に委譲するのではないだろうか。
3段階に分割されたタスクのそれぞれのフェーズはやはりタスクであって、再帰的にまた3段階に分割されると考えている。仕事を作るフェーズが設計、それを実際に行うフェーズが実装、その実装が欲しかったやつなのかを確かめるのがテストである。そう思うとマネジメントする人は設計やテストを実は自身が行っていて、実装フェーズだけを他者に任せていると言えそう（かける時間を考えると多少無理がありそうな気もするがひとまず気にしない）。</p><p>ところでマネジメントの階層構造は浅いほど純粋な実装の割合が高まる。純粋な実装の割合を説明する。マネジメントの階層構造は全てのノードで枝が三つの木構造をなす。それぞれの枝は設計・実装・テストに対応する。ノードはタスクを表す。ルートから実装の枝だけを辿った先の末端のノードが純粋な実装である。純粋な実装が欲しいものであることを保証するために設計が存在して、その設計を満たすことを保証するためにテストが存在する。実際の価値を生み出すのは純粋な実装である。</p><p>純粋な実装の割合を高めるためにはマネジメントの階層を浅くして、余分な設計やテストを削減すれば良い。つまりマネジメントレイヤを減らすこと、息を止めてできる実装のサイズを大きくすることが効く。理想的には全ての主体がマネジメントのトップにいる（マネジメントの不要な組織）と効率が最大になる。問題に対する能力の問題でそれが叶わないケースが多いだろう。理想的には全員が最強な集まりが最強なのだ。社長を100人集めてそれぞれの組織の実行に必要な能力を社長に宿らせれば、100人だけで100社分のアウトプットができる。確かに効率が理想的である。</p><p>さて、生成AIの登場によって人間ではなくAIにタスクを以前よりも段違いに任せられるようになってきた。普段生成AIを使っている我々は知っているのだが、やはり設計とテストを僕たちがやって、実装を生成AIに任せるという生成AIのマネジメントをやっている。生成AIのおかげで僕たちはタスクの1/3を自動化できるようになったのだ。これはこれまでの人間をマネジメントする状況と変わらない。一方で、生成AIは人間よりもだいぶ汎用的で素早い。そのため人間ほどの問題の分割統治が必要ないだろうと思う。これはマネジメントの階層を浅くすることに寄与する。下手にマネジメント階層を深めないで社長が直接生成AIを使って実現できるならば、マネジメント階層の深さは理想的になるのだ。</p><p>極端なパタンについて述べたが、現実にも生成AIはマネジメントの階層を浅くする方に有利な技術だろう。組織は今後もっと浅いマネジメント階層になっていくのではないだろうか。つまり仕事では自律的な行動がこれまで以上に求められることになっていく（昔からこの傾向はずっとそう？）。</p><p>追記: 価値観が疑われると悲しいので言い訳を書いておきます。ここでの主張は思考実験であって、単純化するとこういう考え方があってよいだろうという主張です。心の底から社長100人の組織が最強の組織だと思っている訳ではないし、たくさん無理な仮定や推論を置いています。マネジメントがタスクをこなすための木構造である、とか言っているがそんなわけがないし。</p><h2><a href=#%e5%b9%b3%e5%9d%a6%e3%81%ab%e3%81%99%e3%82%8b%e3%81%9f%e3%82%81%e3%81%ae%e3%82%a8%e3%83%b3%e3%82%b8%e3%83%8b%e3%82%a2%e3%83%aa%e3%83%b3%e3%82%b0 id=平坦にするためのエンジニアリング class=anchor aria-hidden=true>平坦にするためのエンジニアリング</a></h2><p>生成AIは実装をしてくれるのは間違い無いのだけど、設計とテストをする能力も備えている。とはいえそのための段取りがあるとないとでは当然ながらその成果が異なる。設計・実装・テストを効果的に遂行できるような環境を用意することが生成AIを使役してより平坦なマネジメント階層を構築するのに有効である。</p><h3><a href=#%e8%a8%ad%e8%a8%88%e3%82%92%e3%81%86%e3%81%be%e3%81%8f%e3%82%84%e3%82%8b%e3%81%9f%e3%82%81%e3%81%ae%e6%ba%96%e5%82%99 id=設計をうまくやるための準備 class=anchor aria-hidden=true>設計をうまくやるための準備</a></h3><ul><li>コンテキストを共有すること<ul><li>そのタスクの背景・目的を共有する</li><li>例えば大きなタスクを分解した中の一つのタスクとしての位置付けであれば、そのとき実現してほしいタスクだけでなく大きなタスクを共有した上でそこに含まれるタスクの一つをやってほしい、というように依頼すれば背景や目的を伝えられる。僕の実感として良い成果が得られるように感じる。Claude CodeでTODOリストを作成して一個ずつこなしていくのはこの手法の一つのインスタンスだと思う。</li></ul></li></ul><h3><a href=#%e6%a4%9c%e8%a8%bc%e3%82%92%e3%81%86%e3%81%be%e3%81%8f%e3%82%84%e3%82%8b%e3%81%9f%e3%82%81%e3%81%ae%e6%ba%96%e5%82%99 id=検証をうまくやるための準備 class=anchor aria-hidden=true>検証をうまくやるための準備</a></h3><ul><li>検証の観点を共有する<ul><li>コードを書いてくださいと言われただけなら当然検証はしない</li><li>要件を与えれば良いだろうか</li></ul></li><li>検証環境を用意する<ul><li>REPLを用意するとかTDDできるようにするということ</li></ul></li></ul></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/idea>#idea</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2025-06-24 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/coffee/>コーヒーの抽出手法</a></h1><div><p><p>この記事は僕と生成AIとの対話です。</p><p>コーヒーの抽出手法について以下の課題について議論してください。</p><p>ペーパードリップやフレンチプレス、エスプレッソなど様々な手法がありますが、あれらは不必要に凝っているように感じます。粉に挽いたコーヒー豆をお湯につけ煮出し、不要な成分を除去するというステップさえ踏めれば、あとは再現性を高くすることが肝要なはずです。職人技をできるだけ排除すること、片付けや準備を簡単にすることも評価基準に入れたいです</p><p>以上を踏まえて既存手法を比較検討して、さらに新たな効果的な抽出手法を提案してください</p><hr><p>ご指摘の点は、コーヒー抽出の本質を捉えた非常に鋭い視点だと感じます。多くの抽出法が持つ「職人技」や複雑な手順は、コーヒーを淹れる楽しみの一部である一方、本来の目的である「美味しいコーヒーを安定して飲む」ことから遠ざけてしまう側面があることは否めません。</p><p>ご提案の「粉に挽いたコーヒー豆をお湯につけ煮出し、不要な成分を除去する」という本質的なステップに基づき、**「①再現性の高さ」「②職人技の排除」「③準備・片付けの簡便さ」**を最重要の評価基準として、既存手法の比較と新たな抽出手法の提案をさせていただきます。</p><h2><a href=#1-%e6%97%a2%e5%ad%98%e6%8a%bd%e5%87%ba%e6%89%8b%e6%b3%95%e3%81%ae%e6%af%94%e8%bc%83%e6%a4%9c%e8%a8%8e id=1-既存抽出手法の比較検討 class=anchor aria-hidden=true>1. 既存抽出手法の比較検討</a></h2><p>まず、ご提示の基準で主要な抽出手法を再評価してみましょう。</p><table><thead><tr><th style=text-align:left>抽出手法</th><th style=text-align:left>再現性</th><th style=text-align:left>職人技の排除</th><th style=text-align:left>準備・片付けの簡便さ</th><th style=text-align:left>評価</th></tr></thead><tbody><tr><td style=text-align:left><strong>ペーパードリップ</strong></td><td style=text-align:left>△</td><td style=text-align:left>×</td><td style=text-align:left>△</td><td style=text-align:left>お湯の注ぎ方（速度、高さ、円の描き方）という職人技への依存度が高く、再現性は低くなりがちです。器具も比較的多く、準備に手間がかかります。ただし、ペーパーフィルターが微粉や余分な油分をしっかり除去してくれる点は、ご指摘の「不要な成分の除去」において非常に優れています。</td></tr><tr><td style=text-align:left><strong>フレンチプレス</strong></td><td style=text-align:left>○</td><td style=text-align:left>○</td><td style=text-align:left>△</td><td style=text-align:left>お湯を注いで時間を計り、プレスするだけ。職人技が介在する余地が少なく、再現性は高いと言えます。しかし、金属フィルターのため微粉や油分が多く残り、後片付け（粉の処理）が非常に面倒という大きな欠点があります。</td></tr><tr><td style=text-align:left><strong>エスプレッソ</strong></td><td style=text-align:left>×</td><td style=text-align:left>×</td><td style=text-align:left>×</td><td style=text-align:left>マシンの性能に加え、豆の挽き目、タンピング（粉を固める力加減）など、再現性を担保するには高度な技術と経験が必要です。準備・後片付けも最も手間がかかる手法の一つであり、ご要望とは対極にあると言えるでしょう。</td></tr><tr><td style=text-align:left><strong>エアロプレス</strong></td><td style=text-align:left>◎</td><td style=text-align:left>○</td><td style=text-align:left>◎</td><td style=text-align:left>フレンチプレスと同様の浸漬式（お湯につける方式）で再現性が高く、かつペーパーフィルターを使うため後片付けが非常に簡単です。注射器のような形状で、粉がひとかたまりになって捨てられます。ご要望の基準を非常に高いレベルで満たした、既存手法の中では最も合理的な選択肢の一つです。</td></tr><tr><td style=text-align:left><strong>浸漬式ドリッパー</strong>&lt;br>（クレバー、HARIOスイッチ等）</td><td style=text-align:left>◎</td><td style=text-align:left>◎</td><td style=text-align:left>○</td><td style=text-align:left>ドリッパーの底に弁がついており、お湯と粉を一定時間浸漬させた後、スイッチ一つで濾過・抽出が始まります。お湯を注ぐ技術が不要で、再現性は極めて高いです。ペーパーフィルターを使うため後片付けも簡単。これもまた、非常に優れた選択肢です。</td></tr></tbody></table><h3><a href=#%e6%af%94%e8%bc%83%e6%a4%9c%e8%a8%8e%e3%81%ae%e7%b5%90%e8%ab%96 id=比較検討の結論 class=anchor aria-hidden=true>比較検討の結論</a></h3><p>現状の製品では、空気圧を利用する**「エアロプレス」<strong>や、浸漬と透過を両立した</strong>「浸漬式ドリッパー」**が、 ご指摘の思想に最も近い、合理的で優れた抽出法と言えます。</p><h2><a href=#2-%e6%96%b0%e3%81%9f%e3%81%aa%e5%8a%b9%e6%9e%9c%e7%9a%84%e3%81%aa%e6%8a%bd%e5%87%ba%e6%89%8b%e6%b3%95%e3%81%ae%e6%8f%90%e6%a1%88%e3%82%b5%e3%83%bc%e3%83%a2%e3%82%a4%e3%83%9e%e3%83%bc%e3%82%b8%e3%83%a7%e3%83%b3%e3%83%a1%e3%82%bd%e3%83%83%e3%83%89 id=2-新たな効果的な抽出手法の提案サーモイマージョンメソッド class=anchor aria-hidden=true>2. 新たな効果的な抽出手法の提案：「サーモ・イマージョン・メソッド」</a></h2><p>既存手法の優れた点を組み合わせ、さらに理想を追求した、ご家庭にあるもので今日からでも試せる新しい手法を提案します。これを**「サーモ・イマージョン・メソッド（The Thermo-Immersion Method）」**と名付けます。</p><p>この手法の核心は**「①徹底した温度管理」「②攪拌の自動化」「③クリーンな濾過」**の3点です。</p><h3><a href=#%e5%bf%85%e8%a6%81%e3%81%aa%e3%82%82%e3%81%ae id=必要なもの class=anchor aria-hidden=true>必要なもの</a></h3><ol><li><strong>断熱性の高い容器（魔法瓶、保温タンブラーなど）</strong>：抽出中の温度低下を限りなくゼロに近づけ、再現性を極限まで高めます。</li><li><strong>ペーパードリッパーとフィルター</strong>：最も手軽で効果的に「不要な成分」を除去します。</li><li><strong>スケール（はかり）とタイマー</strong>：再現性の基本です。</li><li><strong>コーヒー豆（粉）とお湯</strong></li></ol><h3><a href=#%e6%8a%bd%e5%87%ba%e3%82%b9%e3%83%86%e3%83%83%e3%83%97 id=抽出ステップ class=anchor aria-hidden=true>抽出ステップ</a></h3><ol><li><strong>準備</strong><ul><li>コーヒー豆を計量し、中挽き～やや粗挽きに挽きます。</li><li>断熱容器と、抽出先のサーバー（またはカップ）にお湯を注ぎ、温めておきます。</li></ul></li><li><strong>投入・浸漬</strong><ul><li>温めた断熱容器のお湯を捨て、挽いた粉を入れます。</li><li>スケールの上で容器のゼロ点を合わせ、沸騰したお湯を目標の量まで<strong>一気に注ぎます</strong>。</li><li>すぐに蓋を閉め、タイマーをスタートさせます（例：4分）。</li><li>蓋を閉めたまま、<strong>容器全体をゆっくりと5～6回、逆さにするように攪拌します</strong>。スプーンなどでかき混ぜる必要はありません。これにより、誰がやっても均一な攪拌が可能です。</li></ul></li><li><strong>放置</strong><ul><li>タイマーが鳴るまで、そのまま放置します。断熱容器が抽出温度をほぼ一定に保ち続けます。この間、コーヒーの成分がムラなく、安定して溶け出します。</li></ul></li><li><strong>濾過</strong><ul><li>タイマーが鳴ったら、温めておいたサーバーの上にペーパーフィルターをセットしたドリッパーを置きます。</li><li>断熱容器の蓋を開け、中のコーヒー液を<strong>ドリッパーに静かに全て注ぎ入れます</strong>。</li><li>全ての液体が自然に落ちきるのを待つだけです。</li></ul></li></ol><h3><a href=#%e3%81%93%e3%81%ae%e6%89%8b%e6%b3%95%e3%81%ae%e5%84%aa%e4%bd%8d%e6%80%a7 id=この手法の優位性 class=anchor aria-hidden=true>この手法の優位性</a></h3><ul><li><strong>極めて高い再現性</strong>：お湯の注ぎ方という最大の変動要因を排除。断熱容器により抽出温度が最後まで維持されるため、誰がいつ淹れても味がブレません。</li><li><strong>職人技の完全排除</strong>：求められるのは「計量する」「注ぐ」「待つ」という単純作業のみです。</li><li><strong>準備・片付けが容易</strong>：使用器具は断熱容器とドリッパーのみ。断熱容器は口が広ければ洗いやすく、抽出後の粉はペーパーフィルターごとゴミ箱に捨てるだけで済みます。</li><li><strong>高い品質</strong>：浸漬式により豆の風味を余すことなく引き出し、ペーパーフィルターが雑味や過剰な油分をカットするため、クリーンで甘みの際立つ味わいになります。</li></ul><p>この「サーモ・イマージョン・メソッド」は、コーヒー抽出の複雑さを削ぎ落とし、その本質である「溶解」と「濾過」を、最も合理的かつ安定的に行うことを目指した手法です。ぜひ一度、お持ちの魔法瓶やタンブラーでお試しください。コーヒーの新しい可能性が見えてくるかもしれません。</p><hr><h2><a href=#%e3%82%84%e3%81%a3%e3%81%9f%e3%81%93%e3%81%a8 id=やったこと class=anchor aria-hidden=true>やったこと</a></h2><p>鍋で抽出してペーパーフィルタで濾しました。元々時間とか温度とか測るタイプの人間じゃないので、再現性も何もないことに気がつきました。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/idea>#idea</a>
<a class=tag href=/%20tags/cock>#cock</a></p><p><time>2025-06-22 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/read-nice-books/>良書を読む文化がもっと流行ってほしい</a></h1><div><p><p>この記事は、技術者の成長において「良書を読み込む文化」の重要性を論じた文章です。</p><h2><a href=#%e8%89%af%e6%9b%b8%e3%82%92%e8%aa%ad%e3%81%bf%e8%be%bc%e3%82%80%e3%81%93%e3%81%a8%e3%81%ae%e6%9c%89%e5%8a%b9%e6%80%a7 id=良書を読み込むことの有効性 class=anchor aria-hidden=true>良書を読み込むことの有効性</a></h2><p>新しいメンタルモデルを手にいれるための手法として、良書を読み込むことが有効だと考えます。</p><p>Known unknown（知らないことを知っている、例えばOSにはプロセスとスレッドというのがあるらしいが、何が違うかわからない）な対象を理解するためには、質問に回答してくれるチュータやNotebookLMのようなツールを用いれば良いでしょう（プロセスとスレッドの違いを質問すればいい）。一方で、考え方を新しく身につけるためにはその手法は効きません。なぜなら古いメンタルモデルしか持たない人間が新しいメンタルモデルを獲得するための質問をすることが困難だからです。</p><p>メンタルモデルを新しく説明して頭に叩き込むことは大変です。説明する側はよく整理しないといけない（聞き手が察することには期待できないので）し、聞き手は誤解をしないように注意深く説明を腹落ちさせる必要があります。</p><p>例えば技術研修は新しいメンタルモデルを研修生に叩き込む手段の一つです。やはり大変な営みなので技術研修をする講師には高いレベルのエンジニアの工数を注ぎ込む必要があるし、研修を受ける人々には研修期間中はそれに集中することが許されています。</p><p>技術研修は効果的ですがスケールしません。一方で良書を読み込むことはスケールします。さらに良書は研修よりも洗練されています。なので僕は良書を読み込むことが有効だと考えるのです。</p><p>まず、技術研修がスケールしないことを主張します。講師をアサインする必要があることがネックです。アサインするためには社内に適任者がいるとか、社外から適任者を頑張って呼び出すとかする必要があります。そもそもアサインできないことが多いでしょうし、できたとしても労力と金銭的なコストがかかります。</p><p>良書は安いです。大体の技術書は一万円も出せば購入できます。給料をもらって働いている人間なら程度の差こそあれ世界最高レベルの技術書を年に一回買うことは容易いのではないでしょうか。また良書は簡単に入手できます。Amazonで1分で注文できます。どんなに時間がかかっても、一週間もあれば本が手元に手に入るのではないでしょうか。そして大体の研修に比較して、よりレベルの高い専門家がより労力をかけて作成しています。技術的にも説明としてもレベルが高いはずです。</p><h2><a href=#%e8%89%af%e6%9b%b8%e3%82%92%e8%aa%ad%e3%81%bf%e8%be%bc%e3%81%be%e3%81%aa%e3%81%84%e3%81%ae%e3%81%af%e3%81%aa%e3%81%9c%e3%81%8b id=良書を読み込まないのはなぜか class=anchor aria-hidden=true>良書を読み込まないのはなぜか</a></h2><p>研修をするのはそれはそれで良いとして、研修は受けるのに良書を読み込むことはしない人がいるのはなぜでしょう。要因として以下があるのではないでしょうか</p><ul><li>良書を知らない、見つけられない</li><li>本を読み込むことを選択肢に持っていない</li><li>英語を読むことを選択肢に持っていない</li></ul><p>知らない、見つけられないのはある程度しょうがないでしょう。人に教えてもらうのが有効と思います。幸いなことに社内では本を紹介し合う文化が多少あります。そこで一定解決できるでしょう。インターネットには良書を紹介してくれる人がちらほらいます。アンテナを貼っておくと良いでしょう。</p><p>本を読み込むことを選択肢に持っていないのは経験の問題でしょう。読み込んだことのある人と一緒に読み込む練習をすれば良いと思います。大学の研究室でやられている輪講会はこの目的を持つと考えます。</p><p>また、良書は往々にして英語で書かれています。気合いで読めば読めるので、これも経験の問題でしょう。</p><h2><a href=#%e8%bc%aa%e8%ac%9b%e4%bc%9a%e3%81%ab%e3%82%88%e3%82%8b%e3%82%a2%e3%83%97%e3%83%ad%e3%83%bc%e3%83%81 id=輪講会によるアプローチ class=anchor aria-hidden=true>輪講会によるアプローチ</a></h2><p>輪講会に参加するモチベーションを高めて開催すれば参加してくれるでしょう。参加してくれれば良書を読み込む経験による慣れと、一冊の良書を読み込んだことによる新しいメンタルモデルを身につけることができます。</p><p>社内で二つの輪講会を開催しています。両方を狙って開催しているのが A philosophy of software designの輪講で、慣れを狙ったのが型システムの輪講です。</p><h2><a href=#%e3%81%8a%e3%81%be%e3%81%91%e8%89%af%e6%9b%b8%e3%81%ae%e7%b4%b9%e4%bb%8b id=おまけ良書の紹介 class=anchor aria-hidden=true>おまけ、良書の紹介</a></h2><p>僕が思う良書です。どれも文句なしにおすすめです。どういう領域のメンタルモデルを手に入れられるかはそれぞれの本の冒頭に書いてあるはずです。</p><ul><li>プログラミング in OCaml</li><li>Essentials of Programming Languages</li><li>A Philosophy of Software Design</li><li>プログラミング言語Go</li><li>K and R</li><li>数学文章作法</li></ul><h2><a href=#%e3%81%8a%e3%81%be%e3%81%91%e3%82%a4%e3%83%b3%e3%82%bf%e3%83%bc%e3%83%8d%e3%83%83%e3%83%88%e3%81%ab%e3%81%af%e8%89%af%e6%9b%b8%e3%82%92%e7%b4%b9%e4%bb%8b%e3%81%97%e3%81%a6%e3%81%8f%e3%82%8c%e3%82%8b%e4%ba%ba id=おまけインターネットには良書を紹介してくれる人 class=anchor aria-hidden=true>おまけ、インターネットには良書を紹介してくれる人</a></h2><ul><li><a href=https://izumisy.work/>https://izumisy.work/</a></li><li><a href=https://zenn.dev/yoshiko>https://zenn.dev/yoshiko</a><ul><li>本ではなくインターネットの記事の紹介が多いですが、ご本人の記事もそこで引用される記事も良いものと感じます</li></ul></li><li><a href=https://ohbarye.hatenablog.jp/>https://ohbarye.hatenablog.jp/</a></li></ul><p>パッとはそんなに出てこなかったです。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/book>#book</a>
<a class=tag href=/%20tags/idea>#idea</a></p><p><time>2025-06-15 +0900</time>
lastmod: <time>2025-06-24 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/read-talent-is-overrated/>「究極の鍛錬」を読んだ</a></h1><div><p><p><a href=https://amzn.asia/d/6Wbkscq>「究極の鍛錬」</a>を読んだ。
A Philosophy of Software Design の冒頭で紹介されていて気になったので読んだ。日本語のタイトルはだいぶ怪しいし表紙も僕はギョッとしてしまったのだけど、内容は真っ当そうな感じがした。それなりに面白くて2,3回の読書で読み切った。なんだって！みたいなことは書かれていなくて、まあそうだろうなという内容ばかりではあるのだけど、そういうことを主張する人が存在することをしれたことと、色々推論した結果を読み込めたことが嬉しい（ここ何年かそういうパターンの読書が増えてきた。エコーチェンバーになっていそう）。改めてこの手のことを考えるきっかけになったし、今の自分の状況をこの本の視点で振り返るきっかけになった。</p><p>この本の他には、学問のすすめ、エミール、各種幸福論がその類の本だと思う。</p><p>本の内容に触れる。何かの専門領域ですごくなるためには練習を適切にたくさんする必要がある、みたいなことが主張されている。適切な練習をすることが難しくて、モチベーション、観察、フィードバック、指導とかがそれに影響を与えるとも。練習と実践は違うのであって、単に経験年数を積んでもうまくなるとは限らない、とかは印象的。その手の話ってキャリアとか成長とかを考えるときに気にする話題だし頭を悩ませるものではあるが、ここで議論をショートカットできるようになったのはいいこと。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/book>#book</a></p><p><time>2025-05-25 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/avoid-23-59-59/>23:59:59という時刻を扱うのはやめよう</a></h1><div><p><p>この記事は生成AIを使って書いた記事です。ほとんど生成したものですが、レビューしてありますし加筆修正を人間が行なっています。</p><hr><p>プログラミングやシステム設計において、しばしば「23:59:59」という時刻が“終端”（end of day）として扱われます。しかし、このアプローチには多くの落とし穴（pitfalls）や混乱が潜んでいます。本稿では、なぜ23:59:59のような終端時刻を避けるべきかを整理し、より堅牢で明快な代替手法をご紹介します。</p><h2><a href=#%e8%aa%b2%e9%a1%8c id=課題 class=anchor aria-hidden=true>課題</a></h2><h3><a href=#1-%e5%a2%83%e7%95%8c%e5%80%a4boundary-value%e3%81%ae%e5%95%8f%e9%a1%8c id=1-境界値boundary-valueの問題 class=anchor aria-hidden=true>1. 境界値（Boundary Value）の問題</a></h3><ul><li><strong>オフバイワンエラー（Off-by-one Error）</strong>
23:59:59を終了時刻として設定すると、しばしば「23:59:60」や「24:00:00」をどう扱うかで混乱が生じます。特に、うるう秒（leap second）の挿入時には「23:59:60」が発生し、想定外のバグを誘発することがあります。</li><li><strong>不明瞭な閉区間（Closed Interval）と開区間（Half-open Interval）</strong>
23:59:59を含むか否か、すなわち区間を[00:00:00, 23:59:59]（閉区間）で扱うのか、[00:00:00, 23:59:59)（半開区間）で扱うのかが曖昧になり、仕様書（specification）と実装に齟齬が生じがちです。</li></ul><h3><a href=#2-%e6%97%a5%e4%bb%98%e5%a4%89%e6%9b%b4%e3%81%a8%e3%81%ae%e9%bd%9f%e9%bd%ac id=2-日付変更との齟齬 class=anchor aria-hidden=true>2. 日付変更との齟齬</a></h3><ul><li><strong>日次バッチ（Daily Batch）とカレンダー表示</strong>
例えば、日次バッチ処理を「23:59:59までのデータを集計」と定義すると、処理が終わるわずかな遅延で翌日の00:00:00以降のデータが取りこぼされたり、重複集計されたりする恐れがあります。</li><li><strong>ユーザーインターフェース（UI）の混乱</strong>
ユーザーに「23:59:59表示」を強いると直感的ではなく、かえって誤操作を招くことがあります。多くの人にとって「23:59:59」はピンと来にくく、特にミリ秒（milliseconds）やタイムゾーン（time zone）をまたぐ場合の理解が難しくなります。</li></ul><h3><a href=#3-%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e5%ae%9f%e8%a3%85%e3%81%ae%e8%a4%87%e9%9b%91%e5%8c%96 id=3-システム実装の複雑化 class=anchor aria-hidden=true>3. システム実装の複雑化</a></h3><ul><li><strong>データベース（Database）のクエリ</strong>
<code>WHERE timestamp &lt;= '2025-04-30 23:59:59'</code> といった条件は、ミリ秒精度のタイムスタンプやタイムゾーンが絡むと正確性を欠きやすいです。</li><li><strong>テスト（Testing）とモック（Mock）の難易度</strong>
テスト時に23:59:59を意図的に生成・モックするのは手間がかかり、テストケースの網羅性を落とす原因となります。</li></ul><h2><a href=#%e8%a7%a3%e9%87%88%e3%82%92%e5%a4%89%e3%81%88%e3%81%a6000000240000%e3%82%92%e6%89%b1%e3%81%86 id=解釈を変えて000000240000を扱う class=anchor aria-hidden=true>解釈を変えて00:00:00(24:00:00)を扱う</a></h2><p>23:59:59を扱いたいときは、きっと何かの期間の終わりを表すことを目的としているでしょう。「終わりの時刻まで」、と捉える代わりに終わりの時刻の直前までと捉えることで、23:59:59ではなく00:00:00を扱えば済むようになってすっきりします。具体的には以下の通りです。</p><h3><a href=#%e5%8d%8a%e9%96%8b%e5%8c%ba%e9%96%93half-open-interval%e3%82%92%e4%bd%bf%e3%81%86 id=半開区間half-open-intervalを使う class=anchor aria-hidden=true>半開区間（Half-open Interval）を使う</a></h3><ul><li><strong>[開始, 終了) の形式</strong>
例：[2025-04-01 00:00:00, 2025-05-01 00:00:00)<ul><li>「2025-04-01 00:00:00以上かつ2025-05-01 00:00:00未満」という明確な条件設定が可能。</li><li>オフバイワンエラーを防ぎ、うるう秒も意識不要。</li></ul></li></ul><h3><a href=#iso-8601%e3%81%ae2400%e3%82%92%e6%b4%bb%e7%94%a8%e3%81%99%e3%82%8b id=iso-8601の2400を活用する class=anchor aria-hidden=true>ISO 8601の24:00を活用する</a></h3><ul><li><strong>「24:00」表記</strong><ul><li>同日23:59:59の次に位置づけられるため、論理的な終端（end-of-day）を明示できます。</li><li>例：<code>2025-04-30T24:00:00</code> は <code>2025-05-01T00:00:00</code> と同一視されます。</li><li>ただし、すべてのライブラリがサポートしているわけではない点に注意。</li></ul></li></ul><hr><p>23:59:59を終端時刻として安易に扱うのは、多くの境界値エラーや実装・運用の混乱を招く原因となります。代わりに、半開区間（half-open interval）[開始, 終了)やISO 8601の24:00表記を採用し、仕様（spec）から実装（implementation）、テスト（testing）まで一貫して明確な時刻管理を行いましょう。これにより、バグの減少と運用コストの削減が期待できます。</p><hr><p><strong>参考情報</strong></p><ul><li>ISO 8601: 日付及び時刻のデータ要素と交換形式</li><li>ソフトウェアテストにおける境界値分析（Boundary Value Analysis）</li><li>半開区間について過去に調べた記事: <a href=https://dev.nfurudono.com/posts/semi-open-interval/>https://dev.nfurudono.com/posts/semi-open-interval/</a></li></ul><p>以上を踏まえ、次回からは「23:59:59」という時刻を見直し、より堅牢な方法で時刻管理（time management）を実践してみてはいかがでしょうか。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/idea>#idea</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2025-04-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/read-a-philosophy-of-softfare-design/>A Philosophy of Software Designの読書メモ</a></h1><div><p><p>各章のまとめをする。随時僕の思ったことを差し込む。なのでこのドキュメントを読んであの本を読んだ気になってはいけないし、あの本と同じくらいに信頼してはいけない。</p><h2><a href=#preface id=preface class=anchor aria-hidden=true>Preface</a></h2><h3><a href=#%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2%e3%81%ae%e8%a8%ad%e8%a8%88%e3%81%a8%e3%81%8b%e8%89%af%e3%81%84%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2%e3%81%8c%e4%bd%95%e3%81%8b%e3%81%a8%e3%81%8b%e3%81%ae%e8%ad%b0%e8%ab%96%e3%81%8c%e6%9c%aa%e7%86%9f%e3%81%a7%e3%81%82%e3%82%8b id=ソフトウェアの設計とか良いソフトウェアが何かとかの議論が未熟である class=anchor aria-hidden=true>ソフトウェアの設計とか、良いソフトウェアが何かとかの議論が未熟である</a></h3><ul><li>以下のような事項については議論がされている<ul><li>開発プロセス</li><li>開発ツール</li><li>プログラミングテクニック<ul><li>OOP</li><li>functional</li></ul></li><li>デザインパターンとかアルゴリズム</li></ul></li><li>設計については1971の &ldquo;On the Criteria to be used in Decomposing Systems into Modules&rdquo; から発展がない</li></ul><h3><a href=#%e8%a8%ad%e8%a8%88%e6%8a%80%e6%b3%95%e3%82%92%e4%bd%93%e7%b3%bb%e7%9a%84%e3%81%ab%e8%ba%ab%e3%81%ab%e3%81%a4%e3%81%91%e3%81%a6%e8%a4%87%e9%9b%91%e3%81%95%e3%82%92%e6%b8%9b%e3%82%89%e3%81%9b%e3%82%8b%e3%82%88%e3%81%86%e3%81%ab%e3%81%99%e3%82%8b%e3%81%93%e3%81%a8%e3%82%92%e7%9b%ae%e6%8c%87%e3%81%99 id=設計技法を体系的に身につけて複雑さを減らせるようにすることを目指す class=anchor aria-hidden=true>設計技法を体系的に身につけて複雑さを減らせるようにすることを目指す</a></h3><ul><li>分割統治が大きな関心ごとだが、そのための教育はされていない<ul><li>どのように問題を分割するか</li><li>問題の分割を決めることは設計のでかいタスクの一つ</li></ul></li><li>プログラマの品質とか生産性にはそれなりにばらつきがある<ul><li>能力には才能ではなくて良い練習が効くのは一般的に言われているらしい</li></ul></li><li>設計のスキルがプログラマのすごい・普通を分けるだろうと仮定して、学部一年生に対して講義を始めた<ul><li>原理・原則を座学で伝える</li><li>ソフトウェア開発のプロジェクトもやって、それらを活かす練習をする<ul><li>学生はたくさんコードを書いて講師にレビューを受けて改善する</li></ul></li></ul></li><li>その講義で伝えた設計の原則を集めたのがこの本</li><li>この本を書いた人はスタンフォードの教授で色々ソフトウェアを作ってきた</li><li>複雑さを減らすことがどの原則よりも大切</li></ul><h2><a href=#chapter-1-introduction-its-all-about-complexity id=chapter-1-introduction-its-all-about-complexity class=anchor aria-hidden=true>Chapter 1. Introduction (It&rsquo;s all about complexity)</a></h2><h3><a href=#%e8%89%af%e3%81%84%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2%e3%82%92%e3%81%84%e3%81%84%e6%84%9f%e3%81%98%e3%81%ab%e4%bd%9c%e3%82%8b%e3%81%9f%e3%82%81%e3%81%ab%e3%81%af%e8%a4%87%e9%9b%91%e3%81%95%e3%81%ab%e5%af%be%e5%87%a6%e3%81%99%e3%82%8b%e3%81%93%e3%81%a8%e3%81%8c%e5%bf%85%e8%a6%81 id=良いソフトウェアをいい感じに作るためには複雑さに対処することが必要 class=anchor aria-hidden=true>良いソフトウェアをいい感じに作るためには複雑さに対処することが必要</a></h3><ul><li>ソフトウェアはそれがどんなものであるかを表現できれば作れたも同然である。例えば筋肉がなくても作れる</li><li>そのためソフトウェアを書くのを律速する能力は、作っているシステムがどんなものであるかを理解する能力である</li><li>残念なことにプログラムを成長させていくに連れて複雑さは増していく。</li><li>複雑さを増すとそのソフトウェアを理解することは難しくなり、成長させる速度やコストは増す。バグも入る</li><li>開発ツールで複雑さに対処することはできるし、そうしてきた<ul><li>コード生成とかバージョン管理とかプログラミング言語とかはその例</li></ul></li><li>ツールの力だけでなんとかしきることは、とはいえ無理</li><li>ソフトウェアを簡単に作れるようになって、もっとすごいシステムを安価に作れるようになるためにはソフトウェアをシンプルに保つことが必要</li><li>まあ複雑さはどう頑張っても増えるものではあるのだけど、設計をシンプルにしておけばソフトウェアがでかく強力になってもまだ耐えられるようにできる</li></ul><h3><a href=#%e8%a4%87%e9%9b%91%e3%81%95%e3%82%92%e6%b8%9b%e3%82%89%e3%81%99%e3%81%9f%e3%82%81%e3%81%ab%e3%81%af%e4%ba%8c%e3%81%a4%e3%81%ae%e3%82%a2%e3%83%97%e3%83%ad%e3%83%bc%e3%83%81%e3%81%8c%e3%81%82%e3%82%8b id=複雑さを減らすためには二つのアプローチがある class=anchor aria-hidden=true>複雑さを減らすためには二つのアプローチがある</a></h3><ul><li>コードをシンプルで明らかにすること: こっちはまあそうでしょう、と思える<ul><li>名前の付け方に一貫性を持たせる</li><li>特別扱いを減らす</li></ul></li><li>複雑性をカプセル化する。(moduler designと呼ぶらしい)<ul><li>分割統治をするということ</li><li>丁寧に説明すると、でかい問題を解決するために部分問題の証明を忘れられるようにすること</li></ul></li></ul><h3><a href=#%e9%96%8b%e7%99%ba%e8%80%85%e3%81%af%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2%e3%81%ae%e8%a4%87%e9%9b%91%e3%81%95%e3%81%ab%e5%af%be%e5%87%a6%e3%81%97%e7%b6%9a%e3%81%91%e3%82%8b%e5%bf%85%e8%a6%81%e3%81%8c%e3%81%82%e3%82%8b id=開発者はソフトウェアの複雑さに対処し続ける必要がある class=anchor aria-hidden=true>開発者はソフトウェアの複雑さに対処し続ける必要がある</a></h3><p>橋とかのデザインと違って、ソフトウェアはずっと設計を変え続けるもの。この考え方に足していないのがウォーターフォールな開発で、一度に全体を設計したらそれを開発の過程で変更することはなく、もし微妙なところが出ても書く開発対象の範囲内で対処する。</p><p>アジャイル開発は設計を変え続けるアプローチに即している。将来的に開発したいでかいものは見据えつつ全体の設計は後回しにして欲しいソフトウェアのサブセットをまずは設計して開発する。開発の段階でまずそうとわかった設計は、次の開発の前に変更してまずさを潰す。こうすることで設計の問題が小さいうちに課題を発見し解決できる見込みが増える。</p><p>こういうイテレーティブな開発では設計が終わることはない。開発者は常に設計に気をかける必要があるし再設計する必要がある。改善するために小さく刻んで開発しているのだからそれはそう。設計を改善できないのならば、アジャイルに開発する意味がない。</p><p>今日ではアジャイルな開発をしているわけで、開発者常に設計の課題について考える必要がある。設計のことに常に気をかけないということは、常に複雑さに対処しなければならないということ。</p><h3><a href=#%e3%81%93%e3%81%ae%e6%9c%ac%e3%81%ae%e7%9b%ae%e7%9a%84 id=この本の目的 class=anchor aria-hidden=true>この本の目的</a></h3><p>二つある</p><ol><li>ソフトウェアの複雑さを理解すること</li></ol><ul><li>複雑さとは何か</li><li>複雑さは何が問題なのか</li><li>不必要な複雑さを持っていることにどのようにして気がつくか</li></ul><ol><li>ソフトウェア開発にあたって、複雑さを最小化するための個別なテクニックを習得すること</li></ol><h2><a href=#chapter-2-the-nature-of-complexity id=chapter-2-the-nature-of-complexity class=anchor aria-hidden=true>Chapter 2. The Nature of Complexity</a></h2><p>この章では複雑さとは何かや、どのようにシステムが不必要に複雑であるかを見分けるかを議論する。設計がシンプルかを見分けるだけでは設計をシンプルに作ることはできないが、その判断をもとにシンプルに作るためのアプローチをできる。</p><p>設計方針を色々試してみれば良くて、その結果いい感じになるやつを使えば良い。そのいい感じになるかの評価をできるようにすることがこの章の目的である。</p><h3><a href=#%e8%a4%87%e9%9b%91%e3%81%95%e3%81%ae%e5%ae%9a%e7%be%a9 id=複雑さの定義 class=anchor aria-hidden=true>複雑さの定義</a></h3><p>この本で議論を進めるために以下のように複雑さを定義する: 複雑さはソフトウェアシステムの構造に関するもののうち、システムの理解や修正を難しくするものである。</p><p>例えば以下のような例がある</p><ul><li>コード片がどのように動作しているか理解できない</li><li>システムのどこを修正して良いかわからない</li><li>他に影響を与えずにバグ修正をするのがむずい</li></ul><p>要するに、理解と修正が難しければそのソフトウェアシステムは複雑であるということ。それが簡単だったらシンプル。</p><p>システムの複雑さは、コンポーネントの複雑さをその変更頻度で重み付けした上での総和であると思える。</p><p>また、読み手にとっての複雑さと書き手にとっての複雑さは異なる。書き手にとってシンプルであっても読み手にとって複雑であればそれは複雑である。自分がそういうコードの書き手であったら、その分断が起きた理由を探ると良いだろう。そのギャップを埋める必要がこの仕事にはあるのだから。</p><h3><a href=#%e8%a4%87%e9%9b%91%e3%81%95%e3%81%ae%e7%97%87%e7%8a%b6 id=複雑さの症状 class=anchor aria-hidden=true>複雑さの症状</a></h3><p>一般的に三つの兆しがあって、開発を辛くする</p><ul><li>変更範囲の拡大: 簡単にできそうな変更が思ったより大変なパターン。メンタルモデルとその実現方法があっていないときに生じる。メンタルモデルを表現する力が足りていない</li><li>認知負荷: うまく使うためにやらないといけないことが多いことが原因</li><li>unknow unknown: 変更する必要性に気がつけなくなっていること</li></ul><p>unknown unknownが特に辛い。変更範囲が広いのはめんどいのは間違い無いのだけど、全部対処すれば自信を持って変更を完遂できる。一方でunknown unknownは自信を持つために全てのコードを読む必要があって辛い。システムがでかいとそもそも無理。</p><p>設計の目標の一つにシステムを明らかにすることがある。認知負荷とunknown unknownを減らすことにつながる。理解もコーディングもシュッとできるのがいい。何かを考えてそれが実際に通じるかの判断も簡単になる。</p><h3><a href=#%e8%a4%87%e9%9b%91%e3%81%95%e3%81%ae%e5%8e%9f%e5%9b%a0 id=複雑さの原因 class=anchor aria-hidden=true>複雑さの原因</a></h3><p>複雑さの症状をざっと見て、なんでソフトウェア開発が辛くなるのかを議論した。次に複雑さの原因を議論してシステムに問題が入らないように設計できるようになりたい。</p><p>複雑さは依存と不明瞭さによって生じる。ここではそれらをざっくり語って、後の章では細々とした設計での意思決定がどのようにそれらと関係するかをみる。</p><h4><a href=#%e4%be%9d%e5%ad%98 id=依存 class=anchor aria-hidden=true>依存</a></h4><p>扱う対象がそれ単体では理解できない、変更できないときに一緒に変更するやつに依存するという。頻繁に変更するコンポーネントが他のコンポーネントに依存していると、依存されているコンポーネントまで頻繁に変更するハメになる。そこで以下のシステムの複雑さの定義の言い換えを思い出す。</p><blockquote><p>システムの複雑さは、コンポーネントの複雑さをその変更頻度で重み付けした上での総和であると思える。</p></blockquote><p>依存が多いシステムではたくさんのコンポーネントの変更頻度が上がるため、システムの複雑さも大きい。</p><p>特に複雑なコンポーネントを他の変更が多いコンポーネントから依存させないことがシステム全体の複雑さを抑えるために効く。</p><h4><a href=#%e4%b8%8d%e6%98%8e%e7%9e%ad%e3%81%95 id=不明瞭さ class=anchor aria-hidden=true>不明瞭さ</a></h4><p>大事な要素が明らかになっていないことを指す。例えば数値の単位がわからないとか、名前がなんの意味も表してないとか。あるいは依存が存在することが明らかじゃ無いのもそう。一貫性のなさもこの要因で、同じ名前が異なる用途に使われているとやばい。</p><p>ドキュメントがやばいことが多くの原因で、コメントをちゃんと書けばよかったりする。デザインが良ければそもそも明らかであってドキュメントを不要にすることもできる。</p><p>めっちゃコメントがいるような場合はデザインがまずいことの兆しだし、明瞭さを増すためにはシステムの設計を改善するのが正攻法。</p><p>依存は変更範囲の拡大と認知負荷に作用して、不明瞭さはunknown unknownと認知負荷に作用する。依存と不明瞭さを下げる設計技法が手に入ればソフトフェアの複雑さを下げられるはずだ。</p><h3><a href=#%e8%a4%87%e9%9b%91%e3%81%95%e3%81%af%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e5%85%a8%e4%bd%93%e3%81%ae%e3%82%82%e3%81%ae id=複雑さはシステム全体のもの class=anchor aria-hidden=true>複雑さはシステム全体のもの</a></h3><p>一個一個の細かい要因が全体を壊すほどの複雑さ単独で生むわけではなくて、複数が重なり合って首が回らなくなるもの。対処するためには &ldquo;zero tolerance&rdquo; philosophy に従うべきらしい。</p><p>複雑さは既存のコードベースを修正することを難しく、またリスキーにする。</p><h2><a href=#chapter-3-working-code-isnt-enough-strategic-vs-tactical-programming id=chapter-3-working-code-isnt-enough-strategic-vs-tactical-programming class=anchor aria-hidden=true>Chapter 3. Working Code Isn&rsquo;t Enough (Strategic vs. Tactical Programming)</a></h2><p>プログラミングタスクに際してのマインドセットは良いソフトウェア設計のために大事な要素である。</p><p>良いデザインを得るためには、すぐにコードが動くことを至上とするするtacticalなマインドセットではなくて、綺麗なデザインのために時間をかけた上で問題点を修正する方針が必要だ。</p><p>この章ではなんで戦略的なアプローチが良い設計を生むのか、そして戦略的なアプローチの方が結果的には安いことを主張する。</p><h3><a href=#tactical-programming%e3%81%a8%e3%81%af%e3%81%a9%e3%82%93%e3%81%aa%e3%81%8b id=tactical-programmingとはどんなか class=anchor aria-hidden=true>Tactical Programmingとはどんなか</a></h3><p>多くの開発ではtacticalな手法が取られる。例えばバグを治すためにその場しのぎの対症療法をするようなこと。確かにそのときは早いのだけど、良いシステムの設計が得られることはないだろう。そういうときに、少しずつ不必要な複雑さがシステムに入り込む。</p><p>そのうちしんどさに気がついてリファクタリングとかをしたくなるのだけれど、仕事には期限があって新しい機能を追加しないといけないからやはり複雑さは残ったままになる。今見えている問題にはすぐに効くパッチだけ当てて、全体をよくすることはない。</p><p>そのうちマジでヤバくなるのだけど、その頃には全体を治すのが大変になっていて、当然そんな時間を取ることはできないので諦めてずっとその場しのぎの変更を入れ続けることになる。</p><p>一回tacticalな道に足を踏み入れるとそこから抜け出すことは容易ではないのだ。</p><h3><a href=#storategic-programming%e3%81%a8%e3%81%af%e3%81%a9%e3%82%93%e3%81%aa%e3%81%8b id=storategic-programmingとはどんなか class=anchor aria-hidden=true>Storategic Programmingとはどんなか</a></h3><p>まともなソフトウェア設計者になるための第一歩は動くだけのコードでは不十分であることに気が付くことだ。タスクを早く終わらせるために不必要な複雑さをコードに入れることは許されない。コードは既存のものに追加されていくものなので、今書かれているコードを将来誰かが編集することにもなる。なので今書くコードは動くだけでなく素晴らしい設計を体現することを目標にしないといけない（もちろん動く必要はあるけど）。</p><p>Strategic programmingには投資の心構えが必要で、例えばよく考えることに時間を投資するとか、いくつか設計してみて一番綺麗なやつを選ぶとかする。変更の可能性をいくつか想定してみてまあいけそうだと思えることを検証する。良いドキュメントを書くこともその一環である。
colliraryとして、良い設計をするためにはソフトウェアを変更する能力が効く、が主張できる。ソフトウェアを変更する能力がないひとは変更に強いことを主張できないが、変更する能力がある人はその設計がどこまでの変更をどのくらいの大変さで実施できるかを評価できる。他にも、設計がまずいことに気がついたときに目を瞑るのではなくちょっと時間をかけてよくする必要がある。</p><h3><a href=#%e3%81%a9%e3%82%8c%e3%81%8f%e3%82%89%e3%81%84%e6%8a%95%e8%b3%87%e3%81%99%e3%82%8b%e3%81%b9%e3%81%8d%e3%81%8b id=どれくらい投資するべきか class=anchor aria-hidden=true>どれくらい投資するべきか</a></h3><p>最初に全部設計するのは効果的ではなさそう。理想的な設計は作りながらわかっていくものなので、少しずつのたくさんの投資を基礎の上で行うこと。
1-2割の時間を設計にかけることをここでは提案している。スケジュールを破壊するほどは長くはないし、利益を産むために十分な時間でもあるはず。</p><h3><a href=#%e3%82%b9%e3%82%bf%e3%83%bc%e3%83%88%e3%82%a2%e3%83%83%e3%83%97%e3%81%a0%e3%81%8b%e3%82%89%e3%81%bf%e3%81%9f%e3%81%84%e3%81%aa%e8%a8%80%e3%81%84%e8%a8%b3%e3%81%af%e9%80%9a%e3%81%98%e3%81%aa%e3%81%95%e3%81%9d%e3%81%86 id=スタートアップだからみたいな言い訳は通じなさそう class=anchor aria-hidden=true>スタートアップだから、みたいな言い訳は通じなさそう</a></h3><p>Facebook, Google, VMWareを引き合いに出してstorategicにやった方が良さそうですよ、と主張している。意味的に新しいことはここでは特に言ってなさそう。よくある（本当によくある）tactical programmingの正当化への反論をここではしている。</p><h3><a href=#%e6%95%99%e8%a8%93 id=教訓 class=anchor aria-hidden=true>教訓</a></h3><ul><li>storategic programmingをしろ、効果は思ったよりもすぐに現れる</li><li>明日ではなく今日やるもの</li><li>全てのエンジニアが良い設計への投資をすることが効果的</li></ul><h2><a href=#chapter-4-modules-should-be-deep id=chapter-4-modules-should-be-deep class=anchor aria-hidden=true>Chapter 4. Modules Should Be Deep</a></h2><p>開発者がシステム全体ではなく一部の複雑さだけに対処すれば良い方にすることを目的とするソフトウェア設計着本がある。
Modular designと呼ばれていて、ソフトウェアの複雑さをなんとかするためにすごく大切。</p><p>この章ではこの基本的な原則を解説する。</p><h3><a href=#modular-design%e3%81%a8%e3%81%af%e4%bd%95%e3%81%8b id=modular-designとは何か class=anchor aria-hidden=true>Modular designとは何か</a></h3><p>ソフトウェアシステムを複数の（それなりに独立した）モジュールに分解する。ここでいうモジュールはクラスかもしれないし、サブシステムかもしれないし、サービスかもしれない。理想的にはそれぞれのモジュールは他には全く依存しないで欲しい、つまり開発者はそれぞのれモジュールを他のモジュールのことを完全に忘れて開発できるようになっていて欲しい。そういう理想的な世界では、ソフトウェアシステムの複雑さはそれを構成するモジュールたちの複雑さの中で一番複雑なやつの複雑さである（あれ、そういう定義だったか。まあ気持ちはわかる）。</p><p>現実世界ではそうは問屋が卸さなくて、あるモジュールは他のモジュールの関数とかを呼ぶ必要があって、多かれ少なかれ他のモジュールを知っておく必要がある。モジュールの間いに依存が生じることもあるはず（つまりあるモジュールを変更したら、他のモジュールを変更する必要が出てくるかもしれないということ）。
Modular designの目的はモジュール間の依存を最小化すること。</p><p>依存を管理するためにはモジュールを二つの要素、インターフェースと実装に分けて捉えると良いだろう。モジュールを外から使うために知っておくべきものがインターフェースで、そのモジュールが何をするかを表す。それをどのように実現するかは表さないのが典型的。実装はインターフェースを満たすためのもの。あるモジュールで仕事をする開発者は、他のモジュールのインターフェース、そのモジュールのインタフェース、そのモジュールの実装を頭に入れて働くことになる。他のモジュールの実装を頭に入れる必要はないし、そうしないべきである。</p><p>ここでいうインターフェースはプログラミング言語の意味論で強制されるものに限らなくて、自然言語でドキュメントとして記述されることもある。そのモジュールを使うために開発者が知るべき情報は全てインターフェースの一部である。形式的でない部分はコメントとして書くしかなくて、それが正しいことをプログラミング言語が保証することはできない。そして残念なことにそういう形式的でない部分は複雑でより多い傾向にある。</p><p>明瞭に書かれたインターフェースは開発者がそのモジュールを使うために知る必要のあることを占めることであって、unknown unknownを減らす。</p><h3><a href=#%e6%8a%bd%e8%b1%a1%e5%8c%96 id=抽象化 class=anchor aria-hidden=true>抽象化</a></h3><p>Modular designと関係する概念。抽象化は対象を単純化した見方のことで、重要でない詳細を捨てたもの。複雑なことをしなくてもそれを扱えるようになるので抽象化は便利。</p><p>モジュラなプログラミングではモジュールがインターフェースによってその抽象化を提供することになる。インターフェースはモジュールの単純化された機能を説明することになるということ。モジュールを使うためには重要でない詳細を捨ててそのモジュールを理解すれば済むので嬉しい。</p><p>捨てているのが重要でない部分であるのが大切。抽象化のミスり方には二つある。</p><ol><li>重要でない詳細を抽象化に含めること: 抽象化を複雑にする点でよくない</li><li>重要な詳細を抽象化に含めないこと: 不明瞭なシステムになるのが良くない。抽象化だけをみている開発者はその抽象化を正しく使うために必要な情報を見落とすことになる</li></ol><p>後者のことをfalse abstractionと呼ぶ。一見シンプルだけど実はそうでもないやつ。抽象化を設計するためにはどんな情報が大切かと、どのように大切な情報を減らすかが鍵。</p><h3><a href=#deepshallow-modules-classiti id=deepshallow-modules-classiti class=anchor aria-hidden=true>Deep/shallow modules, classiti</a></h3><p>機能的でシンプルなインターフェースを持つモジュールが最高のモジュールということになりそう。抽象化がうまくいったやつがいい。そういうモジュールのことをdeepなモジュールと呼んでいる。</p><p>反対にインターフェースが複雑な割に大した機能を提供してないものはshallowなモジュール。</p><p>我々はモジュールをdeepにすることを目指すべきであって、そのインターフェースの絶対的なサイズは問題ではない。</p><h3><a href=#%e3%81%be%e3%81%a8%e3%82%81 id=まとめ class=anchor aria-hidden=true>まとめ</a></h3><ul><li>モジュールをインターフェースと実装に分けて捉えることで、その複雑さをシステムの他の部分から隠せる</li><li>そのモジュールを使う側はそのインターフェースだけに気をかければ良い</li><li>大事なことはモジュールが深くなるように設計すること。そうすれば隠蔽できる複雑さを最大化できてシステム全体の複雑さを抑えることに貢献できる</li></ul></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/book>#book</a>
<a class=tag href=/%20tags/idea>#idea</a></p><p><time>2025-04-29 +0900</time>
lastmod: <time>2025-05-17 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/go-time-format/>Goの時刻をフォーマットするときに見るページ</a></h1><div><p><pre><code class=language-go>	DateTime   = &quot;2006-01-02 15:04:05&quot;
</code></pre><p><a href=https://pkg.go.dev/time#pkg-constants>https://pkg.go.dev/time#pkg-constants</a></p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/pl>#PL</a>
<a class=tag href=/%20tags/tech>#tech</a></p><p><time>2025-01-20 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/learn-frontend-test/>wip Next.jsでのテストを自由自在に書けるようになりたい</a></h1><div><p><p>Next.jsのアプリケーションでテストを自由自在に書けるようになることが目的。</p><p>vitestを用いる。アサーションには<code>expect</code>などを使ってマッチャを指定する。
expectや使えるマッチャは<a href=https://vitest.dev/api/expect>https://vitest.dev/api/expect</a>が詳しい。</p><ul><li>テスト戦略の類型とトレードオフの把握</li><li>ユーザインタラクションの再現</li></ul></p></div><div class=post-footer><p><a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2025-01-11 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/go-errors-stacktrace/>漏れなくスタックトレースをGoで取りたい！</a></h1><div><p><p><a href=https://github.com/k1LoW/errors>k1LoW/errors</a> でスタックトレースをエラーにつけられるようになる。便利なのだがトレースをプログラマが明示的に指示しないといけない。設定をコードベースで一回やれば終わりではなく、エラーの発生源で書かないといけない点が気になっている。書くこと自体は許容しているが、漏れがないように人間が頑張るのは許容したくない。漏れをなくすための仕組みを主張する。</p><h2><a href=#k1lowerrors%e3%81%ae%e8%aa%ac%e6%98%8e id=k1lowerrorsの説明 class=anchor aria-hidden=true>k1LoW/errorsの説明</a></h2><p>ライブラリとして使うためにはreadmeの説明で十分だと思うが、議論のためにここでも説明する。以下のように用いる。</p><p><a href=https://go.dev/play/p/Cwp4n-vZONv>https://go.dev/play/p/Cwp4n-vZONv</a></p><pre><code class=language-go>package main

import (
	&quot;encoding/json&quot;

	&quot;github.com/k1LoW/errors&quot;
)

func f() error {
	// このようにWithStackを呼び出した箇所でのスタックトレースがerrorオブジェクトに記録される
	return errors.WithStack(errors.New(&quot;ouch!&quot;)) // ここは11行目
}

func main() {
	err := f()
	// スタックトレースを含んだエラー内容をフォーマットする
	s := errors.StackTraces(err)
	b, _ := json.Marshal(s)
	println(string(b))
}
</code></pre><p>実行すると以下のような出力が得られる。見やすさのために jq にかませてフォーマットした。</p><pre><code class=language-json>[
  {
    &quot;error&quot;: &quot;ouch!&quot;,
    &quot;frames&quot;: [
      {
        &quot;name&quot;: &quot;main.f&quot;,
        &quot;file&quot;: &quot;/tmp/sandbox123757503/prog.go&quot;,
        &quot;line&quot;: 11
      },
      {
        &quot;name&quot;: &quot;main.main&quot;,
        &quot;file&quot;: &quot;/tmp/sandbox123757503/prog.go&quot;,
        &quot;line&quot;: 15
      },
      {
        &quot;name&quot;: &quot;runtime.main&quot;,
        &quot;file&quot;: &quot;/usr/local/go-faketime/src/runtime/proc.go&quot;,
        &quot;line&quot;: 272
      },
      {
        &quot;name&quot;: &quot;runtime.goexit&quot;,
        &quot;file&quot;: &quot;/usr/local/go-faketime/src/runtime/asm_amd64.s&quot;,
        &quot;line&quot;: 1700
      }
    ]
  }
]
</code></pre><p>スタックトレースの先頭 (frames配列の先頭要素) はWithStackを呼び出した位置を指す。</p><p>したがって、アプリケーションの中でのエラーの発生源をスタックトレースから漏れなく特定するためには、<strong>エラーの発生源の全てでWithStackを呼び出す必要がある</strong>。</p><p>なお、WithStackを重ねて呼び出しても問題ようになっている（深いスタックトレースを持つものが生き残るようになっているし、他のも気遣いがされている）。</p><h2><a href=#%e8%83%8c%e6%99%af%e6%97%a2%e5%ad%98%e3%81%ae%e3%82%a2%e3%82%a4%e3%83%87%e3%82%a2 id=背景既存のアイデア class=anchor aria-hidden=true>背景・既存のアイデア</a></h2><p><a href=https://k1low.hatenablog.com/entry/2024/08/13/083000>名前付き返り値とdeferを使って忘れないようにする手法も紹介されている</a>。</p><pre><code class=language-go>func f() (err error) {
	defer (func(){
		err = errors.WithStack(err)
	})()
	b := strings.Builder{}
	_, err := b.Write([]byte(&quot;hello&quot;))
	if err != nil {
		return err
	}
	// ...
}
</code></pre><p>ある程度楽をできるし、この後の議論をした上でもバランスの良い選択肢だと思うが課題も感じている。その課題と解決案を以降で議論する。</p><h2><a href=#%e8%aa%b2%e9%a1%8c id=課題 class=anchor aria-hidden=true>課題</a></h2><ol><li>deferを書くのを忘れそう<ul><li>こちらはリンターでなんとかなるだろう。ここでは深く議論しない</li></ul></li><li>deferの中でerrors.WithStackを呼ぶと、エラーの発生源から離れるため、具体的にどのreturn errで落ちたかがスタックトレースから追えない<ul><li>エラーメッセージから判断できる可能性は大きいけど</li></ul></li></ol><p>二つ目の課題の例を以下に挙げる。fではどの行で落ちたか分からないが、gではどちらのwithStackで生成したかが残る。</p><pre><code class=language-go>func f() (err error) {
	defer (func() {
		err = errors.WithStack(err)
	})()
	if err := ok(); err != nil {
		return err
	}
	if err := ng(); err != nil {
		return err
	}
	return nil
}

func g() (err error) {
	if err := ok(); err != nil {
		return errors.WithStack(err)
	}
	if err := ng(); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func ok() error { return nil }
func ng() error { return errA }
var errA = errors.New(&quot;this is error&quot;)
</code></pre><p><a href=https://go.dev/play/p/SGr1B4sDF9I>https://go.dev/play/p/SGr1B4sDF9I</a> で動かせる。</p><h2><a href=#%e8%a7%a3%e6%b1%ba%e6%a1%88-%e5%9e%8b%e3%81%a7%e9%a0%91%e5%bc%b5%e3%82%8b id=解決案-型で頑張る class=anchor aria-hidden=true>解決案: 型で頑張る</a></h2><p>k1low/errorsでは、errors.WithStackは<code>func(error) error</code> 型を持つ。それを <code>func(error) errors.T</code> とする。ここでTは以下のようなerrorをStackTraceメソッドで拡張したようなインターフェース。</p><pre><code class=language-go>package errors

type T interface {
	error
	StackTraces() stackTraces // 戻り値型には議論の余地があるが、ここでは重要ではない。
}

// 唯一のT型のコンストラクタ
func WithStack(err error) T { ... }
</code></pre><p>スタックトレースを取りたいアプリケーションでは、すべての関数定義で返すエラー型を標準の errorではなく errors.Tとする。そうすると、すべてのreturnされるエラーオブジェクトからスタックトレースを取得できることが保証される。</p><p>以下の二点が嬉しい。</p><ol><li>errors.Tを返す関数しか呼ばない関数は繰り返しerrors.WithStackを呼ぶ必要がなくなる</li><li>errors.WithStackをエラーが発生するたびに (deferの中ではない！) 呼び出すように保証できるので、スタックトレースがちゃんと深くなる</li></ol><p>この方法の問題は以下。人によっては許容できるだろう（ぼくはありだと思っている）。</p><ol><li>すべての関数定義で返すエラー型をerrors.Tに統一する方法が定まっていないこと</li><li>errors.WithStackをたくさん呼ばないといけないこと</li><li>独自のエラーインターフェースを定義していて気持ち悪いこと</li></ol><p>一つ目はリンターを書けば良い。error型を返す関数を定義したら怒るだけなので簡単。deferでちゃんと書くことを保証するよりも難易度は低いはず。</p><p>二つ目は諦めるしかない。生成AIに頑張ってもらいたい。手書きするのは嫌だけど、補完があるならギリギリ許容できる気持ちがある。</p><p>三つは対処を思いつかない。これも諦めて受け入れるしかないだろう。標準のエラーとは別物として扱おうとしているのだから型は真っ当に手法を表現している。解決手法がGoぽくないのだろう。</p><h2><a href=#%e7%b5%90%e8%ab%96 id=結論 class=anchor aria-hidden=true>結論</a></h2><ul><li>deferを使う手法ではスタックトレースがちょっと足りない<ul><li>とはいえエラーメッセージが適切に設定されていれば問題ではない</li><li>込み入ったこともしないでいいし簡単</li></ul></li><li>とはいえ設定もれが怖い気持ちや、スタックトレースをもう一段深く取りたい気持ちもある<ul><li>そのときは今回提案した型で頑張る手法をとれば良いと思う</li></ul></li></ul></p></div><div class=post-footer><p><a class=tag href=/%20tags/pl>#PL</a>
<a class=tag href=/%20tags/tech>#tech</a></p><p><time>2025-01-08 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/go-static-analysis/>Goのanalysisとtypesに入門する</a></h1><div><p><h2><a href=#%e6%a6%82%e8%a6%81 id=概要 class=anchor aria-hidden=true>概要</a></h2><p>Goで静的解析してリンターを実装したい。具体的には、あるT1インターフェース型の変数がスコープにあるときは、T1よりゆるい任意の型の使用を禁止する、みたいな制約を入れたい。その辺に転がっている記事ではASTを覗いてみたり、SSAを覗いてみたりするようだけど、ASTとその型をまともに扱っていつつ、いい感じに静的解析ツールとして仕上げる記事を見つけられなかった。</p><p>この記事ではGoプログラムの静的解析ツールを実装するために存在する標準的なツールチェーンの思想を説明する。Go Analyzerは静的解析ツールフレームワークとして用いる。具体的な静的解析には標準ライブラリを用いる。</p><h2><a href=#%e4%bd%9c%e3%82%8a%e3%81%9f%e3%81%84%e3%82%82%e3%81%ae id=作りたいもの class=anchor aria-hidden=true>作りたいもの</a></h2><blockquote><p>具体的には、あるT1インターフェース型の変数がスコープにあるときは、T1よりゆるい任意の型の使用を禁止する、みたいな制約を入れたい。</p></blockquote><p>これを検証するGoの静的解析ツール。例えば以下のようなrの使用を検知したい。</p><pre><code class=language-go>func parse(r io.Reader) (string, error) { ... }

func (rw io.ReadWriter) {
	var r io.Reader = getReader()
	s, err := dump(r) // 「rじゃなくてrwを使ってくれ〜！」と指摘したい。
	...
}
</code></pre><h2><a href=#analysis id=analysis class=anchor aria-hidden=true>analysis</a></h2><p><a href=https://pkg.go.dev/golang.org/x/tools/go/analysis>https://pkg.go.dev/golang.org/x/tools/go/analysis</a> これ。準標準なパッケージ。ドキュメントの冒頭に思想がちゃんと書かれているのでそれを読むのが良さそう。</p><h3><a href=#analyzer%e6%a7%8b%e9%80%a0%e4%bd%93 id=analyzer構造体 class=anchor aria-hidden=true>Analyzer構造体</a></h3><p>一個の解析ツールに対応する。Analyzer.Runに解析を実行する関数を定義する。この解析ツールを実行するとき（実行するのはフレームワークの仕事）に、Pass構造体が渡される。</p><h3><a href=#pass%e6%a7%8b%e9%80%a0%e4%bd%93 id=pass構造体 class=anchor aria-hidden=true>Pass構造体</a></h3><p>Pass構造体は解析対象のパッケージごとに作成される。なので解析の単位はパッケージごとということになりそう。いいじゃん。</p><pre><code class=language-go>type Pass struct {
	Fset         *token.FileSet
	Files        []*ast.File
	OtherFiles   []string
	IgnoredFiles []string
	Pkg          *types.Package
	TypesInfo    *types.Info
	ResultOf     map[*Analyzer]interface{}
	Report       func(Diagnostic)
	...
}
</code></pre><p>こいつを通じて解析をする関数は処理対象のデータにアクセスしたり、処理結果を報告したりするぽい。モナドとか代数的エフェクトみたいで綺麗だ。そう思うとあれらは抽象化された一つの振る舞いの切り口を表現するための基本的な演算を定義していたのだから、まあそうだなと思える。Kokaで静的解析ツールを作るときにはpassエフェクトを定義するのだろう。</p><blockquote><p>The Fset, Files, Pkg, and TypesInfo fields provide the syntax trees, type information, and source positions for a single package of Go code.</p></blockquote><p>これは本質情報の予感。このあたりにうまくアクセスすることで、ぼくたちの頭の中で想像する型付き抽象構文木へのアクセスを実現できるんだろう。データ構造が思ったのと違いそうなことには気をつけよう。</p><p>これらに加えて、他のanalyzerが出力してくれる結果をこのanalyzerの入力として使える。それにアクセスするためには pass.ResultOf[a].(aResType)を参照すればよい。</p><p>診断(diagnostics)を出したければPass.Reportとか、パッケージで提供されているReportfとかを使うらしい。</p><h2><a href=#go%e3%81%ae%e5%9e%8b%e4%bb%98%e3%81%8d%e6%a7%8b%e6%96%87%e8%a7%a3%e6%9e%90%e6%9c%a8 id=goの型付き構文解析木 class=anchor aria-hidden=true>Goの型付き構文解析木</a></h2><p>ここまでで、モジュラーに静的解析ツールを実装するフレームワークの構造がわかった。それに乗っかれば静的解析をいい感じに動かすことはできそうだ。静的解析の処理を実装する方法もなんとなくわかった。Pass構造体の世界観に乗っかればokな感じがする。</p><p>次に自在にプログラムを解釈する方法を知りたい。プログラムはコンパイラに処理されていろんな形態に変換されるので、ユースケースに応じて適切な表現を選ぶ必要がある。今回は型付き抽象構文木を扱いたいので、Pass構造体のFset, Files, Pkg, TypesInfoあたりを上手に使えると良さそうだ。特にTypesInfoが気になる。これは types.Info型をとるみたいなので、typesパッケージを見に行く。</p><p>typesパッケージはこれ <a href=https://pkg.go.dev/go/types>https://pkg.go.dev/go/types</a>。冒頭の説明がスッキリしていてまだ何をやれば型付き抽象構文木に対してクエリっぽいことをできるか、どんなクエリっぽいことが許されるかを理解できない。なので貼ってあったチュートリアルのリンクを辿る。なお、スッキリしている説明自体は読んでよかった。このパッケージが扱うフェーズで何をやるか説明されていて、もっと詳しく読んで良さそうなことに自信を持てた。</p><p>なお、僕の目的のためには他の解析ツールの結果を使う方が良いかもしれないとも思う。暇だし気になるのでチュートリアルを読むのに時間をかけるけど。</p><h3><a href=#%e3%83%81%e3%83%a5%e3%83%bc%e3%83%88%e3%83%aa%e3%82%a2%e3%83%ab id=チュートリアル class=anchor aria-hidden=true>チュートリアル</a></h3><p>脱線したがチュートリアルを読み進める。<a href=https://go.dev/s/types-tutorial>https://go.dev/s/types-tutorial</a> これ。これを読む目的は、何をやれば型付き抽象構文木に対してクエリっぽいことをできるか、どんなクエリっぽいことが許されるかを理解すること。</p><p>このチュートリアルはジェネリクスには対応してないらしい。ジェネリクスのためのドキュメントは別途あるとのことだけど、今回は基礎を知りたいので気にしない。</p><p>イントロと例くらいは読んでみて、あとは斜め読みでいいかな。まずはイントロ。</p><blockquote><p>Measured by lines of code and by API surface area, it is one of the most complex packages in Go&rsquo;s standard library, and using it requires a firm grasp of the structure of Go programs.</p></blockquote><p>とのこと。大変だ。</p><blockquote><p>Starting at the bottom, the go/token package defines the lexical tokens of Go. The go/scanner package tokenizes an input stream and records file position information for use in diagnostics or for file surgery in a refactoring tool. The go/ast package defines the data types of the abstract syntax tree (AST). The go/parser package provides a robust recursive-descent parser that constructs the AST. And go/constant provides representations and arithmetic operations for the values of compile-time constant expressions, as we&rsquo;ll see in Constants.</p></blockquote><p>データ構造とアルゴリズムを分けるの賢そう。parserにastを定義しないとか偉い感じがする。色々あるんだろうな。どう嬉しいのかはわからないけど。定数畳み込みをastに対して実装したいが、parserに依存するわけではないよね、みたいな話かな。</p><p>名前解決、型検査、定数式の計算は一緒にやらないといけないなるほど。ここでいう名前解決とは、名前の出現に対してその宣言を対応させること。</p><p>例まで読んだがパッケージレベルの話しかわからないな。ぼくは式とかのレベルでプログラムを処理したいんだ！ということで本命のInfo構造体への言及を探すことにすると、<a href=https://github.com/golang/example/tree/master/gotypes#typeandvalue>TypeAndValue</a>でそれらしいことを述べている。</p><p>Info.Typesは <code>map[ast.Expr]TypeAndValue</code> らしい。そろそろ手を動かして、プログラムのこの要素は式として扱われるか？とかをみたい。と思ったらドキュメントが例を出してくれた。こういうときが一番楽しい。式があったら型は得られるようになってるのね。ただまだよくわかってなくて、mapの定義域をast.Exprとしているが、そのExprとして本当に登録されるのはどの範囲のExprなのかがわからない。当然 <code>ast.Expr{}</code> なんて渡しても、その型を計算しているわけがない。どういう操作で手に入れたast.Exprに対しては、Info.Typeがその型を教えてくれるんだろうか。Infoを生成するやつが知ってるのかな。analysisパッケージはよくわからんPassがInfoを持っていたので微妙だけど、パッケージの単位で処理をするのでパッケージに存在するすべての式の型を教えてくれると思って良さそう？</p><p>確かに<a href=https://pkg.go.dev/go/types#Config.Check>Config.Check</a>はパッケージを型検査して、引数にInfoへのポインタをとって結果を書き込みそう。</p><p>次に、型同士の比較をしたい。具体的には、T1が必要な文脈でT2は使えるか (assignable) を判定する方法が欲しい。そのためにこれが使える<a href=https://pkg.go.dev/go/types#AssignableTo>https://pkg.go.dev/go/types#AssignableTo</a>。引数に渡すTypeインターフェースの値はTypeAndValueで取れるので、ほとんど勝ったようなもの。ちなみに僕は、最初<a href=https://pkg.go.dev/go/types#ConvertibleTo%3E>ConvertibleTo</a>を使っていて全然ダメだった。ConvertibleToは数値が変換できるか判定するやつぽい。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/pl>#PL</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2024-08-31 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/lazy-nvim/>Neovimにlazyを入れてプラグイン管理することにした</a></h1><div><p><p>これまで特にプラグインを使っていなかった（それくらいで済む用途にしか使っていなかった）のだけど、カラースキームを指定したくなったのでプラグインマネージャを入れた。</p><p>どれども大差ないといろんな記事で言われていたので名前とかが気に入った<a href=https://github.com/folke/lazy.nvim>lazy</a>を使うことに。</p><p><a href=https://github.com/naoyafurudono/dotfiles/blob/add-lazy/nvim/init.lua#L17-L55>https://github.com/naoyafurudono/dotfiles/blob/add-lazy/nvim/init.lua#L17-L55</a> で設定している。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2024-08-13 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/ahk/>AHK入門</a></h1><div><p><p>Windowsマシンでキーボード操作が不便なので導入する。悪態をつきながらも使っている人を知っているので内容を理解していないが期待している。</p><h2><a href=#%e3%82%a4%e3%83%b3%e3%82%b9%e3%83%88%e3%83%bc%e3%83%ab id=インストール class=anchor aria-hidden=true>インストール</a></h2><p><a href=https://www.autohotkey.com/>https://www.autohotkey.com/</a> 公式ページからバイナリを落とせる。インストールするとwelcome画面が開いたのだが、そこに「コンパイルする」ボタンがあって、ちょっと不安になる。僕はプログラムをボタンを押してコンパイルしないといけない？</p><p>ついてきたマニュアルはいい感じのスタイリングでよみやすそう？</p><h2><a href=#%e3%83%9e%e3%83%8b%e3%83%a5%e3%82%a2%e3%83%ab%e3%82%92%e8%aa%ad%e3%82%93%e3%81%a7%e3%81%bf%e3%82%8b id=マニュアルを読んでみる class=anchor aria-hidden=true>マニュアルを読んでみる</a></h2><p>頭から飽きるまで読んでいく。</p><ul><li>スクリプトの作成 (Create a Script)<ul><li><blockquote><p>Be sure to save the file as UTF-8 with BOM if it will contain non-ASCII characters. For details, see the FAQ.</p></blockquote></li><li>BOMがいるらしい。そういえばBOMってなんなのだろう。結局まだちゃんと理解してない。</li></ul></li><li>スクリプトの実行 (Run a Script)<ul><li>なんかソースファイルをダブルクリックしたりして実行できて、実行してる間だけ効くらしい。</li><li>イベントハンドラみたいなやつの定義がそれぞれのスクリプトに対応するかと思っていたが、なんかメンタルモデルがあってなさそう</li></ul></li><li>それぞれのスクリプト実行がWindowsのトレイアイコンに反映されるらしい。なるほど</li></ul><p>飽きたのでhello worldする。</p><h2><a href=#hello-world id=hello-world class=anchor aria-hidden=true>hello world</a></h2><p>以下はCapsLockを押すとhello, worldと出力するよう設定するahkスクリプト。ちなみにこれらのhello, worldはCapsLockを打って入力している。</p><pre><code class=language-ahk>#Requires AutoHotkey &gt;=v2.0.0

CapsLock::
  {
    SendInput &quot;hello, world&quot;
  }
  Return
</code></pre><p>CapsLockで英数変換するのは以下で実現できた。</p><pre><code class=language-ahk>#Requires AutoHotkey &gt;=v2.0.0

CapsLock::
  {
    SendInput &quot;^{Space}&quot;
  }
  Return
</code></pre><p>紆余曲折あって、以下のようになった。Windowsでもいい感じにvim使えるようになって幸せ。</p><p><a href=https://github.com/naoyafurudono/dotfiles/blob/main/autohotkey.ahk>https://github.com/naoyafurudono/dotfiles/blob/main/autohotkey.ahk</a></p><pre><code class=language-ahk>#Requires AutoHotkey &gt;=v2.0.0

IME_SET(SetSts, WinTitle:=&quot;A&quot;)    {
    hwnd := WinExist(WinTitle)
    if  (WinActive(WinTitle))   {
        ptrSize := !A_PtrSize ? 4 : A_PtrSize
        cbSize := 4+4+(PtrSize*6)+16
        stGTI := Buffer(cbSize,0)
        NumPut(&quot;Uint&quot;, cbSize, stGTI.Ptr,0)   ;   DWORD   cbSize;
        hwnd := DllCall(&quot;GetGUIThreadInfo&quot;, &quot;Uint&quot;,0, &quot;Uint&quot;,stGTI.Ptr)
                 ? NumGet(stGTI.Ptr,8+PtrSize,&quot;Uint&quot;) : hwnd
    }
    return DllCall(&quot;SendMessage&quot;
          , &quot;UInt&quot;, DllCall(&quot;imm32\ImmGetDefaultIMEWnd&quot;, &quot;Uint&quot;,hwnd)
          , &quot;UInt&quot;, 0x0283  ;Message : WM_IME_CONTROL
          ,  &quot;Int&quot;, 0x006   ;wParam  : IMC_SETOPENSTATUS
          ,  &quot;Int&quot;, SetSts) ;lParam  : 0 or 1
}

IME_GET(WinTitle:=&quot;A&quot;)  {
    hwnd := WinExist(WinTitle)
    if  (WinActive(WinTitle))   {
        ptrSize := !A_PtrSize ? 4 : A_PtrSize
        cbSize := 4+4+(PtrSize*6)+16
        stGTI := Buffer(cbSize,0)
        NumPut(&quot;DWORD&quot;, cbSize, stGTI.Ptr,0)   ;   DWORD   cbSize;
        hwnd := DllCall(&quot;GetGUIThreadInfo&quot;, &quot;Uint&quot;,0, &quot;Uint&quot;, stGTI.Ptr)
                 ? NumGet(stGTI.Ptr,8+PtrSize,&quot;Uint&quot;) : hwnd
    }
    return DllCall(&quot;SendMessage&quot;
          , &quot;UInt&quot;, DllCall(&quot;imm32\ImmGetDefaultIMEWnd&quot;, &quot;Uint&quot;,hwnd)
          , &quot;UInt&quot;, 0x0283  ;Message : WM_IME_CONTROL
          ,  &quot;Int&quot;, 0x0005  ;wParam  : IMC_GETOPENSTATUS
          ,  &quot;Int&quot;, 0)      ;lParam  : 0
}

IME_TOGGLE() {
  current := IME_GET()
  IME_SET(!current)
}

IME_OFF() {
  IME_SET(0)
}

CapsLock::
  {
    IME_TOGGLE()
  }

~Esc::
  {
    IME_OFF()
  }
</code></pre></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/pl>#PL</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2024-07-28 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/learn-authorization/>認可に入門 wip</a></h1><div><p><p><a href=https://www.osohq.com/academy>https://www.osohq.com/academy</a>
これを読んで認可に入門します。頑張るぞ〜！</p><h2><a href=#%e3%82%a4%e3%83%b3%e3%83%88%e3%83%ad id=イントロ class=anchor aria-hidden=true>イントロ</a></h2><p><a href=https://www.osohq.com/academy/authorization-academy>https://www.osohq.com/academy/authorization-academy</a></p><blockquote><p>Chapter II: What authorization is: how to organize your authorization code
Chapter III: Role-based access control: grouping permissions in your app into roles like User and Admin
Chapter IV: Relationship-based control: grouping permissions by relationship, like &ldquo;the creator of a post may edit that post&rdquo;
Chapter V: Authorization enforcement: once your app has decided to allow or deny access, what do you do with that decision?</p></blockquote><p>こんな感じとのこと。色々あるんだな。どれも気になるが、特にアプリケーションコードにどうやって統合していくかが気になるところかな。もれなく頑張らずに実現したい。</p><h2><a href=#what-is-authorization id=what-is-authorization class=anchor aria-hidden=true>What is Authorization?</a></h2><p><a href=https://www.osohq.com/academy/what-is-authorization>https://www.osohq.com/academy/what-is-authorization</a></p><p>具体例を挙げてWebアプリケーションにはレイヤがあって、それぞれのレイヤではどんな情報を取れて、どんな認可ができるかを議論する。</p><p>また、<a href="https://www.osohq.com/academy/what-is-authorization#authzlogic:~:text=4.%20Adding%20Authorization%20to%20an%20Application">&ldquo;4. Adding Authorization to an Application>&rdquo;</a>ではコードでの認可処理の書き方を比較する。</p><p>Naiveなアプローチだと以下のつらみがあると言っている。それな〜。</p><blockquote><p>That quickly gets difficult. As the number of places where you need to apply authorization increases, you end up duplicating the same logic. Making any change then requires us to remember every place our logic is duplicated.</p></blockquote><p>どうしたらいいんだ&mldr;</p><p><a href="https://www.osohq.com/academy/what-is-authorization#authzlogic:~:text=Formalizing%20Our%20Authorization%20Model">Formalizing Our Authorization Model</a> なるほどね（以下を認識する）。</p><ul><li>actor</li><li>action</li><li>resource</li></ul><p>UNIXのファイルにつけるパーミッションもこの考えで整理されてそう。どのユーザがどのファイルに対してどんな操作をするかを気にして権限の管理をしてるイメージ。</p><p>グループIDみたいなのはactorを発展させたものぽい。
sudoもその辺をいじるのかな。Capabilityはactionsの部分かな。それだけでもなさそうか。</p><p>上の三つ組を考えるメリットは二つあるとのこと。</p><ul><li>言語を共有できる</li><li>設計としてシンプル</li></ul><p>設計がシンプルと言ってるのは、以下のように認可のインターフェイスを持てそうということらしい。</p><pre><code class=language-haskell>isAllowed:: (Actor, Action, Resource) -&gt; Bool
</code></pre><p>こういうインターフェースを定めることで認可の周りで責務の境界を定められる。呼び出し側の責務にenforcement, 呼ばれる側の責務にdecisionという名前をここではつけている。</p><h3><a href=#enforcement id=enforcement class=anchor aria-hidden=true>Enforcement</a></h3><p>認可処理の結果をもとに何をするかを決めること。そもそも認可処理の呼び出しをするのもここの範囲だし、その結果アクセスがなければ403返すとかするのもここ。良いかどうかを気にしつつ、その結果どうするかを決めるのがここ。</p><h3><a href=#decision id=decision class=anchor aria-hidden=true>Decision</a></h3><p>基本はyes/noを返すやつ。さっきの関数の実装。警告とかは出したきゃ出せばいい。純粋である必要はなさそう。</p><h3><a href=#%e3%81%be%e3%81%a8%e3%82%81 id=まとめ class=anchor aria-hidden=true>まとめ</a></h3><p><a href="https://www.osohq.com/academy/what-is-authorization#authzlogic:~:text=5.%20Putting%20Everything%20Together">5. Putting Everything Together</a> がまとめだった。ここまでのメモが集約されてる感じ。</p><p>あとここには書かなかったけど、enforcementとかdecisionとかの話の後にenforcementをどこに実装する？みたいな話があるがマイクロサービスぽいアプリケーションを書いてないとそもそも問題にならなさそうで、一旦そこに僕は興味ないのでスルー。</p><h3><a href=#%e8%aa%b2%e9%a1%8c id=課題 class=anchor aria-hidden=true>課題</a></h3><p>アーキテクチャの話はなるほどって感じだが、まだ考えられることはたくさんある。</p><ul><li>権限が足りないときのエラーメッセージの返し方<ul><li>足りない場合は403だけじゃなくて何を足せば良いか知りたいとか</li></ul></li><li>管理者にアプリユーザがどんな権限を持ってるかを表示するとか</li><li>グループとか</li></ul><h2><a href=#role-based-access-control-rbac id=role-based-access-control-rbac class=anchor aria-hidden=true>Role-Based Access Control (RBAC)</a></h2><p><a href=https://www.osohq.com/academy/role-based-access-control-rbac>https://www.osohq.com/academy/role-based-access-control-rbac</a></p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tech>#tech</a></p><p><time>2024-06-24 +0900</time>
lastmod: <time>2024-12-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/semi-open-interval/>半開閉区間</a></h1><div><p><h2><a href=#%e5%8f%82%e7%85%a7 id=参照 class=anchor aria-hidden=true>参照</a></h2><p>コンピュータで区間処理するときは半開閉区間で持つことが多い気がしている。もはや信仰のレベルで身についているので自分一人で決めて終わりなときはそれで良いのだが、説明が必要なときに困る。そのときのために良さげな参照を集めておく。</p><ul><li>&ldquo;Always use [closed, open) intervals&rdquo;<ul><li><a href=https://fhur.me/posts/always-use-closed-open-intervals>https://fhur.me/posts/always-use-closed-open-intervals</a></li><li>半開閉区間の説明と閉区間のつらみ、半開閉区間のよさを語っている</li></ul></li><li>&ldquo;Google Cloud API設計ガイド&rdquo;<ul><li><a href="https://cloud.google.com/apis/design/design_patterns?hl=ja#representing_ranges">https://cloud.google.com/apis/design/design_patterns?hl=ja#representing_ranges</a></li><li>半開閉区間を使う必要があるとしている。C++とJavaがそうしてるぞと強調してるが理由は特に触れてない。</li></ul></li><li>&ldquo;時間の歩き方&rdquo;<ul><li><a href=https://blog.osa.in.net/time-tips/>https://blog.osa.in.net/time-tips/</a></li><li>半開閉区間というか、時間（時刻の区間としている）の持ち方の話。日付の区間なら閉区間もありと主張してる。</li></ul></li></ul><h2><a href=#%e4%bd%99%e8%ab%87 id=余談 class=anchor aria-hidden=true>余談</a></h2><p>何というか区間は連続な集合の２端点を指定して定まる部分集合であって、その全体からなる集合族を扱おうと思うと半開閉区間にしておくと綺麗というのも関係する？</p><p>区間は全順序集合の部分集合で、それらを体系的に考えようと思うと区間の集合の性質を考えるのが良いはず。つまり区間からなる族を考えると良さそう。</p><p>考える全順序集合が連続な集合なら、半開閉区間からなる族を考えると、任意の区間は有限個の区間の非交和として表現できる半開では無い区間の族ではこの性質は成り立たなさそう。漏れとダブりがないように区間を分割する必要は実用的に割とあってそれをきれいにできるのは半開閉区間だけということになる。</p><p>ググってみると集合半環という概念があるみたいで、それにこの性質が効いてるぽい。<a href=https://ja.wikipedia.org/wiki/%E9%9B%86%E5%90%88%E5%8D%8A%E7%92%B0>集合半環 (wikipedia)</a>をみると良さそう。</p><p>むずい。</p><h2><a href=#chatgpt%e3%81%ab%e6%95%b4%e7%90%86%e3%81%97%e3%81%a6%e3%82%82%e3%82%89%e3%81%a3%e3%81%9f id=chatgptに整理してもらった class=anchor aria-hidden=true>ChatGPTに整理してもらった</a></h2><p><a href=https://chatgpt.com/share/4c778bf6-f43a-4230-825d-398ad025a457>https://chatgpt.com/share/4c778bf6-f43a-4230-825d-398ad025a457</a></p><p>結構良い回答をもらえた。</p><h3><a href=#%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0%e3%81%a7%e5%8c%ba%e9%96%93%e3%82%92%e8%a1%a8%e7%8f%be%e3%81%99%e3%82%8b%e3%81%ae%e3%81%ab%e5%8d%8a%e9%96%8b%e9%96%89%e5%8c%ba%e9%96%93%e3%82%92%e7%94%a8%e3%81%84%e3%82%8b%e3%81%a8%e8%89%af%e3%81%84%e7%90%86%e7%94%b1%e3%82%92%e8%aa%ac%e6%98%8e%e3%81%97%e3%81%a6%e3%81%8f%e3%81%a0%e3%81%95%e3%81%84 id=プログラミングで区間を表現するのに半開閉区間を用いると良い理由を説明してください class=anchor aria-hidden=true>プログラミングで区間を表現するのに半開閉区間を用いると良い理由を説明してください</a></h3><p>プログラミングで区間を表現する際に半開閉区間（半開区間、片開区間とも言う）を用いると良い理由は、特に次のような点にあります：</p><ol><li><p><strong>直感的なインデックス操作</strong>:</p><ul><li>配列やリストなどのデータ構造において、インデックスは通常0から始まります。半開閉区間 <code>[start, end)</code> を使うと、<code>start</code> から <code>end-1</code> までのインデックスが含まれるため、範囲を扱う際に計算がシンプルになります。例えば、要素数が10の配列に対して <code>[0, 10)</code> という範囲を指定すると、全ての要素を含むことになります。</li></ul></li><li><p><strong>区間の連結が容易</strong>:</p><ul><li>半開閉区間は連結する際に便利です。例えば、 <code>[start1, end1)</code> と <code>[start2, end2)</code> という2つの区間を連結する場合、<code>end1</code> と <code>start2</code> が同じであれば、それらを連結して <code>[start1, end2)</code> とすることができます。このように、区間の端点が明確に分かれているため、エッジケースが少なくなります。</li></ul></li><li><p><strong>境界の一貫性</strong>:</p><ul><li>境界条件を処理する際、開区間の端点は含まれないため、範囲外アクセスのリスクが減少します。これにより、特にループ処理や再帰的なアルゴリズムの実装が一貫しやすくなります。</li></ul></li><li><p><strong>数学的な整合性</strong>:</p><ul><li>半開閉区間の表現は、数学的にも広く使われており、理論的な背景からも自然な表現です。例えば、集合の分割や区間の分割などで、一貫した扱いが可能です。</li></ul></li><li><p><strong>プログラミング言語のサポート</strong>:</p><ul><li>多くのプログラミング言語やライブラリが、半開閉区間をデフォルトでサポートしています。例えば、Pythonのリストスライスや、C++の標準ライブラリの範囲は、半開閉区間の形式を採用しています。このため、言語やライブラリの機能を活用する上で半開閉区間を使うのが自然です。</li></ul></li></ol><p>以上の理由から、プログラミングにおいて区間を表現する際には半開閉区間を用いることが一般的であり、推奨されます。</p><h3><a href=#%e6%95%b0%e5%ad%a6%e7%9a%84%e3%81%aa%e7%94%9f%e5%90%88%e6%88%90%e3%81%a7%e4%b8%80%e8%b2%ab%e3%81%97%e3%81%9f%e6%89%b1%e3%81%84%e3%81%a8%e3%81%82%e3%82%8a%e3%81%be%e3%81%99%e3%81%8c%e5%b0%82%e9%96%80%e7%9a%84%e3%81%ab%e3%81%af%e3%81%a9%e3%81%ae%e3%82%88%e3%81%86%e3%81%aa%e6%80%a7%e8%b3%aa%e3%81%8c%e6%88%90%e3%82%8a%e7%ab%8b%e3%81%a4%e3%81%ae%e3%81%a7%e3%81%97%e3%82%87%e3%81%86%e3%81%8b id=数学的な生合成で一貫した扱いとありますが専門的にはどのような性質が成り立つのでしょうか class=anchor aria-hidden=true>数学的な生合成で一貫した扱いとありますが、専門的にはどのような性質が成り立つのでしょうか？</a></h3><p>数学的な観点から見て、半開閉区間（例えば ([a, b))）を使用することにはいくつかの重要な性質があります。これらの性質により、一貫した扱いや直感的な操作が可能となります。以下にいくつかの重要な性質を挙げます：</p><ol><li><p><strong>区間の連結性</strong>:</p><ul><li>2つの半開閉区間 ([a, b)) と ([b, c)) を連結すると、新しい半開閉区間 ([a, c)) を得ます。これにより、連続する区間を簡単に扱うことができます。</li><li>例： ([1, 3)) と ([3, 5)) の連結は ([1, 5)) となります。</li></ul></li><li><p><strong>区間の分割性</strong>:</p><ul><li>半開閉区間 ([a, c)) を点 (b) で分割すると、2つの区間 ([a, b)) と ([b, c)) になります。このように、区間を分割する際の扱いがシンプルです。</li><li>例： ([2, 7)) を (5) で分割すると ([2, 5)) と ([5, 7)) になります。</li></ul></li><li><p><strong>一意性と包含関係</strong>:</p><ul><li>各点は1つの半開閉区間に一意的に属します。具体的には、点 (x) が区間 ([a, b)) に属するのは (a \leq x &lt; b) の場合のみです。このため、区間の包含関係を判断するのが容易です。</li><li>例： (x = 3) は ([1, 5)) に含まれますが、([3, 7)) にも含まれます。</li></ul></li><li><p><strong>空集合の扱い</strong>:</p><ul><li>半開閉区間において、区間 ([a, a)) は空集合となります。これにより、区間のサイズが負になることを避け、理論的な一貫性を保ちます。</li><li>例： ([4, 4)) は空集合として扱います。</li></ul></li><li><p><strong>順序性と計算の簡便性</strong>:</p><ul><li>半開閉区間は順序を持っているため、数直線上の位置関係を直感的に理解できます。これにより、範囲の計算や比較が簡単になります。</li><li>例： ([2, 5)) と ([5, 8)) の関係は明確に非重複であると分かります。</li></ul></li><li><p><strong>測度論との整合性</strong>:</p><ul><li>測度論（特にルベーグ測度）においても、半開閉区間は重要です。半開閉区間は測度が容易であり、特に区間の長さが (b - a) で計算できるため、実際の応用において便利です。</li></ul></li></ol><p>これらの性質により、半開閉区間は数学的に一貫した扱いが可能となり、プログラミングにおいても同様の利便性が得られます。このため、アルゴリズムやデータ構造の設計において半開閉区間を使用することが推奨されます。</p><h2><a href=#%e5%a5%bd%e3%81%8d%e3%81%aa%e5%8c%ba%e9%96%93%e7%99%ba%e8%a1%a8%e3%83%89%e3%83%a9%e3%82%b4%e3%83%b3 id=好きな区間発表ドラゴン class=anchor aria-hidden=true>好きな区間発表ドラゴン</a></h2><p><img src="/posts/semi-open-interval/nc355601_%E5%A5%BD%E3%81%8D%E3%81%AA%E6%83%A3%E8%8F%9C%E7%99%BA%E8%A1%A8%E3%83%89%E3%83%A9%E3%82%B4%E3%83%B3%E3%81%AE%E3%83%89%E3%83%A9%E3%82%B4%E3%83%B3.png?width=200px" alt=閉じたとこから開いたと〜こ！></p><p>好き好き大好き〜</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tech>#tech</a></p><p><time>2024-05-29 +0900</time>
lastmod: <time>2024-05-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/rubykaigi2024/>RubyKaigi2024参加メモ</a></h1><div><p><p>RubyKaigi2024に参加したので、思ったことをメモしておきます。</p><p>参加したセッションはこちら: <a href=https://rubykaigi.smarthr.co.jp/2024/plans/d2350276-c631-4bdc-ad75-49e446e798a3>https://rubykaigi.smarthr.co.jp/2024/plans/d2350276-c631-4bdc-ad75-49e446e798a3</a></p><h2><a href=#shopify%e3%81%8c%e3%81%99%e3%81%94%e3%81%84 id=shopifyがすごい class=anchor aria-hidden=true>shopifyがすごい</a></h2><p>今回のセッションをいくつか聞いてShopifyのやり方に憧れるようになった。エンジニアリングをしていく上での姿勢として、課題に対して上流から対処しよう、みたいな箴言があってそれが心に残っている。
ShopifyのRuby周りのチームはまさにそれを地で行っていると今回のセッションを聞いて感じたそういうチームに所属して（作って？）良いエンジニアリングをしていきたいと思っていたのだが、これまでは具体的なイメージいを持っていなかった。</p><p>ShopifyのRubyチームによる貢献にはすでに自分が直接的に恩恵を受けているし、彼らがどういう思想で取り組んで具体的に何をしてきたか、これからどういう思想でやっていくかを生で聞くことができた。遠いけれども具体的に目標とする存在に出会えたことが今回の一番の収穫だったと思う。</p><h2><a href=#%e5%90%8d%e5%89%8d%e7%a9%ba%e9%96%93%e3%81%a8%e3%81%8b%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%bc%e3%83%ab%e3%81%ae%e8%a9%b1%e9%a1%8c%e3%81%8c%e6%a5%bd%e3%81%97%e3%81%bf id=名前空間とかモジュールの話題が楽しみ class=anchor aria-hidden=true>名前空間とかモジュールの話題が楽しみ</a></h2><p>バージョンとかライブラリのインストールとか大変だしよく分からないのでスッキリする方向に進んでいきそうで楽しみ。セッションも普通に勉強になった。</p><h2><a href=#%e4%ba%ba%e3%81%a8%e4%bc%9a%e3%81%88%e3%81%a6%e3%82%88%e3%81%8b%e3%81%a3%e3%81%9f id=人と会えてよかった class=anchor aria-hidden=true>人と会えてよかった</a></h2><p>一方的に知っていた人もお互い初めましてな人もお話しできてよかった。今回存在を新たに認知した人ももちろんいて、いろんな人が色々やっていることとか、意外とコミッタ少ないこととか認知できて良い。
Rubyって人間が作ってるんだなと感じる。</p><p>現実味を感じる一週間でした。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/pl>#PL</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2024-05-18 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/2024-04/>2024年4月での振り返り</a></h1><div><p><h2><a href=#%e8%bf%91%e6%b3%81 id=近況 class=anchor aria-hidden=true>近況</a></h2><p>4月が終わるので（？）最近のことを振り返る。</p><p>1月に配属されて、2月開発にプロジェクトが始まってからずっと<a href=https://gamers.lolipop.jp/>LOLIPOP! for gamers</a>を作り続けている。今まで本で読んだようないろんな苦しみを体感できて楽しい。プログラミングに関することや、設計とか技術選定、開発体制や組織、チームとか締切とか工数みたいな大変さを一通り味わったと思う。</p><p>自分がうまくできなかった・できた経験や周りの人が自分より上手くやったりあるいは自分が彼らにアドバイスする経験を積めた。修行を積んでいる感じがする。</p><p>修行が必要なのはそれはそうと思うのだが、戦略的に仕事したいなとも思う。たとえば１ヶ月後は今の倍のスピードで開発できるようにしたいがどうすれば良いだろう、とか考えて立案して実行するとか。</p><h2><a href=#%e5%ad%a6%e7%94%9f%e6%99%82%e4%bb%a3%e3%81%ae%e7%8b%99%e3%81%84 id=学生時代の狙い class=anchor aria-hidden=true>学生時代の狙い</a></h2><p>学生の頃に感じていたプログラミングの課題が感覚としてわからない気持ちはだいぶ薄くなってきた。そろそろ腰を据えて課題を整理して解決を図る余裕が欲しくなってくる（自分で作るぞ）。</p><p>Webアプリケーションを作っている。知らない人が変更をするであろうプログラムを作ることが仕事。実行環境は不安定で、このプログラムは複数のプロセスで同時に走るし、どのタイミングでプロセスが落ちるかわからない。</p><p>DBとかの外部サービスは自分たちが実装しているプログラムよりも余程信頼できるもので、一貫性とかを担保しようと思うと外部サービスに頼ることになる。もちろん我々が実装するサービスを雑に作っている訳ではないが、外部サービスを選ぶときには厳しめな基準を持っているので信頼性が違うのは当然に思う。
Webアプリケーションはたくさんの人が作っているので、そのための外部サービスが成熟しているのは当然なのかな。一方で、プログラミング言語を設計するときに使えるツールってそんなになくて、自分で実装するものが理解できて使うの楽なイメージがある（僕はにわかなので見当違いなことを言ってると思った方が良いかもだが）。</p><p>そう思うと、Webアプリケーションを作る仕事はインターネットから情報を探し出して信頼できるツールにうまく責任をなすりつつ、本当にやりたいことを見失わないようにハンドリングすることなのかと思う。そのためにモデリングとか設計とかするのかな。インターネットから欲しい情報を探し出したりそれらを組み合わせて実装するのもまあ大変。</p><p>この解釈はなんだか悲しいな。プログラムを作ることが目的になっている視点な気がする。これを悲しいと思ったのは、ぼくが思う正しい仕事が事業で利益を上げることではなく、誰も知らなかったこと・できなかったことを明らかにして誰でもできるようにすることだと捉えているからだろう。やるのが大変で、それをやったのであれば誰もできなかったことをできたのは間違い無いのだろうが、後から来る人がそれをやりたいと思うかや、やりたいと思ったとして自分の影響で簡単にできるようになったかは別の問題。事業でやる分には競合が同じ苦労を味わったりするような状況で放置することも多いはず（この辺はペパボはいい感じだと思う）。</p><p>数年前よりも良いものを早く作れるようになることがWebのエンジニアリングでは求められていて、そのためには知見を集めつつそれでも叶わない課題を見つけてそれを解決する手法を提案・実装・共有することが必要なのだろう。その中でそれまでの仮説を否定するものがあると、パラダイムシフトが起きて自分も含めてみんなで楽しくなれるのだろう。仮説を否定するためには流れに乗るのではなくて既存の目的や仮説を理解した上で、自分が先端の課題に向き合って試行錯誤して課題解決することが必要なはず。そうやって狙ってやった提案がハマると気持ち良いだろうから、それをふんわりとしたエンジニアリングの目標にするのは一つの手だと思う。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/alcohol>#alcohol</a></p><p><time>2024-04-30 +0900</time>
lastmod: <time>2024-12-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/multi-lang-on-hugo/>hugoで多言語対応始めた</a></h1><div><p><p><a href=https://github.com/naoyafurudono/naoyafurudono.github.io/commit/b4966a3e96c2a8131da6d623cef85df5c97439ba>https://github.com/naoyafurudono/naoyafurudono.github.io/commit/b4966a3e96c2a8131da6d623cef85df5c97439ba</a>
このコミットみたいな感じで設定したりファイル名を変えたりすると、いい感じにパスを掘ってくれる。</p><p>パスを掘ってくれる以外のメリットは知らない。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/tool>#tool</a></p><p><time>2024-04-18 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/elm-architecture/>ElmアーキテクチャをReactで実現する話</a></h1><div><p><h2><a href=#elm%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3 id=elmアーキテクチャ class=anchor aria-hidden=true>Elmアーキテクチャ</a></h2><p>リアクティブプログラミングの勉強をしていた頃にElm言語を知って好きになった（全然コード書いてないけど）。特徴はElmアーキテクチャにあると思っている。
Webアプリケーションの大体のフロントエンドアプリケーションはこう言うアーキテクチャで表現できるはず、みたいなことを言っていて、そのアーキテクチャが簡単なので気に入ったのだろう。</p><p>ユーザやAPIとやりとりをするアプリケーションなので、外界からの入力は当然ある。</p><p>また、それによって（のみ）アプリケーションの状態は変化する。アプリケーションが取りうる状態はアプリケーションに固有だし、どんなことがアプリケーションで起こって（入力としておきえて）、その結果どのような状態遷移をするかもアプリケーションに固有。なのでそれらはアプリケーションの実装者が決める。入力というかイベントがあって、それによってある状態から他の状態に遷移する、状態遷移系を定義するのはシンプルに思える。</p><p>状態が決まればそれの描画結果も決まるはず。もちろんDOMとかスタイルを当てたりとかして状態を描画結果に対応づける方法はそのアプリを作る人が定義する。描画というのは状態から描画結果への写像なのだ、と思うのがシンプルなポイント。</p><p>最初にあげた、外界からの入力は曲者。クリックとかレンダリングとかAPIの呼び出しとかは、知ったことではない感じがする。少なくともフロントエンドアプリケーションの範囲で意味を定義して実装するものではない。なのでその辺はElmのランタイムがいい感じに実装してインターフェイスを提供してくれる。そのインターフェイスを使いつつ、イベントを定義することになる。</p><h2><a href=#react%e3%81%a7%e5%ae%9f%e7%8f%be%e3%81%99%e3%82%8b%e8%a9%b1 id=reactで実現する話 class=anchor aria-hidden=true>Reactで実現する話</a></h2><p>Elmアーキテクチャは最高なんだけど、仕事のプロジェクトで使うとなると言語の選択はもっと資本主義ぽい判断が必要になって、TypeScriptとReact使うかという気持ちになる。</p><p>幸いなことにこれら二つでElmっぽいことはできるので、今の仕事では黙々とそれを進めている。
Reactで違うところは、Elmランタイムがなくてもうちょっと小さな部品がたくさんあって、それをいい感じに組み合わせて使うところだと思う。<code>useEffect</code> で頑張るとか。</p><p>そのあたりを頑張っているうちとかに、だんだんElmアーキテクチャっぽくするのが辛くなったりして辛い。みんなで強い気持ちでその方針に向かうのが良さそう。</p><p><a href=https://guide.elm-lang.org/>https://guide.elm-lang.org/</a> がElmのガイドでElmアーキテクチャを推してくれる。なのでみんな読んでほしい。</p><h2><a href=#elm%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%81%a8%e3%82%a8%e3%83%95%e3%82%a7%e3%82%af%e3%83%88%e3%83%8f%e3%83%b3%e3%83%89%e3%83%a9 id=elmアーキテクチャとエフェクトハンドラ class=anchor aria-hidden=true>Elmアーキテクチャとエフェクトハンドラ</a></h2><p>エフェクトハンドラで実現したい世界と、Elmアーキテクチャみたいな世界は重なる部分が多そうだと感じている。
Reactの開発者もuseContextはalgebraic effectなんだ！みたいなことを何処かで言っていた気もするし、誰しも思うことなんだろう。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/pl>#PL</a>
<a class=tag href=/%20tags/tech>#tech</a></p><p><time>2024-04-18 +0900</time>
lastmod: <time>2024-04-19 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/install-storybook-next/>Nextjsのプロジェクトにstorybookを導入してみた</a></h1><div><p><h2><a href=#%e3%82%84%e3%81%a3%e3%81%9f%e3%81%93%e3%81%a8 id=やったこと class=anchor aria-hidden=true>やったこと</a></h2><p><a href=https://github.com/naoyafurudono/timer/pull/1>https://github.com/naoyafurudono/timer/pull/1</a></p><p>このプルリクエストで頑張った。コミットメッセージにやったことは書いてある。</p><h2><a href=#%e5%8f%82%e8%80%83 id=参考 class=anchor aria-hidden=true>参考</a></h2><p>公式ドキュメントがしっかりしてそう。storybookが内部で使っているwebpackが<code>@</code> インポートを読めないみたいで、プラグインを入れる必要があった。</p><ul><li>storyの書き方: <a href=https://storybook.js.org/docs/writing-stories>https://storybook.js.org/docs/writing-stories</a></li><li>Next.jsへのインストール: <a href=https://storybook.js.org/docs/get-started/nextjs>https://storybook.js.org/docs/get-started/nextjs</a><ul><li>コマンド一発だった。便利。</li></ul></li><li><code>@</code> インポートが効かない問題の対処: <a href=https://qiita.com/sinnlosses/items/51e614570180c5f12e86>https://qiita.com/sinnlosses/items/51e614570180c5f12e86</a></li></ul></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2024-03-26 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/fav-racket-features/>推し言語機能 Racket編</a></h1><div><p><p>この記事は<a href=https://adventar.org/calendars/8634>GMOペパボエンジニア Advent Calendar 2023 🎅会場</a>の19日の記事です！</p><p>昨日はyagijinさんのReactやってる人向けのSwiftUI入門でした。
Swiftに興味があるReact信者の僕のために書いてくれたのかと錯覚しました。これを期にSwift UI入門しようと思います。
Swift UIは双方向バインディングを採用しているとのことなので、Vueとの類似もありそうですね。</p><p>Reactを書いている時間は癒しの時間です。ところでReactは関数型言語からインスパイアされた機能が多いですよね。今日の記事はそんな関数型言語の中でも僕の好きなRacket言語の記事です。僕が一推しするRacketの言語機能を紹介します。</p><h2><a href=#%e5%89%8d%e6%9b%b8%e3%81%8d id=前書き class=anchor aria-hidden=true>前書き</a></h2><p>好きなRacket言語の言語機能を紹介します。ざっくりとした紹介なので、ここでの知識を人に話したりプログラミングで活用する前に、節々で参照する公式ドキュメントを参照してもらえると嬉しいです。</p><ul><li>契約</li><li>named let</li><li>動的束縛</li></ul><h2><a href=#%e5%a5%91%e7%b4%84 id=契約 class=anchor aria-hidden=true>契約</a></h2><p>ここでいう契約とは、関数の入出力の性質を関数定義の際に宣言しておくことで、関数を呼び出しを実行する際に入出力の値を検証し、違反していた場合にエラーを投げる言語機能のことです。余談ですが、契約と型は対応する概念です。契約の検証は実行時に行いますが、型検査はコンパイル時に行います。静的に型をつける言語では関数定義の際にその型を宣言することで、関数呼び出しのあるコードの入出力の方を検証し、違反する呼び出しを特定します。
ContractのRacket Guideを貼っておきます。<a href=https://docs.racket-lang.org/guide/contracts.html>https://docs.racket-lang.org/guide/contracts.html</a></p><p>ここでは <a href=https://docs.racket-lang.org/reference/function-contracts.html>https://docs.racket-lang.org/reference/function-contracts.html</a> の例をお借りして説明します。</p><pre><code class=language-racket>&gt; (define/contract (maybe-invert i b)
    (-&gt; integer? boolean? integer?)
    (if b ( -i) i))
&gt; (maybe-invert 1 #t)
-1
&gt; (maybe-invert #f 1)
maybe-invert: contract violation
  expected: integer?
  given: #f
  in: the 1st argument of
      (-&gt; integer? boolean? integer?)
  contract from: (function maybe-invert)
  blaming: top-level
   (assuming the contract is correct)
  at: eval:2:0
</code></pre><p>冒頭の <code>define/contract</code> で始まるS式では、関数定義をしつつ、その関数の契約を宣言します。二つの引数 <code>i</code>, <code>b</code> をとる関数 <code>maybe-invert</code> を定義していて、<code>b</code>がtruthyなら<code>-i</code>を返し<code>b</code>がfalthyなら<code>i</code>を返す関数として<strong>実装</strong>しています。この関数の契約は<code>(-> integer? boolean? integer?)</code> と宣言されています。これは<code>integer?</code>を満たす値と<code>boolean?</code>を満たす値を引数に取り、<code>integer?</code>を満たす値を返す関数である、と読みます。</p><p><code>(maybe-invert 1 #t)</code> という関数呼び出し式では第一引数に <code>1</code>, 第二引数に <code>#t</code> を渡しているので入力に関する契約を満たしていて、返り値は<code>-1</code>になるので出力に関する契約も満たしています。そのためエラーが出ずに何事もなく計算結果の　<code>-1</code>が表示されます。</p><p>一方で、 <code>(maybe-invert #f 1)</code> という関数呼び出しでは引数の順序を間違えて渡しているようです。第一引数にfalseを表す <code>#f</code> を渡しています。<code>#f</code> は <code>integer?</code> を満たさない（そういうふうに <code>integer?</code>が定義されている）のでRacket処理系は契約に違反している旨をエラーとして表示しています。</p><p>こういうのが契約です。ちゃんと確認していませんが、PHPで型注釈を書いた際にも実行時の検査が行われるそうなのでPHPは契約を言語機能としてサポートしているといえそうです。他にはD言語も契約をサポートします。</p><p>入力値のバリデーションはコードを書くときに当たり前に行う作業ですが、それをシステマチックに行うためのフレームワークを言語が提供してくれるのは魅力的だと思っています。また、契約は型システムや漸進的型つけとも密接に関わりがある楽しい概念です。</p><h2><a href=#named-let id=named-let class=anchor aria-hidden=true>named-let</a></h2><p>次はnamed-letです。これについても公式ドキュメントを貼っておきます。<a href=https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29>https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29</a></p><p>RacketやSchemeなどのLisp系言語で勉強しているとwhileやforは習いませんが、再帰を習います。例えば整数のリストを受け取って、その和を返す関数<code>sum</code>を定義するにはこんな感じで書きます。</p><pre><code class=language-racket>&gt; (define (sum lst)
          (if (nil? lst)
              0
              (+ (car lst) (sum (cdr lst)))))
&gt; (sum '(1 2 3 4 5 6 7 8 9 10))
55
</code></pre><p><code>nil?</code>はリストが空を判定し、<code>car</code>はリストの先頭要素をとる関数で、<code>cdr</code>はリストの先頭を除いた部分をとる関数です。先頭の値とそれ以降の和をたすことで、リスト全体の和を得ています。</p><p>このように再帰があればループはかけるのですが、関数を定義してその直後にその関数を呼び出す、そしてその後その関数は使わない、みたいなケースがしばしばあります。そういうときに役立つのがnamed-letです。以下のように再帰関数の定義と関数呼び出しを同時に行うことができます。</p><pre><code class=language-racket>&gt; (let sum ((lst '(1 2 3 4 5 6 7 8 9 10))
       (if (nil? lst)
           0
           (+ (car lst) (sum (cdr lst))))))
55
</code></pre><p>再帰関数を使ってループを書くことでループの中での再代入を避けることができます。そのためループ不変条件を把握するのが楽になります。そしてnamed-letを使うことで、不要な関数定義を省くことができます。スコープにある変数は少ないほど嬉しいです。ここだけで使う再帰関数なんだということが一目でわかります。あと書いてみるとわかるのですが、named-letを書くととても気分がいいです。</p><h2><a href=#%e5%8b%95%e7%9a%84%e6%9d%9f%e7%b8%9b id=動的束縛 class=anchor aria-hidden=true>動的束縛</a></h2><p>最後は動的束縛です。emacs lispの変数束縛は動的だということで有名ですし、最近だとReactのContextが動的束縛っぽいかなと思います。やはり公式ドキュメントのリンクを貼っておきます。<a href=https://docs.racket-lang.org/guide/parameterize.html>https://docs.racket-lang.org/guide/parameterize.html</a></p><p>誤解を恐れながらいうと、環境変数みたいなやつをコードの中で設定できる機能です。公式ドキュメントの例をそのまま貼り付けます。</p><pre><code class=language-racket>&gt; (parameterize ([error-print-width 5])
    (car (expt 10 1024)))
car: contract violation
  expected: pair?
  given: 10...
&gt; (parameterize ([error-print-width 10])
    (car (expt 10 1024)))
car: contract violation
  expected: pair?
  given: 1000000...
</code></pre><p>REPLで2回プログラムを実行しています。<code>(expt x y)</code> は <code>x</code> の <code>y</code> 乗です。それのcarを取ろうとしています（<code>car</code>はリストの先頭要素を返す関数でした）が、<code>(expt x y)</code>の計算結果は数値であってリストでないので<code>car</code>の契約に違反します。そのためエラーメッセージが表示されています。今回フォーカスしたいのは動的束縛です。<code>parameterize</code> で <code>error-print-width</code>の値をそれぞれの実行で <code>5</code> や<code>10</code>に指定しています。その結果表示されるエラーメッセージの幅が5になったり10になったりしています(<code>10...</code> と <code>1000000...</code>)。おそらくエラーメッセージを表示する関数の中で <code>error-print-width</code>が参照されているのでしょう。</p><p>このように関数を呼び出すタイミング側でその振る舞いを変えられるのが動的束縛の旨みです。関数の引数で渡す必要がないので、動的変数を参照する関数と設定する関数の間の関数たちが余分な引数を取らなくても良いわけです。</p><p>グローバル変数を使ってもこのような引数を介さない設定はできますが、動的束縛を使う方が衛生的です。例えば一つのプログラムの中でグローバル変数の値を変えたい場合、グローバル変数の値を書き換えることになります。これは悪名高い可変なグローバル変数を使うことを意味します。可変なグローバル変数は無関係に見えるプログラムの実行順序がクリティカルにプログラムの振る舞いを左右するのでよくないです。</p><p>一方で動的束縛では関数呼び出しごとに値を設定するため実行順序のことは気にしなくて良いです。値を設定した呼び出しの範囲下ではそれが反映されるし、その範囲外ではその設定は無効化されます。このように衛生的に、かつ疲れない形で広い範囲で参照する値を設定できることがグローバル変数と比較した際のメリットだと思います。</p><h3><a href=#%e3%82%a8%e3%83%95%e3%82%a7%e3%82%af%e3%83%88%e3%83%8f%e3%83%b3%e3%83%89%e3%83%a9%e3%81%a8%e3%82%a8%e3%83%95%e3%82%a7%e3%82%af%e3%83%88%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0 id=エフェクトハンドラとエフェクトシステム class=anchor aria-hidden=true>エフェクトハンドラとエフェクトシステム</a></h3><p>動的束縛される変数を参照する場合、呼び出し側の不慮の事故によって変数の定義もれでプログラムが正常に動作しないかもしれません。環境変数を設定し忘れるとアプリケーションが動かないのと同じです。こういう事故は実行する前、例えばコンパイルしたり型検査のタイミングで気がつけると嬉しいですよね。</p><p>Racketでこの課題を解決できるかは知らないのですが、エフェクトハンドラとエフェクトシステムを使えば型検査の中で解決できます！
その説明をしたい気持ちが溢れているのですが、そろそろ日を跨ぎそうなので興味がある方は僕に声をかけてくれると嬉しいです。</p><h2><a href=#%e3%81%82%e3%81%a8%e3%81%8c%e3%81%8d id=あとがき class=anchor aria-hidden=true>あとがき</a></h2><p>プログラミング言語の言語機能、いいですよね。言語設計者が思う表現のベストプラクティスが詰まっていて触れるたびに嬉しくなります。</p><p>明日のアドベントカレンダーは冷静沈着なTepiさんがTextのJetpack Composeで画像表示した話を書く予定とのことです。
Jetpack Composeは名前しか聞いたことがないので、新しい概念を見られそうで楽しみです！</p><p>それでは良いクリスマスを！</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/pl>#PL</a>
<a class=tag href=/%20tags/tech>#tech</a></p><p><time>2023-12-19 +0900</time>
lastmod: <time>2023-12-20 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/2023-09/>2023-09振り返り</a></h1><div><p><p>今月はインカレの運営準備と仕事を頑張った。またカレーとボルダリングを始めた。</p><p>インカレでは人に仕事を回す仕事でしっかりキャパオーバーした経験をできた。おかげで価値観を少し変えることができて、瞬殺できるタスクはすぐに瞬殺するのが楽だと思えるようになったし、瞬殺できない仕事もなんとか小さくしようともがけるようになった。この辺りは仕事でも意識しているところで、二つのサンプルがうまいこと僕の中で補い合って学びを得る機械になってくれた形だと思う。どちらもちゃんとした人たちが一緒に仕事をしてくれてフィードバックもくれる環境だから実現しているのだと思う。感謝だし、この環境に身をおけた運と自分を褒めてあげたい。</p><p>カレーもオリエンテーリングと職場の人たちが相補的に絡み合って好きになり始めた。ボルダリングもそうか。今の僕は職場とオリエン界隈の二つのコミュニティに支えられて生活を営んでいるみたいだ。充実している。いいこと。</p><p>ここまではいわゆるソフトスキルみたいな仕事をする上での能力とか趣味の話だったけど、純粋な技術の話でいうとWebアプリケーション開発のレイヤが低めのところが（どのくらいかわからないけど）強くなった。Rackみたいな構成とかDNSの話（間接参照は偉大だ）、アーキテクチャの成長のさせ方とかを新たに腹落ちさせた。</p><p>10月は趣味を深めつつ、ソフトスキルっぽい面ではきっちり仕上げるところを重視する。ガッとやる。技術はネットワークとかを深められると嬉しい。趣味は今のを深めていく。ボルダリングは週2回いけるといいなと思う。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tech>#tech</a></p><p><time>2023-10-02 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/generate-slides-from-template/>GASでスライド生成</a></h1><div><p><p>Google Slidesで作成したテンプレートファイルに文字列を置換する形でスライドを生成するスクリプトをChat GPTに書いてもらったのでメモ。</p><pre><code class=language-aa>+--------------------------------+
|                                |
|  {{氏名}}                      |
|                                |
|                                |
|     {{住所}}                   |
+--------------------------------+
</code></pre><p>みたいなスライドを作って、</p><pre><code class=language-csv>氏名,住所
佐藤太郎,日本のどこか
田中一郎,東京のどこか
</code></pre><p>みたいなスプレッドシートでスクリプトを実行すると以下のようなスライドをテンプレのあるスライドに追記する。</p><pre><code class=language-aa>+--------------------------------+
|                                |
|  佐藤太郎                      |
|                                |
|                                |
|     日本のどこか               |
+--------------------------------+

+--------------------------------+
|                                |
|  田中一郎                      |
|                                |
|                                |
|     東京のどこか               |
+--------------------------------+
</code></pre><p>スクリプトは以下。</p><pre><code class=language-gas>function createSlidesFromSheet() {
  var slideId = 'ここにスライドのIDを入れる'
  var sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  var data = sheet.getDataRange().getValues();
  
  var slide = SlidesApp.openById(slideId);
  var templateSlide = slide.getSlides()[0]; // テンプレートとして使う最初のスライドを取得
  
  var headers = data[0]; // ヘッダー行を取得

  // データ行をループ
  for (var i = 1; i &lt; data.length; i++) {
    var row = data[i];
    var newSlide = slide.appendSlide(templateSlide); // テンプレートスライドをコピー
    
    var shapes = newSlide.getShapes();
    for (var j = 0; j &lt; shapes.length; j++) {
      var shape = shapes[j];
      var text = shape.getText().asString();
      
      // スプレッドシートのヘッダーを参照して、対応するデータでプレースホルダーを置き換える
      for (var k = 0; k &lt; headers.length; k++) {
        var placeholder = '{{' + headers[k] + '}}';
        text = text.replace(placeholder, row[k]);
      }
      
      shape.getText().setText(text);
    }
  }
}

</code></pre></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-10-01 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/2023-09-bestbuy/>ベストバイ</a></h1><div><p><p>酔っていて興が乗ったので「しばらくの間で買って良かったもの」N選をやります！！</p><h2><a href=#%e6%9c%ac%e6%a3%9a id=本棚 class=anchor aria-hidden=true>本棚</a></h2><p>本棚を買いました！横に長いタイプの本棚で、高さは太ももくらいです。二段だけで、本棚の上にも物を置けるような感じ。幅は120cmくらい（ところでセンチって微妙ですよね）で、横に長めの本棚です。
2cmくらいの厚さのベニヤ？でできていて、それなりに丈夫そうな雰囲気があります。
minneで買いました。一階にプログラミング言語のほんを置いて、2階にそのほかの本を置いています。本棚にある本の中でのおすすめは、『数学の基礎 集合・数・位相』です。これを読むと実数の作り方がわかって感動できます。また、眠れない夜にぴったりで、楽しめるときには存分に興奮できるし、そうでもないときには眠くなります。ホテルに聖書の代わりにこれを置いたらいいのにと思ってます。</p><h2><a href=#%e3%83%91%e3%82%bd%e3%82%b3%e3%83%b3 id=パソコン class=anchor aria-hidden=true>パソコン</a></h2><p>M2 macbook airを買いました！これはいい物です。ノートパソコンのいいところは椅子に座らないでも使えるところです。仕事で疲れた体でも、ノートパソコンならさわれます。退勤後もキーボードを触る幸せを感じられるのはノートパソコンのおかげです。ところで酔った状態でキーボードを叩いていると、タイプミスが頻発します。タイピングに頭のリソースを使っているようです。
m2 macbook airはキーボードがいい感じだし、性能もいいのがいいところです。メモリは16GBにしています。細かいことはよくわからないので、考えないことにします。</p><p>キリがない気がするので個数制限を設けましょう。
N=5にします。あと3個。</p><h2><a href=#%e3%83%ab%e3%83%b3%e3%83%90 id=ルンバ class=anchor aria-hidden=true>ルンバ</a></h2><p>ルンバを買いました。ルンバのいいところは、掃除でstuckしている光景がちょっとかわいそうなところです。彼は頑張って掃除してくれるのですが、たまに段差に座礁して身動きが取れなくなります。その姿は少し傷ましくて、それを避けるための掃除をしないとなという気持ちにさせてくれます。一人暮らしの家に優しさを発揮する機会を与えてくれるのがルンバのいいところなんじゃないかと思います。こういうふうに書くと彼はポンコツみたいな表現になってしまいますが、彼は僕より掃除が上手いです。頼りにしてるよ。</p><h2><a href=#echo-dot id=echo-dot class=anchor aria-hidden=true>echo dot</a></h2><p>会社に入るよりかは前に、echo dotを買いました。
echo dot自体がもたらす利益よりも、そのインターフェイスがあることを前提とした環境構築への影響がノミネートの理由です。
echo dotのおかげでルンバやswitch botを導入できました。音楽も流せるしアラームも設定できる。</p><h2><a href=#%e3%83%aa%e3%83%a5%e3%83%83%e3%82%af%e3%82%b5%e3%83%83%e3%82%af id=リュックサック class=anchor aria-hidden=true>リュックサック</a></h2><p>5月の頭にリュックサックを買いました。新宿の駅の近くの百貨店で見つけて、ゴールデンウィークいっぱい悩んでから購入に至りました。出勤も旅行もオリエンテーリングの遠征も全てこのリュックと一緒です。ちょっと小さいけど必要十分な機能提供してくれている感じが好き。</p><h2><a href=#%e3%81%be%e3%81%a8%e3%82%81 id=まとめ class=anchor aria-hidden=true>まとめ</a></h2><p>いかがだったでしょうか？
この記事ではベスタバイ5選を紹介しました！
この記事が皆さんの参考になれば幸いです。よかったらチャンネル登録と高評価、よろしくお願いします。</p><pre><code>&lt;!-- エンディングテーマが流れる --&gt;
</code></pre></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-09-13 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/divide-dev-posts/>ブログを分割したい</a></h1><div><p><p>このブログは日記も開発っぽいことも両方書いてある。これらを別のサイトに分けようと考えている。</p><ul><li>開発の記事が日記に埋もれるのが嫌だから</li><li>今の環境だと開発の記事を書きにくい・表現しにくいから<ul><li>コードや数式を書きにくい・表示が微妙など</li><li>madoko使いたい</li></ul></li></ul><p>そのための準備としてnetlifyを試しに使ってみた。このブログのリポジトリを登録したら、特に細かい設定をしないでもシュッとデプロイできてしまった。すごい。DNSとかSSLとかの設定を試していく。</p><p>ところでデプロイの設定は何もわからないのでチュートリアルが必要。madoko使うなら設定ちゃんとしないとだろうし。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/idea>#idea</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-09-06 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/contract-programming/>契約と型検査</a></h1><div><p><p>プログラミングの型検査・契約・テストについて書きます。お酒を飲みながら書きました。注意は払ったつもりですが、変なところがあるかもしれません。</p><ul><li>契約とは何か<ul><li>例を含める</li></ul></li><li>どんな嬉しさがあるか</li><li>型検査との兼ね合い</li></ul><h2><a href=#%e5%a5%91%e7%b4%84%e3%81%a8%e3%81%af%e4%bd%95%e3%81%8b id=契約とは何か class=anchor aria-hidden=true>契約とは何か</a></h2><p>契約 (contract) とはプラグラムの関数の入出力に関する規約のことです。例えば整数の割り算をする <code>div</code> 関数は、二つの整数を受け取って商を返す関数だとしましょう。このとき、入力の二つの値は</p><ol><li>どちらも整数</li><li>二つ目の整数は0ではない</li></ol><p>ことが求められます。また、整数の割り算を行なっているので、<code>div(a,b)</code> の値は例えば</p><ol><li><code>a</code> の絶対値以下であること</li></ol><p>が求められます（もっと細かい要求をしても良いでしょうが）。箇条書きで示したような <code>div</code> 関数について求められる性質のことを契約とよぶことが多いです。</p><p>ここまでで例を示しました。例のことは忘れて一旦抽象的な定義を試みましょう。契約は関数を呼び出す側と呼ばれる定義の間の約束事です。関数を<strong>正しく</strong>呼べば<strong>正しい結果</strong>を返すことを規定します。どんな呼び出しが正しくて、正しい呼び出しをされたと仮定とした上でどんな結果が正しいかを規定するのが<strong>契約</strong>です。</p><p>先ほどの例を考えると、 <code>div</code> 関数の第二引数に0を渡すのは呼び出し側の契約違反で、<code>div(168,4)</code> の結果が42にならないのは関数定義の契約違反です。契約は、関数呼び出しにおける呼び出し側と定義側との間の規約を表明し、検査します。</p><p>多くの言語でコードを書く際は、関数の冒頭で引数のチェックをして、呼び出し側の責任を追及するスタイルでコードを書くことになりがちです。言語によっては組み込みの機能でいい感じに契約を書いて、実行時に検査できます。
D言語とかRacketがいい例です。</p><p>例えばRacketだと、モジュールでエクスポートする関数を表明する箇所で、関数の契約を書きます。完全に雰囲気ですが、おそらくこんな感じで書くんじゃないかったかと思います。正確にはRacket GuideかRacket Referenceをご覧ください。</p><pre><code class=language-racket>#lang racket

(export
  (div (-&gt; (and int (lambda (x) (&lt; 0 x) )) int  int)))

...

(define (div a b)
  (/ a b))
</code></pre><h2><a href=#%e5%a5%91%e7%b4%84%e3%81%ae%e5%ac%89%e3%81%97%e3%81%95 id=契約の嬉しさ class=anchor aria-hidden=true>契約の嬉しさ</a></h2><p>契約を書いておくと何が嬉しいでしょうか。問題の切り分けが楽になることが嬉しいですね。<a href=https://dl.acm.org/doi/10.1145/3371133>Blame shifting</a>ができます。みなさん人生で一回は <code>Segmentation fault</code> とか <code>Null pointer exception</code> とか <code>car: cannot apply for nil</code> みたなエラーに遭遇したことがあるかと思います。これらのエラーは契約をちゃんと関数に書いていないから起きるはずで、まともなライブラリを使っていればあまりみないはずです。これらのエラーが出たときには割と深く絶望して、どの関数が悪さをしているか探す旅が始まります。</p><p>もし真面目に契約を書いていれば関数が許さないnilを受け取った時点で呼び出し側に責任があることを即座にエラーを起こしたり、変な結果を返しそうになったら返す直前に同様にエラーを起こします。</p><p>これが契約の嬉しさです。反対に、関数を動かして契約違反で怒られない限り、その契約を実装が遵守していることが保証されます。これもまた契約の嬉しさの一つです。契約はプロダクション環境で生きているドキュメントとして機能します。</p><p>テストとの違いは、契約は実行時に検査をすることが大きいでしょう。テストはテストを走らせるときにしか検証を行いませんが、契約は実行時にも検査を行います。プロダクション環境で関数を呼び出すときにも契約は検査されるのです。</p><h2><a href=#%e5%9e%8b%e6%a4%9c%e6%9f%bb%e3%81%a8%e3%81%ae%e5%85%bc%e3%81%ad%e5%90%88%e3%81%84 id=型検査との兼ね合い class=anchor aria-hidden=true>型検査との兼ね合い</a></h2><p>契約はいいものであることがわかったと思います。関数定義の性質を保証して、何かあれば<strong>すぐに</strong>検出し、何もなければ、すべてのそれまでの実行で違反したケースがないことを保証します。</p><p>この観点で見たときに、型検査はテストよりも契約に近しい存在だと言えるでしょう。型検査は、コンパイルのたびに型制約が満たされていることを検証します。健全な（まともな）型システムでは、型検査をパスしたプログラムは実行時に型エラーを起こさないことが保証されます
（この保証がある型システムのことを健全だというので順番は逆ですが）。型検査では、関数の入力として渡される値が、関数が期待する条件を満たすことを検査しますし、関数が返す値が宣言にあっていることも検査します。契約と対比させると、契約は実行時に検査を行う一方で、型検査はコンパイル時に行うという感じです。</p><p>逆にいうと、契約は型検査で静的にやろうとする検査を実行時まで遅延したものです。実行時には任意の計算をできるので表現力は契約の方が高いです。例えば引数の値が10と20の間である、みたいなことを検査するのは型検査では大変ですが、契約ならちょちょいのちょいです。</p><p>じゃあ契約だけでいいじゃないか、型検査なんてやめてしまえ！という話になるかというと、そういうわけにもいきません。型検査には契約にないよさがあります。</p><p>型検査の良さは静的に検証が済むことにあります。つまり、以下の二つを型検査は満たします</p><ol><li>全ての実行について、検証結果が成立する</li><li>プログラムを実行しないでも検証を行える</li></ol><p>まず一つ目について。契約やテストでは、実行した場合については動作を検証してくれますが、それとは違う値については特に保証をしてくれません。だから境界テストみたいな、人間が上手に動かす技法が使われるのでしょう。型検査では、ある程度検証内容を抽象的にしたり保守的にすることで、全ての実行に対する性質を保証します。
intが返る関数は決してfloatを返さないことを型検査では保証できます。</p><p>抽象化や保守的な検査を行う二つ目の恩恵として、実行しないでも検証できることが挙げられます。本番環境で動かさないとわからなかったり、テスト環境をせっせと用意する必要は、型検査では生じません。</p><h3><a href=#%e3%83%86%e3%82%b9%e3%83%88%e3%81%af%e3%81%84%e3%82%89%e3%81%aa%e3%81%84 id=テストはいらない class=anchor aria-hidden=true>テストはいらない？</a></h3><p>型検査や契約の有用性を主張してきましたが、それでもテストは必要です。実際に色々な具体的なケースで動かすことでわかることは多いでしょう。型検査は動かさないでもわかることを検証して、契約は動かしたらわかることを検証します。テストはプログラムを動かしてみて検証します。型や契約だけではプログラムを動かすことはありません。そこが大きな違いなはずです。</p><p>それでも全ての異常の検知をテストでまかなう必要もないはずです。契約や型検査は保証をする仕組みとして優秀です。基本的な保証は契約や型検査で済ませて、本当に際どいところをテストでカバーする、みたいな役割分担をすると幸せになれるんじゃないでしょうか。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/pl>#PL</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/alcohol>#alcohol</a></p><p><time>2023-08-31 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/task-decomposition/>タスク分解と見積もり</a></h1><div><p><h2><a href=#%e8%a6%8b%e7%a9%8d%e3%82%82%e3%82%8a%e3%81%a8%e7%9b%ae%e6%a8%99 id=見積もりと目標 class=anchor aria-hidden=true>見積もりと目標</a></h2><p>見積もりとかについて真面目に考えてみる。</p><p>仕事をするときに、頑張ります！と意気込んで、目標を分解しひとつひとつこなしていくことはある程度できるし、途中で分解したタスクが違った方を向いていることに気がついて、自分がやることを軌道修正することもできる。</p><p>全部ではないけれど、ある程度のことは十分に時間があれば達成できるんじゃないかと思う。特に目標を具体的に描けていればできることは多い（できないことをなかなか目標として想像できないとか、そもそもできないことがある、みたいな話はそれはそうだけど一旦置いておく）。</p><p>仕事とかチームで動くときとかでは、歩みを揃えられることが大事なわけで、自分の好みで十分な時間を消費して良いわけではない。仕事では、目標に、達成する事項だけでなく期限がついてくる。目標を達成できそうかを判断するには、期限と見積もりを照らし合わせれば良い。</p><h2><a href=#%e3%82%bf%e3%82%b9%e3%82%af%e3%81%a8%e6%9c%9f%e9%99%90 id=タスクと期限 class=anchor aria-hidden=true>タスクと期限</a></h2><p><strong>目標</strong>は期限と達成する事項のペアだと思うことにして、達成する事項のことは<strong>タスク</strong>と呼ぶことにしよう。つまり、目標はタスクと期限のペア。今まではタスクを分解して一個ずつクリアしていけば良かったが、仕事では目標を分割して、タスクをクリアする中で期限も一緒に守らないといけない。次元が増えるのだから難しくなるのは当たり前だ。</p><p>タスクの分解は、タスクをよく観察して論理的に推論すれば割と上手くいく。それに対して期限を含めてうまく目標を細分化するには、つまり見積もりをするには、自分の能力や環境要因、タスクの達成の確実性などを含めて考慮しないと考え切ることはできない。</p><p>見積もりは曖昧さを伴ったものになるはず。そこが難しいのかな。また、タスクを分解して軌道修正をするとタスクはそれで洗練される一方で、期限の方は純粋に遅れが生じるのも難しい。時間は巻き戻らないのだ。</p><h2><a href=#%e8%a6%8b%e7%a9%8d%e3%82%82%e3%82%8a%e3%81%ae%e5%ae%89%e5%ae%9a id=見積もりの安定 class=anchor aria-hidden=true>見積もりの安定</a></h2><p>見積もりを安定させるには、このように生じる遅れの量を最小化すれば良い。そのためには目標の分解を小さくして、細かい粒度で軌道修正すれば安定するはず。あまり細かく分解しないでガッと取り組みうまくいけば最速だし、細かく分解して検討を繰り返して良さそう良さそうと確認をたくさんするのは時間がかかる。それでも確認することを込みで見積もることはできるので、安定性の面ではやはり有利に働くだろう。この辺りは最急降下法とかで、一回のイテレーションでどのくらい進むのが良いか、みたいな話と似ている。</p><p>なんにせよ、今の僕は安定した見積もりをできていないので学習の意味を込めて、細かすぎるくらいのタスクの分解をするのが良いのだろうなと思った。</p><p>自分の性格と合うだろうか。</p><h2><a href=#%e3%83%81%e3%83%bc%e3%83%a0%e3%81%a7%e3%81%ae%e4%bb%95%e4%ba%8b id=チームでの仕事 class=anchor aria-hidden=true>チームでの仕事</a></h2><p>先ほどの段落で、一発でガッと仕事して上手くいけばそれが最速、みたいなことを言った。これが実際にありうるのは個人で仕事をしているときであって、チームで仕事をするときには普通以心伝心というわけにはいかず、解釈違いやすり合わせ、議論に会話が必要だろうし、それができるのがチームの強みのはず。</p><p>これをこまめに行うことは、多くのチームにとって課題だろうし、僕がチームに参加するときに度々足りていないなと思うところでもある。</p><p>タスクの分解を細かくすることでコミュニケーションの機会を増やせるだろうから、チームでの仕事には細かいタスク分解がプラスに働きやすそう。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/idea>#idea</a>
<a class=tag href=/%20tags/alcohol>#alcohol</a></p><p><time>2023-08-31 +0900</time>
lastmod: <time>2023-09-06 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/dotfiles-setup/>dotfilesのセットアップスクリプトを書いた</a></h1><div><p><h2><a href=#%e5%8b%95%e6%a9%9f id=動機 class=anchor aria-hidden=true>動機</a></h2><p><a href=https://github.com/naoyafurudono/dotfiles/tree/main>dotfiles</a>をGitHubで管理しているのだが、今までは設定ファイルの管理だけで、インストールは手動で行なっていた。設定ファイルを使いまわせるだけでだいぶ便利なんだけど、コンテナ環境の中で作業したくなると、手動インストールに耐えられなくなる。そこで重い腰を上げてセットアップを自動化した。</p><h2><a href=#%e3%82%84%e3%81%a3%e3%81%9f%e3%81%93%e3%81%a8 id=やったこと class=anchor aria-hidden=true>やったこと</a></h2><h3><a href=#cli%e7%92%b0%e5%a2%83%e3%81%ae%e3%82%bb%e3%83%83%e3%83%88%e3%82%a2%e3%83%83%e3%83%97%e3%82%92%e7%b0%a1%e5%8d%98%e3%81%ab%e3%81%97%e3%81%9f id=cli環境のセットアップを簡単にした class=anchor aria-hidden=true>CLI環境のセットアップを簡単にした</a></h3><p><code>git</code> のインストールと以下の実行でok。
nvimとかfishとかcargoとかが入る。</p><pre><code class=language-sh>git clone https://github.com/naoyafurudono/dotfiles.git
bash dotfiles/setup.sh
</code></pre><h3><a href=#%e3%81%95%e3%82%89%e3%81%ab%e5%8b%95%e4%bd%9c%e7%a2%ba%e8%aa%8d%e3%81%ae%e3%81%9f%e3%82%81%e3%81%aedocker%e3%82%92%e7%94%a8%e3%81%84%e3%81%9f%e3%83%86%e3%82%b9%e3%83%88%e3%82%82%e6%9b%b8%e3%81%84%e3%81%9f id=さらに動作確認のためのdockerを用いたテストも書いた class=anchor aria-hidden=true>さらに動作確認のためのDockerを用いたテストも書いた</a></h3><p><a href=https://github.com/naoyafurudono/dotfiles/tree/main#test>test</a></p><p>arm環境かつubuntuだけでしか動かしていないが、dockerコンテナでセットアップスクリプトを動かして、正常に終了するかを確認するテストを書いた。</p><h2><a href=#%e6%b0%97%e3%81%ab%e3%81%aa%e3%82%8a%e3%81%94%e3%81%a8 id=気になりごと class=anchor aria-hidden=true>気になりごと</a></h2><p>この手のセットアップスクリプトのテストって、世の中ではどのようにテストしているんだろう。以下の難しさがテストを大変にしている気がする。</p><ul><li>環境依存な部分をうまく吸収する必要があること</li><li>インストール失敗の判定が難しいこと</li></ul></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/ubuntu>#ubuntu</a>
<a class=tag href=/%20tags/idea>#idea</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-08-17 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/arm64/>arm64のメモ</a></h1><div><p><p><a href=https://github.com/naoyafurudono/comp>Cコンパイラを実装する</a>ためにarm64のことを調べている。この記事はそのメモ。</p><h2><a href=#%e5%85%ac%e5%bc%8f%e3%83%89%e3%82%ad%e3%83%a5%e3%83%a1%e3%83%b3%e3%83%88 id=公式ドキュメント class=anchor aria-hidden=true>公式ドキュメント</a></h2><p>よくあるソフトウェアのライブラリについているドキュメントとは毛色が違う。</p><ul><li><a href=https://developer.arm.com/documentation/den0024/a/An-Introduction-to-the-ARMv8-Instruction-Sets>Armv8-A Instruction Set Architecture</a>が優しい<ul><li><a href="https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/Learn%20the%20Architecture/Armv8-A%20Instruction%20Set%20Architecture.pdf?revision=ebf53406-04fd-4c67-a485-1b329febfb3e">PDF版もある</a>。空白多めのシングルカラム39ページなのでサクッと読める。最初に読んでおくと幸せになれたかも。</li></ul></li><li><a href=https://github.com/ARM-software/abi-aa/releases/download/2023Q1/aapcs64.pdf>Procedure Call Standard for the Arm® 64-bit Architecture (AArch64) (pdf)</a>がCコンパイラを実装するときに気になる細かいことをコンパクトにまとめてそうな印象。</li><li>上のドキュメントを含む<a href=https://github.com/ARM-software/abi-aa/releases>公式のリンク集がある</a></li></ul><h2><a href=#%e3%83%84%e3%83%bc%e3%83%ab id=ツール class=anchor aria-hidden=true>ツール</a></h2><p>Arm macを使っている人の話です。</p><ul><li>既存コンパイラがはくアセンブリを覗く方法<ul><li>アセンブリをはく: <code>gcc -O0 -S</code></li><li>ディスアセンブル: <code>otool -vVt</code></li></ul></li><li>デバッガで調査する<ul><li>lldbが使える</li><li>エラー箇所の特定に便利</li><li>ドキュメント<ul><li><a href=http://www.den.t.u-tokyo.ac.jp/ad_prog/debug/>入門記事（東大の講義ページ）</a>
何もわからんくなったら{ここに立ち返る|ここから始める}のが良さそう</li><li><a href=https://lldb.llvm.org/use/tutorial.html>公式チュートリアル</a>: ちょっと読んだ。真面目に勉強するなら導入に良さそう</li></ul></li></ul></li></ul><h2><a href=#%e6%84%9f%e6%83%b3 id=感想 class=anchor aria-hidden=true>感想</a></h2><p>アセンブリ命令って割と体系的になってなくてやばいイメージがあったけど、
arm64は秩序がある程度あるように感じている。まだ深淵を覗けていないだけかもしれないが。汎用レジスタの名前が簡単なことが大きいかもしれない。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/pl>#PL</a>
<a class=tag href=/%20tags/comp>#comp</a>
<a class=tag href=/%20tags/tech>#tech</a></p><p><time>2023-07-15 +0900</time>
lastmod: <time>2023-07-22 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/2023-05/>2023-05振り返り</a></h1><div><p><h2><a href=#5%e6%9c%88%e3%81%ae%e3%81%b5%e3%82%8a%e3%81%8b%e3%81%88%e3%82%8a id=5月のふりかえり class=anchor aria-hidden=true>5月のふりかえり</a></h2><p>月末なので気まぐれに今月を振り返る。</p><h3><a href=#%e4%bc%9a%e7%a4%be id=会社 class=anchor aria-hidden=true>会社</a></h3><p>エンジニア研修が始まった。ビジネスっぽい話も面白かったけど、エンジニアっぽい話とは違う面白さだった。プログラムに関して議論するのはやはり楽しい。</p><h3><a href=#%e9%80%b1%e6%9c%ab id=週末 class=anchor aria-hidden=true>週末</a></h3><p>蓼科と山口にいったし、日本ダービーにも行った。だいぶ遊んだ気がする。静かな週末は一回くらいだったかも知れない。読みたい本が溜まっている。</p><h3><a href=#%e5%b9%b3%e6%97%a5%e5%8b%a4%e5%8b%99%e6%99%82%e9%96%93%e5%a4%96 id=平日勤務時間外 class=anchor aria-hidden=true>平日勤務時間外</a></h3><p>走る機会を減らして筋トレを増やしている。体重計に乗っていないので成果の程は定かでないが、体感筋肉が増えた気がする。たまに13km走るとしんどい。</p><h3><a href=#%e3%81%9d%e3%81%ae%e3%81%bb%e3%81%8b id=そのほか class=anchor aria-hidden=true>そのほか</a></h3><ul><li>親に初任給で何買うか決めてない<ul><li>個人的に気になっている家電を送りつけて、レビューをもらう案が今のところ最有力<ul><li>いいトースター</li><li>ルンバ</li></ul></li><li>その他の案<ul><li>置き時計・壁時計</li><li>ケーキ（一緒に会えれば）</li></ul></li></ul></li><li>いらないものを処分したい</li><li>本棚がほしい<ul><li>これは6月の課題にしよう</li><li>いい感じの本棚を選んで、それに見合った量の本だけ残してあとは処分する</li></ul></li><li>オリエン大会の運営２つに参加することになった。どちらもまだ、そんなに動いていないけど放置はできない感じ。楽しみ。</li></ul><h2><a href=#6%e6%9c%88%e7%9b%ae%e6%a8%99 id=6月目標 class=anchor aria-hidden=true>6月目標</a></h2><p>すべて6/30 9:00が締め切り。来月は振り返りと次の目標策定をする。それは6/30 23:00締め切り。</p><h3><a href=#%e7%94%9f%e6%b4%bb%e3%81%ae%e3%81%93%e3%81%a8 id=生活のこと class=anchor aria-hidden=true>生活のこと</a></h3><ul><li>親に初任給でなにか贈る<ul><li>喜んでもらえるもの</li><li>ついでに僕も楽しいもの</li><li>兄に酒でも贈るか</li></ul></li><li>部屋をいい感じにする: 読書と衣類を最適化する<ul><li>本棚を一つ買う</li><li>本と服を処分する</li><li>夏っぽい服を買う</li></ul></li></ul><h3><a href=#%e4%bb%95%e4%ba%8b%e3%81%ae%e3%81%93%e3%81%a8 id=仕事のこと class=anchor aria-hidden=true>仕事のこと</a></h3><ul><li>クラウド・インフラの理解を深める<ul><li>ラズパイ買ったのでそれで遊ぼう</li><li>ネットワークとOSをいじる</li></ul></li><li>仕事の議論についていけるようになる</li></ul><h3><a href=#%e8%b6%a3%e5%91%b3%e3%81%ae%e3%81%93%e3%81%a8 id=趣味のこと class=anchor aria-hidden=true>趣味のこと</a></h3><ul><li>月間120km走る<ul><li>2日あたり8km</li></ul></li><li>自炊写真をインスタする<ul><li>食器がネック</li></ul></li><li>運営で友達を増やす<ul><li>試走で運営に関係ない話をするひとが増えるとよい</li></ul></li><li>PC環境をなにかしら改善する<ul><li>開発環境系がいいな。キーボードショートカットとかウィンドウマネージャもあり</li></ul></li></ul></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a></p><p><time>2023-05-31 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/alc-tag/>alcoholタグの運用</a></h1><div><p><p>ブログの"alcohol"タグをいつからか使い始めた。当初はお酒に関する記事につけるタグのつもりで使い始めたのだが、この度アルコールが入った状態で書いた記事にもつけることにした。</p><p>この記事の"alcohol"タグはどういう意味なのかはクイズにしたらおもしろいだろうか（こういう書き方をすると、お酒が入っているとばれるのだろう）。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/alcohol>#alcohol</a></p><p><time>2023-04-28 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/univ-tech/>学生生活の振り返り（技術）</a></h1><div><p><h2><a href=#%e3%81%be%e3%81%88%e3%81%8c%e3%81%8d id=まえがき class=anchor aria-hidden=true>まえがき</a></h2><p>昨日学籍を失って、こんど入社式に出る。学校に入ったり研究室に所属したり、就職したりするときには自分が抱える課題と向き合い、自分の幸せについて考えて進路を決めてきた。これから先はそういう機会が来たことに気が付きにくくなるだろう。</p><h2><a href=#%e5%ad%a6%e9%83%a8%e3%81%ae%e9%81%b8%e6%8a%9e id=学部の選択 class=anchor aria-hidden=true>学部の選択</a></h2><p>高校生のころ、大学にはいることは周りの雰囲気からして僕の意思が入る余地はなく決まっていた。そのなかで進路を悩んだ。理学と工学のどちらかにしようとは早く決めたのだが、そこからの踏ん切りがなかなかつかず、出願するときにエイヤと決めた。学問自体の面白さは理学に惹かれていたけど、就職とかキャリア的なことを考えると工学がよいのではないだろうかみたいな悩みかただったと思う。結局目先の面白さを優先して理学を選んだのだった。就職はなんとかなるだろうと踏んでいたし、学問の選択でなんとかならないのなら、自分は他の要因でなんとかならない人間であるはずなので、学問の選択でキャリアが狂うことを心配するのは無駄だと結論づけた。</p><h2><a href=#%e5%8c%96%e5%ad%a6%e3%81%8b%e3%82%89%e6%95%b0%e7%90%86%e8%a8%88%e7%ae%97%e3%81%b8%e3%81%ae%e8%88%88%e5%91%b3%e3%81%ae%e8%bb%a2%e5%90%91 id=化学から数理計算への興味の転向 class=anchor aria-hidden=true>化学から数理・計算への興味の転向</a></h2><p>高校生のころは化学が好きで、特に化学反応に惹かれていた。水素と酸素を一緒にしてエネルギーをかけると十中八九水に落ちるのが不思議だと感じた。統計的にそうなるのは受け入れらたのだが、反応の過程でなにが起きているのかがとても気になったし、この好奇心は普遍的なもので、すでに賢いひとが調べているはずなので大学で勉強したいと思っていた。大学で蓋をあけると、学部でやった化学や研究室で行われている研究は思ったよりもぼくにとって腑に落ちない考え方をしていて、そのなかで勉強してもぼくはあまり幸せになれないだろうと感じた。</p><p>では腑に落ちるのはどういうときだろうか、みたいなことが気になりだした。これは学部一年の後期くらいのこと。論理学とか心理学とか数学とかに答えがあるかもしれないと思いはじめて、論理学と数学を扱う数理計算科学系に所属することにした。所属のためにはある程度の成績が必要だったのだが、勉強が楽しかったのと、なにより友達に恵まれたおかげで、無事に所属できた。</p><h2><a href=#%e6%95%b0%e5%ad%a6%e8%ab%96%e7%90%86%e5%ad%a6%e3%81%8b%e3%82%89%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0%e8%a8%80%e8%aa%9e%e7%90%86%e8%ab%96%e3%81%b8%e3%81%ae%e8%bb%a2%e5%90%91 id=数学論理学からプログラミング言語理論への転向 class=anchor aria-hidden=true>数学・論理学からプログラミング言語理論への転向</a></h2><p>数理計算の学部の講義（2018年4月から2020年3月）はどれも大体おもしろかった。集合論とか解析の話をしっかり数学者に教えていただけたのは幸せだったと思う。議論を正面からできる相手も複数人いてだいぶ恵まれていた。</p><p>学部では、数学の基礎や応用数学の入門や基礎（ORや確率・統計など）、計算機科学を学んだ。どれも専門的な議論はできるほどにはならないが、その手の書籍が怖くない程度には身につけることができた。数理論理学の講義も取り、不完全性定理の証明を追うなどした。これらの学問は現象を表現する数理的な手段を追求するものとしての側面をもち、当初の想定以上にぼくがかかえていた「腑に落ちること」の解釈（？）に影響を与えてくれた。</p><p>心理学とか小説とか、数理的とは限らない本を読むこともしていた。そういう本を本で、自分の中で巡らせていた理解を答え合わせしていたのだと思う。なんやかんやあって理解することとか腑に落ちること自体にはある程度の安定した解釈を持てて、実用上困らなくなった。</p><p>ここまでが学部3年のこと。学部3年の後期に研究室に体験所属みたいなことをして、輪講みたいなことをする機会が会った。そこで型理論に入門した。それまではプログラミングが好きじゃなかったのだが、プログラミング言語はおもしろいと思うようになった。研究室の先生方がとくに魅力的なことを決め手にして、所属を決めた。</p><h2><a href=#%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0%e8%a8%80%e8%aa%9e%e7%90%86%e8%ab%96 id=プログラミング言語理論 class=anchor aria-hidden=true>プログラミング言語理論</a></h2><p>プログラミング言語の理論の勉強、研究はおもしろかった（2020年10月から、研プロを含む）。論文や教科書はいままでで一番熱心に読んだし、人と議論して楽しいと感じた。研究でも小さなものではあるが世の中の知見を広げた感覚は得られた。この感覚は個人として、とても大切なものだと思っている。数学のゾクゾクする定理の証明を理解したときの感覚を、だれから教えられるわけでもなくて、自分で考えて得られたことが嬉しかったし、それを人に共有できる喜びもあった。</p><h2><a href=#%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0 id=プログラミング class=anchor aria-hidden=true>プログラミング</a></h2><p>プログラミング言語についていると、嫌でもプログラミングのことを考える。この型システムを持つ言語は使いやすいだろうか、どういうふうにプログラミングがかわるだろうか、など。残念ながら僕にはプログラミングの経験があまりなく、その思考の幅が広がらなかった。このままではだいぶ人生損すると思ってプログラミングをがんがんやりたいと思うようになった。修士1年のころにはこの思いはそれなりに持っていた。</p><p>はじめの頃はどこから手を出していいかわからずだいぶ迷走した。コンパイラ最適化の実装やインターンへの参加もして、ある程度開発をしたが世の中で行われているプログラミングとの乖離を感じていた。</p><p>転機になったのが、mepayでtentenさんが主催して開催されたGo関連の短期インターン（2022年3月）だった。そこでGo言語に触れたことも大きかったし、なによりエンジニアやそれを志向する学生とコミュニケーションを取れたことでいわゆるソフトウェアエンジニアがどんなことをしていて、彼らがするプログラミングを垣間見た。その後友達の紹介でキャディでのアルバイトをはじめて、プログラミングの幅がさらに広がった。</p><p>今のぼくの関心事は上手に楽しくプログラミングをすることにある。きれいに書くとか、メンテナンスできるとか、思ったことを自然に表現できるとか、どういう考え方がいい、みたいなことに興味がある。これからはプログラミングの幅をもって広げつつ、上手に表現することを直近では追求したい。さらにそのためのプログラミング言語や環境などについても考えて、形にできたら楽しそうだと思う。</p><h2><a href=#%e3%81%82%e3%81%a8%e3%81%8c%e3%81%8d id=あとがき class=anchor aria-hidden=true>あとがき</a></h2><p>腑に落ちて、自由自在に扱えるようになると楽しいと僕は感じるのだろう。そのための過程にも楽しさを感じるように思う。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a></p><p><time>2023-04-01 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/notify-github-actions/>GitHub Actionsの実行結果をDiscordに通知</a></h1><div><p><p>このブログはGitHub Actionsでデプロイしているのだが、ここしばらくデプロイに失敗したことに気が付かずに放置してしまっていた。</p><p><a href=https://github.com/marketplace/actions/actions-status-discord>Actions Status Discord</a>というアクションを<a href=https://github.com/naoyafurudono/naoyafurudono.github.io/commit/1f7a900b4c8aa166dd735c61ee1667119b23e810>デプロイの最後に叩く</a>ことで、いい感じの通知をDiscordにWebhook経由で送れる。</p><p><a href=https://github.com/naoyafurudono/naoyafurudono.github.io/blob/3943f0fbf808d0ec880b3e7b9c901d0909eb35bd/.github/workflows/gh-pages.yml#L44>こんな感じに</a>実行条件を指定しないと、デプロイが失敗したときに通知が実行されないことに注意。デフォルトでは <code>if ${{ success() }}</code> が指定されたものとみなされるとのこと。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-03-30 +0900</time>
lastmod: <time>2023-07-01 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/custom-markdown-translation-with-hugo/>Hugoのマークダウン処理をカスタム</a></h1><div><p><h2><a href=#%e8%83%8c%e6%99%af id=背景 class=anchor aria-hidden=true>背景</a></h2><p>HTML文書のheading要素の周りには<code>id</code>がついていてほしいし、それへのリンクは手軽にコピーできて欲しい。その点Googleのドキュメントはとても好き。人に文書コンテンツを渡すときにこちらの意図がURLで表現できるし、そのリンクを踏んだ側も見るべき箇所にスムーズにたどり着ける。このブログを書くのに使っているHugoでも同じことをした。</p><h2><a href=#%e3%82%84%e3%82%8b%e3%81%93%e3%81%a8 id=やること class=anchor aria-hidden=true>やること</a></h2><p><a href=https://github.com/naoyafurudono/naoyafurudono.github.io/commit/3f28cbafd119216c194b82d1fded6b373e7a7332>このコミット</a>のように、<a href=https://gohugo.io/templates/render-hooks/#heading-link-example>headingのHTMLへの変換を定義する</a>。</p><p>示したコミットでは<code>a</code>タグで囲むだけでなく、heading levelを増やしている。
Hugoではタイトルを<code>h1</code>にするにもかかわらず、マークダウンの<code>#</code>も<code>h1</code>にする。そのせいで、本文を書くときは<code>##</code>から始める必要があって気持ち悪い。この気持ち悪さを解消するために、マークダウンのheading level+1をhtmlのheading levelとしている。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/daily>#daily</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/window-manager/>使い勝手の良いデスクトップ向けウィンドウマネージャが欲しい</a></h1><div><p><p>使い勝手のよいウィンドウマネージャがWindowsとかMacに搭載されることはないだろう。使うアプリケーションやブラウザ、入力デバイスやその使い方によって使い勝手が大きく変わるだろうから。
OSが決め打ちで提供できるものでは無いんじゃないかと思う。なので自分でまじめに使い勝手の良いものを考える必要がある。</p><p>先日オリエンテーリングのインカレの配信のお手伝いをしたのだが、そこで使っていたスイッチャがなかなかデスクトップでのウィンドウマネージャの機能として魅力的に感じた。</p><p>スイッチャにはいろんなウィンドウ（カメラからの入力や、図、合成用のテロップなど）が接続されていて、すべてが画面の下部に控えめに表示される。それらを見ながらスイッチャのオペレータが放送するためのウィンドウを選択、合成する。放送されるウィンドウは画面上部に大きく表示される。放送されるウィンドウの右に同じサイズでプレビューウィンドウも表示される。これらの違いは放送されるか否かだけで、合成のテストとかに使える。</p><p>これを実現するためには操作用のデバイス（このデバイスをスイッチャというようだ）と、大きなモニタが必要だ。</p><p>デスクトップのウィンドウマネージャでもスイッチャのように</p><ul><li>すべてのウィンドウを表示しておいて</li><li>本番+alphaくらいのウィンドウをメインエリアに表示する</li></ul><p>と便利な気がする。単純にはいかないだろうけど、いい線行きそうだ。</p><p>懸念事項は以下の通り:</p><ul><li>ウィンドウの個数が多くなりそう</li><li>ウィンドウサイズが固定ではない（アスペクト比）</li><li>ウィンドウの動的な生成とその配置方法が非自明</li></ul></p></div><div class=post-footer><p><a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/idea>#idea</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-03-16 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/effect-handlers-without-continuation/>エフェクトハンドラの良さと実用性について</a></h1><div><p><p>エフェクトハンドラで継続や代数的エフェクトを扱う必要性は一ミリもなくて、実用的にそれらが欲しくなることはないか、あるいは限られていてそこまで一般的な機能を提供する必要はないんじゃないかと感じている。</p><p>このあたりを議論するために</p><ol><li>エフェクトハンドラの嬉しさ</li><li>意味論の歴史的経緯</li><li>改善ポイント</li></ol><p>を考える。</p><p>なお、この記事はとくに裏付けもなく書いている。気が向いたら裏付けをしようと思っているが、この記事の目的は僕の考えの整理であって、世に主張をしたいわけではない。</p><p>記事の内容は不正確なことを留意されたい。</p><h2><a href=#%e3%82%a8%e3%83%95%e3%82%a7%e3%82%af%e3%83%88%e3%83%8f%e3%83%b3%e3%83%89%e3%83%a9%e3%81%ae%e5%ac%89%e3%81%97%e3%81%95 id=エフェクトハンドラの嬉しさ class=anchor aria-hidden=true>エフェクトハンドラの嬉しさ</a></h2><p>エフェクトハンドラが実際的 (practical) なプログラミング言語でエンドユーザに使わせたくなるのは</p><ul><li>エフェクトシステムと相性のよい意味論</li><li>動的束縛</li></ul><p>を提供したいからではないだろうか。エフェクトハンドラを言語に入れれば、それで表現できる操作は自動的にエフェクトシステムで追跡できるし、ハンドラを用いることでエフェクトをローカルに使えるのは特筆するべきだろう。汎用性とlocal reasoningのしやすさはエフェクトハンドラのもつ良い性質だと思う。</p><p>エフェクトハンドラで実現できる動的束縛はとても使い勝手が良い上に、エフェクトシステムで追跡することで使い勝手が上がりそうだ。動的束縛のためだけのエフェクトシステムではなく、もう少し凝ったことができるエフェクトシステムがつくとなお幸せだろうから、エフェクトハンドラみたいな抽象度の比較的高いフレームワークで実現するのは幸せなんじゃないかと感じる。</p><h2><a href=#%e6%84%8f%e5%91%b3%e8%ab%96%e3%81%ae%e6%ad%b4%e5%8f%b2%e7%9a%84%e7%b5%8c%e7%b7%af id=意味論の歴史的経緯 class=anchor aria-hidden=true>意味論の歴史的経緯</a></h2><p>エフェクトハンドラと呼ばずに &ldquo;algebraic effects&rdquo; とか &ldquo;algebraic effects and handlers&rdquo;
とか呼ぶ流派、時代がある。歴史的には</p><ul><li>algebraic effects</li><li>algebraic effects and handlers</li><li>effect handlers</li></ul><p>みたいな流れで登場したはずだ。最初はハンドラはなくて、モナドとかの話をするような人たちが副作用にモナドではない別の表現を与えようとしたんだったか。ここでいうモナドはモナド則とかを真面目に考えるような数学のモナド。代数的エフェクトもその流れの中に（このころは）あったはず。そもそも代数的エフェクトの代数とは、操作が（0だか1こ以上）あって、それらに等式制約を課す。それを満たすようなモデルを持つのが代数 (algebra) である、みたいな世界だっと思う。群とか環は代数だけど、体は代数じゃないみたいな話を聞いたことがある。そういうのりの代数として、エフェクトを表現したらモナドの合成みたいなことを考えるときに幸せだ、という主張がことの発端だった気がする。</p><p>ここまでは数学とかモデル理論？とかの話によっていて、あまりプログラミング言語っぽい雰囲気がしない。ハンドラとか継続が入ってきた経緯はしらないが、多分、プログラミング言語に代数的エフェクトを入れるにあたって、モナドのbindやreturnみたいなものを定義するように、エフェクトに意味を与える仕組みとしてハンドラが考えられたんじゃないかと思う。このあたりは論文をまじめに読めば分かるはず。これが確か2014年くらいのこと。</p><p>2000年くらいだったかから考えられていたエフェクトシステムとの相性に目をつけたからか知らないが、「代数的エフェクトとハンドラ」を取り入れた言語が2014年ころに登場し始める。2017年くらいにでてくる印象がある。
EffやKokaはこのへんな気がする。このあたりで、エフェクトが代数的であることはとくに気にされなくなっていき、エフェクトシステムと例外ハンドラがうまいこと組み合わさる限定継続演算子くらいの気持ちで代数的エフェクトとそのハンドラが捉えられて、やがて代数的ではないことが気になる人々がエフェクトハンドラと呼ぶようになったのではないかと思っている。</p><h2><a href=#%e6%94%b9%e5%96%84%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88 id=改善ポイント class=anchor aria-hidden=true>改善ポイント</a></h2><p>限定継続は本当に必要だろうか。もっとやさしい概念を提供するのにとどめるのはいかがだろうか。ワンショット継続とかに限定する言語もあるが、それは正しい方向性だろうか。</p><p>僕たちがほしかったものは、local reasoningしやすいエフェクトシステムとそれで健全に管理できる意味論なんじゃないかと思う。エフェクトハンドラはその条件を満たすけど、もっと使い心地のよい意味論があるはずだと思う。</p><h2><a href=#%e3%81%82%e3%81%a8%e3%81%8c%e3%81%8d id=あとがき class=anchor aria-hidden=true>あとがき</a></h2><p>最後の文をメモしたくてこの記事を書いた。それ以外は文脈である。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/pl>#PL</a>
<a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/idea>#idea</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-03-16 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/gcp-cred/>Google Cloudの認証を必要とするアプリケーション開発について</a></h1><div><p><p>Google Cloudの認証・認可はきめ細かくちゃんとしている感じがして、扱うのが難しいと感じていた。少し調べたら<a href=https://cloud.google.com/docs/authentication/client-libraries#adc>Application Default Credentials with client libraries</a>の説明を見つけて腹に落ちた。これを抑えた上で、<a href=https://cloud.google.com/docs/authentication/provide-credentials-adc#how_to_provide_credentials_to_adc>それぞれの実行環境でどのようにcredentialをセットアップするか</a>を見ると、プロセスの権限が半分くらいわかる。ここまでで、サービスアカウントがどのようにプロセスに付与されるかを理解できるはずだ。</p><p>次に、それぞれのサービスアカウントがどのようなリソースへのアクセスをもつか、それをどうやって設定するかを確認すれば認証・認可を自由に管理できるんじゃないかと思う。<a href=https://cloud.google.com/docs/authentication/application-default-credentials#personal>How Application Default Credentials works</a>が良い水先案内に見える。</p><p>このあたりは知識がないと本当に挙動がわけわからないので分かりやすいところにドキュメントを置いといたり、積極的にエラーメッセージで教えてほしい。
Google Cloudを使う上での義務教育だと感じた。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-03-14 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/linux-keys/>Linux (gnome) でよくやる設定</a></h1><div><p><p>GNOMEというかLinuxというかでよくやる設定を列挙する。キーボード系が多いと思う。</p><h3><a href=#gnome-terminal-%e3%81%a7ctrl-shift-tab%e3%82%92%e6%9c%89%e5%8a%b9%e3%81%ab%e3%81%99%e3%82%8b id=gnome-terminal-でctrl-shift-tabを有効にする class=anchor aria-hidden=true>gnome-terminal で<code>ctrl-(shift-)?tab</code>を有効にする</a></h3><p>以下を実行</p><pre><code class=language-sh>gsettings set org.gnome.Terminal.Legacy.Keybindings:/org/gnome/terminal/legacy/keybindings/ next-tab '&lt;Primary&gt;Tab'
gsettings set org.gnome.Terminal.Legacy.Keybindings:/org/gnome/terminal/legacy/keybindings/ prev-tab '&lt;Primary&gt;&lt;Shift&gt;Tab'
</code></pre><p>参考: <a href=https://askubuntu.com/questions/133384/keyboard-shortcut-gnome-terminal-ctrl-tab-and-ctrl-shift-tab-in-12-04>https://askubuntu.com/questions/133384/keyboard-shortcut-gnome-terminal-ctrl-tab-and-ctrl-shift-tab-in-12-04</a></p><h3><a href=#capslock%e3%81%a7%e8%8b%b1%e6%95%b0%e5%a4%89%e6%8f%9b id=capslockで英数変換 class=anchor aria-hidden=true><code>capslock</code>で英数変換</a></h3><p><a href=https://github.com/k0kubun/xremap><code>xremap</code></a>や<a href=https://github.com/mooz/xkeysnail><code>xkeysnail</code></a>を使うどちらもそんなに使い心地は変わらないと思う。今は<code>xkeysnail</code>を使っている。</p><h3><a href=#xkeysnail%e3%82%92systemd%e3%81%ab%e8%b5%b7%e5%8b%95%e3%81%97%e3%81%a6%e3%82%82%e3%82%89%e3%81%86 id=xkeysnailをsystemdに起動してもらう class=anchor aria-hidden=true><code>xkeysnail</code>をsystemdに起動してもらう</a></h3><p>課題が2つある:</p><ul><li><code>xkeysnail</code>が<code>uinput</code>を必要とすること<ul><li><code>sudo</code>が必要とreadmeに書かれているのはこれが理由</li></ul></li><li><code>xkeysnail</code>をsystemdに登録すること<ul><li><code>sudo</code>つけられない/等価なことはできない？</li></ul></li></ul><p>以下のように解決する</p><ol><li>必要な権限を自分に与える<ol><li>sudoなしで<code>xkesynail</code>を実行できるようになる</li></ol></li><li>systemdに登録して、ログインくらいのタイミングで有効にする</li></ol><h4><a href=#%e6%a8%a9%e9%99%90%e3%82%92%e4%b8%8e%e3%81%88%e3%82%8b id=権限を与える class=anchor aria-hidden=true>権限を与える</a></h4><p>これの通りにやればよい: <a href=https://github.com/mooz/xkeysnail/issues/64#issuecomment-600380800>https://github.com/mooz/xkeysnail/issues/64#issuecomment-600380800</a></p><h4><a href=#systemd%e3%81%ab%e7%99%bb%e9%8c%b2%e3%81%99%e3%82%8b id=systemdに登録する class=anchor aria-hidden=true>systemdに登録する</a></h4><ol><li>設定ファイルを書く <a href=https://github.com/naoyafurudono/configs/blob/main/systemd/user/xkeysnail.service>https://github.com/naoyafurudono/configs/blob/main/systemd/user/xkeysnail.service</a></li><li><code>~/.config/systemd/user/</code>におく<ol><li>バイナリをおく: 上の例では<code>~/.local/bin</code>においてあることを想定している</li></ol></li><li>systemdに登録する: <code>systemctl --user enable --now xkeynail</code><ol><li><code>enable</code>で登録、<code>--now</code>で今実行</li></ol></li></ol><p>もしうごかなかったら<code>jounalctl -r</code>でsystemdのログをみる。</p><h3><a href=#%e8%b5%b7%e5%8b%95%e6%99%82%e3%81%abmozc%e3%81%ae%e6%97%a5%e6%9c%ac%e8%aa%9e%e5%85%a5%e5%8a%9b%e3%82%92%e6%9c%89%e5%8a%b9%e3%81%ab%e3%81%99%e3%82%8b id=起動時にmozcの日本語入力を有効にする class=anchor aria-hidden=true>起動時に<code>mozc</code>の日本語入力を有効にする</a></h3><p><a href=https://github.com/naoyafurudono/configs/blob/main/mozc/ibus_config.textproto>https://github.com/naoyafurudono/configs/blob/main/mozc/ibus_config.textproto</a>を<code>~/.config/mozc/</code>におく。</p><p>参考: <a href=https://blog.nfurudono.com/posts/mozc-default-engine/>https://blog.nfurudono.com/posts/mozc-default-engine/</a></p></p></div><div class=post-footer><p><a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/tool>#tool</a>
<a class=tag href=/%20tags/linux>#linux</a>
<a class=tag href=/%20tags/gnome>#gnome</a></p><p><time>2023-02-28 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/print-docs/>軽いドキュメントを印刷するためのツールが欲しい</a></h1><div><p><p>さくっと書いた文書を印刷したいことがある。ビジネスライクな手紙とか、その日のTODOリストなんかがそうだ。
LaTeXやMadokoを使うのは大げさな感じがして、諦めて手書きするか、Google Docsで済ませることが多い。とはいえ手紙の書き方を毎回調べたり、フォーマットを調整したり、PCで打ち込んだデータを手書きするのはつらい。</p><p>テンプレートと変数の宣言、UIの調整と文書のまともな処理をして印刷（A4）できるものが欲しい。A4のPDFに変換できればよい。それぞれの文書のソースはマークダウンのちょっとした拡張くらいの文法で書きたい。エディタで編集したいのでGoogle Docsとかはなしで。テンプレートの作成方法はテキストにこだわらない。いじりやすいと嬉しい。</p><p>問題が以下のように分割できるはず。</p><ul><li>テンプレート作成</li><li>ソースの文法<ul><li>Markdown拡張</li></ul></li><li>テンプレートへのソースの埋め込み</li><li>PDFへの変換</li></ul><p>HTML/CSSやlatexを勉強してMadokoでくっつければなんとかできる気はするが、大変そうだしあまり楽しくない。文書作成ツールを自作するか？とりあえず、HTML/CSSで手紙を表現できるようになるところから始めるのが良さそうか。自作マークダウン拡張（というより処理系）はまれに欲しくなるのでやっても良いだろう。Hugoもそんなに快適じゃないし、Madokoはいじりにくいので。</p><ul><li>自分でコードをいじりやすいこと</li><li>メタな文書処理がしやすいこと<ul><li>識別子や文書の変数への束縛、正規表現やCFGベースのテキスト置換など</li><li>この辺はMadokoが強い</li></ul></li><li>そういえばMadokoはPDFの生成でHTMLを使わずにlatexを使っていたな&mldr;</li></ul><p>ここまで来て、<a href=https://github.com/cognitom/paper-css>Paper CSS</a>という良さげなリポジトリを見つけた。
Qitaでこのライブラリを使って<a href=https://qiita.com/cognitom/items/d39d5f19054c8c8fd592>帳票を作る例が解説されている</a>。</p><p>まだそれぞれをあまり読んでいないのであとで確認する。このあたりの技術に合うように出力することにして、それを生成するマークダウンエンジンを用意すればok?</p><p>やはりしんどい気がする。GUIでなんとかする方法を探すのが楽だろうか。あらためて考えよう。</p><h3><a href=#%e8%bf%bd%e8%a8%98-google-docs-api id=追記-google-docs-api class=anchor aria-hidden=true>追記: Google Docs API</a></h3><p><a href="https://developers.google.com/docs/api/reference/rest?hl=ja">Google Docs API</a>を利用するのはどうだろうか。
APIはあまりリッチではなくて、create, update, pullができるのみ。文書構造の編集はJSONをごりごりいじることで実現する。<a href="https://developers.google.com/docs/api/reference/rest/v1/documents?hl=ja">JSONスキーマが定義されている</a>ので、これを見ながら必要な変換を定義すればよい。</p><p>テンプレートをGoogle DocsのGUIで作成して、それをAPIでpullした上で、コンテンツを注入したドキュメントをcreateすれば、やりたかったことを実現できそうだ。テンプレートの置き換え箇所の指定方法はどうするのが良いだろうか。</p><p><code>(開始記号)名前(引数リスト)(終了記号)</code>を文書に埋め込む。これがひとかたまりの文書オブジェクトとして認識されることが必要。また、これにスタイリングを適用した場合、埋め込み後もそのスタイリングが保たれるようにする。引数に他の名前が出現しうることに注意する</p><p>テンプレに埋め込むテキストを定義する側では、埋め込み内容の定義リストを作成する:</p><pre><code class=language-python>def name(args: list[str]) -&gt; str:
  return f&quot;&quot;&quot;\
ここに置換後の文字列を書く。
ここにも埋め込みの出現を許す。
&quot;&quot;&quot;
</code></pre><p>埋め込み処理では、JSON形式のテンプレのすべてのテキストについてマクロ展開をすればよい。</p><h3><a href=#%e8%bf%bd%e8%a8%98-web%e6%8a%80%e8%a1%93%e3%81%a7%e6%9c%ac%e3%81%8c%e4%bd%9c%e3%82%8c%e3%82%8b- id=追記-web技術で本が作れる- class=anchor aria-hidden=true>追記: Web技術で「本」が作れる &mldr;</a></h3><p>リブロワークスからCSSで組版するノウハウをまとめた本が<a href="https://libroworks.co.jp/?p=6956">5/12に出るらしい</a>。途中までを<a href="https://libroworks.co.jp/csskumihan/viewer/#src=/csskumihan/0_frontmatter.html&amp;f=epubcfi%28/4!%29">オフィシャルが公開している</a>。
Vivliostyleというソフトを使って、MarkdownとCSSで書籍を作るらしい。その手のソフトは他にもあるようで、<a href=https://print-css.rocks/lessons>比較サイト</a>を先の書籍で紹介されていた。</p><p>こう思うとmadokoはだいぶ良いものだなと感じる。適用範囲を限定した置換とlatexはなかなか強い。
latexとcssを完全に理解すればmadokoが最高かもしれない。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/idea>#idea</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-02-24 +0900</time>
lastmod: <time>2023-04-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/my-pc/>PCの構成メモ</a></h1><div><p><p>PCを自作して使っているのだけど、どんなパーツを使ったか忘れて後でなにか買い足すときに互換性があるかわからなくてこまる。今回調査してメモしておく。</p><ul><li>CPU: Core i5 12400</li><li>マザーボード: GIGABYTE B660M DS3H AX DDR4 [Rev.1.x]</li><li>RAM: <a href=https://amzn.to/3ZdyVLF>DDR4-3200 (2933・2666対応) (PC4-25600) W4U3200CM-8GR</a></li><li>SSD: WDS500G3X0E<ul><li>M.2 NVMe 内蔵SSD / 500GB / PCIe Gen4x4 / WD BLACK SN770 NVMe SSDシリーズ</li></ul></li><li>ケース: <a href=https://amzn.to/3ZxnLlp>Thermaltake Versa H17 ミニタワー型PCケース CS7096 CA-1J1-00S1NN-00</a></li><li>電源: <a href=https://amzn.to/3Z0HhXp>XPG PYLON パイロン 450W PC電源ユニット [ 80PLUS Bronze認証取得 ] PYLON450B-BKCJP</a></li></ul><p>Ubuntuを入れて使っているけど特に不満はない。不満はないのだが、この間Gentooのことを教えてもらって面白そうなので使ってみようと思っている。</p><p>余談だが、このPCは親に就活で必要だろうからといって渡してもらったお金で組んだのだった。自由に使えと言ってもらったが、きっとスーツとかを想定していたのだろう。幸いなことにスーツは買わずに済んでいるので（兄のお下がりがまだ着れる）、ずっと気になっていた自作PCに手を出すのに使ったのだった。少し後ろめたい気持ちがないでもなかったが、Linuxとか触るの楽しいことが分かって仕事でもこの手のものを触りたいと思えたし、面接の話のネタにもなったので結果オーライだろう。学校とか本で学ぶOS周りの技術をそのまま試せるのが僕には嬉しかったのだろう。Windowsでは厳しいし、Macもどこか違っているので。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/tech>#tech</a>
<a class=tag href=/%20tags/ubuntu>#ubuntu</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-02-23 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/tips-for-tagging/>HugoでタグをつけるためのTips</a></h1><div><p><p>車輪の再発明ではあるだろうけどメモしておく。<code>archetypes/</code>に<code>hugo new</code>で生成する<code>.md</code>ファイルのテンプレを置くことができる。そこにありうるすべてのタグを書いておけば、記事を書くときに関係ないタグを消すことで、関連するタグを忘れずにつけることができる。</p><p>僕は以下のようにフロントマターを設定している。</p><pre><code>---
title: &quot;TODO&quot;
date: {{ .Date }}
author: &quot;Naoya Furudono&quot;
draft: true
tags: [
    &quot;daily&quot;
    ,&quot;PL&quot;
    ,&quot;tech&quot;
    ,&quot;ubuntu&quot;
    ,&quot;alexa&quot;
    ,&quot;book&quot;
    ,&quot;idea&quot;
    ,&quot;python&quot;
    ,&quot;tool&quot;
]
---
</code></pre></p></div><div class=post-footer><p><a class=tag href=/%20tags/idea>#idea</a>
<a class=tag href=/%20tags/tool>#tool</a></p><p><time>2023-02-16 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/fav-pl-article/>好きなPL本</a></h1><div><p><p>プログラミング言語を勉強するとイディオムとかその言語界隈でのベストプラクティスが学べて良い、みたいなことが巷でよく言われる。確かにそれはそのとおりだとぼくも感じるのだが、雑にチュートリアルをこなしたりするだけでは言語をよく学べないだろうと思うし、良い情報源を見つけることはそんなに簡単ではないと感じている。</p><p>僕がこれまで呼んだPL系の本でこれはと思ったものがいくつかあるので紹介する。
(注意: 好奇心でアフィリエイトを試しています。アマゾンへのリンクはアフィリエイトを有効にしています。)</p><ul><li>C言語: <a href=https://amzn.to/3E9NSqi>The C Programming Language</a><ul><li><a href=https://www.sigbus.info/compilerbook>低レイヤを知りたい人のためのCコンパイラ作成入門</a> も面白い</li></ul></li><li>Go言語: <a href=https://amzn.to/3lBC21x>プログラミング言語Go</a></li><li>OCaml: <a href=https://amzn.to/3xIzdPf>Real World OCaml: Functional Programming for the Masses</a><ul><li><a href=https://dev.realworldocaml.org/toc.html>ここで公式が無料でHTML版</a>を公開している。</li></ul></li><li>Python: <a href=https://google.github.io/styleguide/pyguide.html>Google Python Style Guide</a><ul><li>Python以外の言語についても<a href=https://google.github.io/styleguide/>スタイルガイドがある</a></li></ul></li></ul><p>どれも勉強になる。文化の共通部分と異なる部分があって楽しい。共通部分はプログラミング全般で大切なのだろうと思うし、異なる部分は言語の活かし方なのだろうと思う。</p><p>そういえばこういう本を読んだときと、良いPLの論文を読んだときでは感想が異なる。
PLの論文はすごいアイデアを中心として、周辺の概念がうまく回っていく様を見せつけられると感動するのだが、この手の本はもっといろんな機能や習慣がうまく組み合わさる様を見せつけてくれる。甲乙つくものではないだろう。</p><p>ちなみに、いま述べた類の感動を与えてくれたのはこれら2つがぱっと思いついた:</p><ul><li><a href=https://www.microsoft.com/en-us/research/publication/generalized-evidence-passing-for-effect-handlers/>Generalized Evidence Passing for Effect Handlers</a></li><li><a href=https://www.jot.fm/issues/issue_2022_02/article2.pdf>Implementation Strategies for Mutable Value Semantics (pdf)</a></li></ul><p>1つ目は背景知識がたくさんいる気がするので人にはおすすめしない。
2つめは必要な背景知識が少なめなはず。</p><p>このように整理すると、local reasoningがPL意味論で大切にしたい中心的な概念に思える。本当だろうか。</p></p></div><div class=post-footer><p><time>2023-02-16 +0900</time>
lastmod: <time>2023-07-08 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/python-generator/>Pythonのジェネレータをyieldで書く例</a></h1><div><p><p>Pythonのジェネレータ（というより<code>yield</code>）の挙動を示す例を書いた。二分木を作る<code>gen</code>と、ノードを探索してその内容を表す文字列を返すジェネレータを返す<code>conv</code>を定義した。<code>conv</code>がこういう風に定義できることを例で確認したかった。</p><pre><code class=language-python>from dataclasses import dataclass
import itertools
import random
from typing import Generator


@dataclass
class Tree:
    value: str


@dataclass
class Node(Tree):
    children: list[Tree]


@dataclass
class Leaf(Tree):
    pass


def gen(n):
    msg = f&quot;{random.randbytes(1)}&quot;
    if n &lt;= 0:
        return Leaf(msg)
    else:
        return Node(msg, [gen(n - 1), gen(n - 2)])


def conv(t: Tree) -&gt; Generator[str, None, None]:
    if isinstance(t, Leaf):
        yield f&quot;Leaf: {t.value}&quot;
    elif isinstance(t, Node):
        for i in itertools.chain(*map(conv, t.children)):
            yield i
        yield f&quot;Node: {t.value}&quot;


if __name__ == &quot;__main__&quot;:
    import pprint as pp

    t = gen(3)
    pp.pprint(t)
    for i in conv(t):
        print(i)
</code></pre></p></div><div class=post-footer><p><a class=tag href=/%20tags/python>#python</a></p><p><time>2023-01-06 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/2023-todo/>2023年にやりたいこと</a></h1><div><p><p>来年の抱負じゃないけど、一息ついたタイミングでやりたいことを整理しておくとどこかのタイミングで役に立つかもしれない。</p><h2><a href=#%e4%bb%8a%e5%b9%b4%e3%81%ae%e3%81%be%e3%81%a8%e3%82%81 id=今年のまとめ class=anchor aria-hidden=true>今年のまとめ</a></h2><p>今年は人生で一番プログラミングした気がする。
3月の末にmerpayで短期のインターンに参加したのを皮切りに、
4月にキャディでのアルバイトをはじめるなど、プログラミングをする機会が増えた一年だった。研究でもインタプリタをゴリゴリ書いてみるなどした。最近は講義で簡単な定理証明支援系の実装に挑戦している。変わり種としては、IBMの方々が講師として開催されているJVM関連のコンパイラ/VMの講義にも参加している。</p><p>型システムつきの言語ばかり触っていては視野が狭くなってつまらないだろうと思って意識的にPythonやJS/TS、Racketを使ってみるようにしていた。ライブラリをつなぎ合わせるくらいなら不便がなくてよいのだが、ある程度込み入ってきて、一つのデータ構造を複数のコンポーネントから使うようになると型システムが欲しくなる。クラスや契約である程度カバーできる面はあるが、型システムにまもってもらう安心感は得られない。抽象化をしきれないというか、しても心のどこかで実装を意識しながらデバッグしたりすることになるし、そもそも抽象化を書きにくかったりする。</p><p>なんにしてもプログラムをゴリゴリ書く能力はついたと思う。今年はとにかく動くものを作る系のコーディング技術を身につけた一年だった。年の最後にPythonで言語処理系を実装するとき、クラスを使わずdictとlistだけでどこまでいけるかやってみたのだが、型システム（依存型を含むので、いわゆるeval的な処理も必要）の実装で力尽きた。その経験からやはり型は必要だと思い直したのであった。
dataclassを使って一日かけて書き直したらまともに実装できたので感動している。もはやC++とかで書いた方がいい気がするが。</p><p>3月くらいまではあまり実装をする人ではなかった。実装に手を出し始めたのは最近の話。プログラミング言語の理論（型システムとか抽象機械とか意味論とか）ばかり見ていて論文やドキュメントを読むのが何より楽しいと思う人だった。論文を書く中で言語の使い手の気持ちがあまりわからなくなったり、論文を読んでいても、プログラマの幸せにつながる未来を想像できない研究をみたりした。</p><p>プログラミング言語や処理系はプログラムや表現したい対象があって初めて良し悪しが見えてくるものだと思う。そういうプログラミング言語の研究の動機の部分をもっと知りたくて実装に手を出してみた。結果は上々で、今の僕は去年よりもプログラミング言語やプログラミングのことが好きな自信があるし、そういう話をして楽しい人間に近づけたと思う。丸くなってしまいはしたかもしれないが。</p><h2><a href=#2023%e5%b9%b4%e3%81%ae%e8%a9%b1 id=2023年の話 class=anchor aria-hidden=true>2023年の話</a></h2><p>インフラっぽいことを型システムやコンパイラの表現力/処理でまっとうに行いやすいようなしくみを考えて、実現に向けた方針くらいを打ち立てたい。インフラの勉強とRust, Scala, Haskell（適切なものを一つ）の業務で自在に使えるくらいの知識が必要だろう。</p><p>DSLやconfigでインフラ/ミドルウェアを構成するのが最近流行っているようだが、そういうのを勉強するのはつらい。あまり長持ちする技術ではないだろうし、知識としての深みも出にくそうな印象をうける。ライブラリとして提供してもらって他の便利機能はプログラミング言語に移譲するのがよいだろう。適切な言語であれば、ライブラリ特有の問題を言語の機能で扱いやすくできるはずだ。僕がやりたいのは、そのやさしく扱いやすくする部分。</p><p>その他にも全然知らない世界（技術的）をみたいし、文化的な面でも知らないところに飛び込むつもりだ。今年はそういうことをしやすい一年だと思う。楽しい一年になりそうだ。</p><p>まずは修士の研究をやろう。</p></p></div><div class=post-footer><p><time>2022-12-29 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/replace-with-git-grep/>git grep で検索して置換</a></h1><div><p><p><code>git grep</code>は便利なのだが、置換の機能がない。ぐぐると<code>sed</code>と組み合わせて置換する方法がたくさんでてくる。スクリプトファイルに書き込んだのでメモしておく。</p><ul><li>POSIX準拠の正規表現を使える。</li><li>第２引数（置換後の文字列）ではマッチグループを参照できる。（<code>"\1にマッチした"</code>のように書く）</li></ul><pre><code class=language-rep.sh>#!/bin/bash

if [ $# -ne 2 ]; then
  echo &quot;Arity mismatch. want: 2, actual: $#&quot; 1&gt;&amp;2
  exit 1
fi

git grep -lE &quot;$1&quot; | xargs sed -i -E &quot;s/$1/$2/g&quot;
</code></pre><p>個人メモ：<code>~/.local/bin</code>に置いてある。</p><p>rg版はこちら</p><pre><code class=language-rep>#!/bin/bash

if [ $# -ne 2 ]; then
  echo &quot;Arity mismatch. want: 2, actual: $#&quot; 1&gt;&amp;2
  exit 1
fi

rg -l &quot;$1&quot; | xargs sed -i -E &quot;s/$1/$2/g&quot;
</code></pre></p></div><div class=post-footer><p><time>2022-12-18 +0900</time>
lastmod: <time>2025-01-18 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/memo-concurrency-in-go/>読書メモ: Go言語による並行処理</a></h1><div><p><p>ちゃんと読もうと思ったときのための自分向けのメモ。</p><ul><li>プログラミング技法を学びたいなら3,4章</li><li>Golangの復習をしたいなら3章</li><li>Golangのランタイムを覗きたいなら6章を読むと良さそう。</li></ul><p>ざっと見た感じ、だいぶ信用して良さそうに思える。積極的に読んでいこう。</p></p></div><div class=post-footer><p><time>2022-11-25 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/disable-hugo-pagination/>Hugoでページネーションを無効化</a></h1><div><p><p><a href=https://github.com/naoyafurudono/naoyafurudono.github.io/commit/103975b47aba0b12b6b3fb5ff71caf04b591381d>このコミット</a>
でトップページのページネーションを無効化した。やったことは以下の通り。</p><ul><li><code>.Pagenator</code>を使わないようにする</li><li>対象のポストを全件表示するようにする</li><li>ページネータを消す</li></ul><p>最初の一つが<code>page/2/</code>みたいなページ生成を抑止して、次の２つがトップページの見た目を変える。ページネータを消せば自然に<code>.Pagenator</code>を使わないようになるはずだ。</p><h2><a href=#%e5%8f%82%e8%80%83%e3%83%89%e3%82%ad%e3%83%a5%e3%83%a1%e3%83%b3%e3%83%88 id=参考ドキュメント class=anchor aria-hidden=true>参考ドキュメント</a></h2><ul><li><a href=https://gohugo.io/templates/pagination/#configure-pagination>Hugoは<code>.Pagenator</code>の使用をみつけると、<code>page/2/</code>みたいなページを生成する</a></li></ul></p></div><div class=post-footer><p><time>2022-11-24 +0900</time>
lastmod: <time>2024-12-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/church-encoded-list-in-js/>Church Encoded List in JS</a></h1><div><p><p>Charch encodingで書いたリストの動くものがほしかったので書き下した。<code>isnil</code>を実現するためにコンスを<code>isnil</code>、<code>car</code>、<code>cdr</code>からなるペアとして表現した。</p><pre><code class=language-javascript>// cons list in Church encoding

const tr = t =&gt; f =&gt; t;
const fl = t =&gt; f =&gt; f;
const ite = c =&gt; t =&gt; f =&gt; c(t)(f);

const pair = f =&gt; s =&gt; pi =&gt; pi(f)(s);
const fst = p =&gt; p(f=&gt;s=&gt;f);
const snd = p =&gt; p(f=&gt;s=&gt;s);

const nil = pair(tr)(0);
const cons = x =&gt; xs =&gt; pair(fl)(pair(x)(xs));
const car = l =&gt; fst(snd(l));
const cdr = l =&gt; snd(snd(l));
const isnil = l =&gt; fst(l);

const fix = f =&gt; (x =&gt; f(y =&gt; x(x)(y)))((x =&gt; f(y =&gt; x(x)(y))));

const foldr = fix(folD =&gt; f =&gt; init =&gt; l =&gt; (ite (isnil(l)) (() =&gt; init) (() =&gt; f(car(l))(folD(f)(b)(cdr(l)))) ) ());

const len = l =&gt; foldr(elm =&gt; b =&gt; 1+b)(0)(l);
const len2 = fix(leN =&gt; l =&gt; (ite(isnil(l))( () =&gt; 0)( () =&gt; 1 + leN(cdr(l)) ))() );

const lst = cons(1)(cons(2)(nil));
len(lst); // -&gt; 2
</code></pre></p></div><div class=post-footer><p><time>2022-10-28 +0900</time>
lastmod: <time>2022-11-03 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/mozc-default-engine/>Mozc のデフォルトエンジンを設定する方法 2022 Oct</a></h1><div><p><p>設定ファイルを書き換えるとmozcのデフォルトを日本語入力にできる。
Ubuntu22.10でしか試していないことに注意。</p><pre><code>$ cat ~/.config/mozc/ibus_config.textproto
engines {
  name : &quot;mozc-jp&quot;
  longname : &quot;Mozc&quot;
  layout : &quot;default&quot;
}
active_on_launch: True
</code></pre><h2><a href=#%e7%92%b0%e5%a2%83 id=環境 class=anchor aria-hidden=true>環境</a></h2><pre><code>Distributor ID:	Ubuntu
Description:	Ubuntu 22.10
Release:	22.10
Codename:	kinetic
</code></pre><h2><a href=#%e9%95%b7%e3%81%84%e8%aa%ac%e6%98%8e id=長い説明 class=anchor aria-hidden=true>長い説明</a></h2><p>Ubuntuで日本語をmozc、ローマ字を元から入っているUSのなにかで入力している。このやり方のありがちな課題として、mozcのデフォルトが直接入力になっていることがある。安直に対処するなら、ubuntuにログインするたびGUIでmozcの切り替えを行えばよいが、毎回操作するのは面倒だ。デフォルトで日本語モードにすれば良くて、その実現方法を冒頭に載せた。</p><p>今年追加されたデフォルトエンジンを指定するオプションを用いて日本語入力をデフォルトにしている。環境によっては設定ファイルを置くべきディレクトリが違うとか、既存の設定とマージする必要があるみたいなことはあるかもしれない。</p><h3><a href=#%e5%8f%82%e8%80%83 id=参考 class=anchor aria-hidden=true>参考</a></h3><ul><li><a href=https://github.com/google/mozc/issues/381>この件のIssue</a><ul><li>多くの人が困っていたみたいだ。</li></ul></li><li><a href=https://github.com/google/mozc/blob/master/docs/configurations.md#activate-mozc-on-launch>設定ファイルの説明</a></li></ul></p></div><div class=post-footer><p><time>2022-10-28 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/learn-apt/>aptのドキュメント整理</a></h1><div><p><p>雰囲気でaptを使っていて、リポジトリ周りの扱いに困ることがある。この手のツールは一生使うだろうから勉強して損はないだろう。この記事には読んだドキュメントと一言コメントを残しておく。</p><ul><li><a href=https://manpages.ubuntu.com/manpages/bionic/ja/man8/apt.8.html>apt(man)</a><ul><li>意図的に情報を絞っているとのこと。数分で読み切れる。</li><li>ざっくりと概念をつかめた気がする。</li><li>次の課題はリポジトリ</li></ul></li><li><a href=https://manpages.ubuntu.com/manpages/bionic/ja/man5/sources.list.5.html>sources.list(man)</a><ul><li>リポジトリのリスト。aptが参照/手入れする。こういう名前のファイルがあるし、似たようなディレクトリもある。それらの総称として<code>sources.list</code>と呼んでいる節がありそう。</li><li><a href=https://kujira16.hateblo.jp/entry/2019/10/14/190008>くじらにっき++</a>がやさしい</li></ul></li></ul><p>これでざっくりわかった。次にセキュリティのことを調べる。というのも、aptが失敗するのはセキュリティ周りの設定がうまくいっていないことが原因なことが多く感じるから。</p><ul><li><a href=https://manpages.ubuntu.com/manpages/kinetic/ja/man8/apt-secure.8.html>apt-secure(man)</a><ul><li>ここで、apt-keyで鍵を登録すると書かれているが、この方法は非推奨になっている（<a href=https://manpages.ubuntu.com/manpages/kinetic/en/man8/apt-key.8.html>apt-key</a>）。<ul><li><a href=https://gihyo.jp/admin/serial/01/ubuntu-recipe/0675>gihyoに解説記事</a>がある</li><li>代替ツールはなくて、manでは直接ディレクトリに鍵ファイルを放り込むことが推奨されている。</li></ul></li></ul></li></ul><p>トラブルが起こったらこのあたりをいじればよさそうだ。
apt経由でインストールする際のおまじないの意味もわかるようになった。確かSlackをaptでインストールした際にリポジトリや鍵を追加したはずなのだが、当時はよくわかっていなかった。</p></p></div><div class=post-footer><p><time>2022-10-22 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/effect-handlers-dependency-injection/>エフェクトハンドラと依存性注入の関係について調べる （文献調査）</a></h1><div><p><p>僕はエフェクトハンドラについてそれなりに理解していると思う。一方で依存性注入についてはふわっとしか知らない。</p><p>そんな状態ではあるけれど、エフェクトハンドラは関数型プログラミングで依存性注入するための素直な表現に使えるのではないかと感じている。</p><p>このポストではネットやアカデミアでどんな議論がありそうかをざっと眺める。それらの議論の細かいところとか、考察とかは明日以降の意識がはっきりしているときに扱う。</p><h2><a href=#%e3%82%b5%e3%83%bc%e3%83%99%e3%82%a4 id=サーベイ class=anchor aria-hidden=true>サーベイ</a></h2><p>同じことを思ったひとはいるようで、検索すると<a href=https://danidiaz.medium.com/free-monads-and-effect-handlers-vs-dependency-injection-bca2eb95e580>2017年のブログ記事</a>がヒットした。<a href="https://news.ycombinator.com/item?id=20513108">Hacker Newsのスレ</a>で <code>chowells</code>
と <code>kybernetikos</code> が同様の議論をしている。これは2019年のこと。</p><p><a href=https://www.microsoft.com/en-us/research/publication/programming-with-implicit-values-functions-and-control-or-implicit-functions-dynamic-binding-with-lexical-scoping/>Jonathan Brachthauser と Daan Leijenの論文</a>。</p><p>エフェクトハンドラの使い方を調べるなら、モナドの使い方を調べるほうが早い気はする。そう思って調べると<a href=https://qiita.com/lotz/items/a903d3b2aec0c1d4f3ce#full_moon-extensible-effects>良さげなQiitaの記事をみつけた</a>。</p><p>まだ列挙したドキュメントをあまり読めていないので、当初知りたかった関係についてはまだよくわかっていない。でも何かしら関係あることは間違いなさそうだし、僕の直感もそんなに的外れではなさそうに思える。明日起きたら読む。</p></p></div><div class=post-footer><p><time>2022-10-14 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/ta-command/>Linuxコマンドがわからない学部生について</a></h1><div><p><p>学部生や教育を非難したり愚痴を言ったりするつもりはない。</p><p>情報系の学部2年生向けのプログラミングの講義でTAをやっている。
Linuxコマンド（ <code>cd</code> とか <code>ls</code> 、 <code>git</code> など）を知らないとか、ディレクトリやパスなどの周辺の概念を知らない学生が少なくないように感じる。</p><p>講義で教える類のものではないのだろうけど、学生は真面目に講義を受けていればマスターできると想像して自律的に学ばないから僕が観測したような状況が生まれたのかなと想像する。というか、昔の僕がそうだった。</p><p>ああいう概念を身につけるためにはターミナルをたくさん使うのが推奨されがちな気がするが、卵・ニワトリ論争というか、エアーマンが倒せない理論と同じことが起きる気がする。なので個人的には適切な入門書を読むことを勧めたい。今回のLiniuxコマンドや周辺の概念は<a href=https://www.sbcr.jp/product/4797380941/>新しいLinuxの教科書</a>に多くを学んだ。学部生たちにもこれを勧めてしまって大丈夫だろうか。</p></p></div><div class=post-footer><p><time>2022-10-12 +0900</time>
lastmod: <time>2022-10-15 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/moving/>格安の引越し業者が良かった</a></h1><div><p><p>今日引越しをした。
1年半くらい住んだ家から学校の近くへ引越した。動機は学校がオフラインになったから。告知から実行までが短くて困った。
2週間後から週4で対面参加せよと言われて強引だなあという気持ち。なんにせよ、この状況では学校の近くに住むのが有利なので引っ越すことにしたのだ。新居はそれなりにいい感じで、部屋も十分広いし町もよいところに感じた。不満は坂があることと、水回りの設備に伸びしろがあること。</p><p>新居の話はこれくらいにして、本題の引越し業者の話をしよう。大学入学から数えて、今回の引越しは3回目か4回目なのだが業者を手配したのは初めてだった。これまではヤマト運輸の単身パックや家財配送便？などを利用しつつ、気合や周囲の優しさで引越しをこなしてきた。たとえば洗濯機だけは業者に任せて、あとのものはリュックに入れたり現地で買うなど。他にはトラックを借りて荷物を運んだりもした。</p><p>今回業者にお願いしたのは単にコストパフォーマンスが良さそうなことに気がついたから。支払った金額は22,120円なので、軽トラを借りて友達にバイト代を払うとトントンになりそうだ。業者にお願いすれば僕は疲れない上に時間も短く済む。そして結果論ではあるが業者の方は丁寧な作業をしてくれた。ほんとにあの額で良かったのだろうかという気がしてくる。あの人たちはどれだけの報酬をもらえているのだろうか。まとめると、金銭的には同等のコストがかかり、時間的には業者に依頼するのが有利、得られる結果も依頼するほうが良さげ。依頼するしかないだろう。</p><h2><a href=#%e8%80%83%e5%af%9f id=考察 class=anchor aria-hidden=true>考察</a></h2><p>特に安く抑えられたことが効いている。時期と依頼先が良かったのだろう。今回はよい行動ができたと思う。勝因は勢いとコミュニケーションだと思う。引越しのような行動は勢いがあれば8割くらい（10割がどんなか知らないが）のクオリティを達成できる気がする。ある程度の予備調査は必要だけど、勢いを殺さない範囲の調査で十分なはず。プラス2割を得ようとすると話が込み入ってくる印象だ。今回行った調査は以下の要領で行った：</p><ul><li>SEO対策が効いてる系の記事で引越し業者選びの雰囲気を掴む</li><li>相見積もりサイトで業者の候補を得る （５社程度）</li><li>業者に直接問い合わせる （２社）</li></ul><p>もっとよい選択はあったと思うのだけれど、話が込み入りそうだったのでこれくらいで打ち切った。これが8割の行動だと思っている。お金の使い方や事務処理を学んだ気がする。学びを活かしていこう。</p></p></div><div class=post-footer><p><time>2022-10-12 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/wishlist/>Wishlist</a></h1><div><p><p>欲しい / つくりたいソフトウェアのリスト。随時更新していく。</p><ul><li>マークダウンフォーマッタ<ul><li>全角文字にうまく対応したり、Madokoのシンタックスを理解したりしてほしい。</li></ul></li></ul></p></div><div class=post-footer><p><time>2022-09-30 +0900</time>
lastmod: <time>2022-10-15 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/syncthing/>Syncthingがよさげ</a></h1><div><p><p>オープンソースのソフトウェアで<a href=https://docs.syncthing.net/intro/getting-started.html>Syncthing</a>
というものを知った。
LAN内のデバイスとはLAN内で、インターネットの先にいるデバイスとはインターネット越しにファイルを同期できるソフトウェアだ。予めクライアントをインストールして、ディレクトリごとに共有設定をしておくと、設定に応じてよしなにファイルを同期してくれる。</p><p>USBのような手軽さはないが、クラウドストレージ越しにファイルのやりとりをするよりは便利そうだ。
UbuntuとAndroidにクライアントを入れてつかってみているのだけど、今の所いいかんじ。学校のネットワークではP2P通信を禁止している。おそらくSyncthingも引っかかるので、学校のネットワークでは動作しないように設定しておく。</p><p>設定は公式に従ってもよいし、<a href=https://virment.com/how-to-use-syncthing-for-syncing-local-files/>このブログポスト</a>も参考になる。詳しいことは<a href=https://wiki.archlinux.jp/index.php/Syncthing>ArchWiki</a>が頼りになりそう。</p></p></div><div class=post-footer><p><time>2022-09-28 +0900</time>
lastmod: <time>2022-10-15 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/otoshibuta/>落し蓋</a></h1><div><p><p>ひじきの煮物をつくったのだけど、あまり上手にできなかった。その原因をさぐりたい。</p><p>まず、ひじきの量に対して他の具材を入れすぎた。ひじきが主役っぽくなくなってしまった感じ。次に味が結構こくなってしまった。これは煮物という感覚を持たなかったことが敗因だろう。水を入れずに醤油、みりん、めんつゆだけでなんとかしようとして濃くなったの思う。途中で水を追加したけど、味は変わるわけではなく&mldr;。とはいえ、食感はおいしかった。</p><p>落し蓋をしなかったことも影響しているのだろうか。落し蓋の効果はいろいろあるようだけど、水分の蒸発を防いだり煮汁の対流を促進して味を均等にする効果があるらしい。</p><p>ひじきの煮物が苦手というより、煮物を作るための基礎的な知識が不足している気がしてきた。煮物は漸進的に調理するのが難しい気がする。スープなら具材の火の通りやすさを加味して順序を決めれば、あとは味見をしつつ味付けすることでおいしくなる。カレーとか味噌汁とかはこのあたりだと思う。肉やさかなを焼くときは、下処理と焼く面に気を使えば大体満足できるものが作れる印象がある。火が通ってなかったらそこだけ焼き直せばいいし。サラダはいわずもがなだし。これらに対して煮物は水分のコントロールが難しい。具材、調味料の水分をうまく扱わないといけないので。なんというか、すべての材料のバランスを調理前に決定しておかないといけないイメージがある。</p><p>料理のさしすせそも煮物に関するtipsなのか？</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/cock>#cock</a></p><p><time>2022-09-19 +0900</time>
lastmod: <time>2023-02-16 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/sakurai-youtube-channel/>「桜井政博のゲーム作るには」がおもしろい</a></h1><div><p><p><a href=https://www.youtube.com/c/sora_sakurai_jp>桜井政博のゲーム作るには</a> というYouTubeチャンネルが面白い。ゲームの仕組みに関する知識を説明してくれる。動画のクオリティがすごいし、何より内容が面白い。</p><p>桜井さんが語っているyoutubeラジオ?があった。明日聞いてみよう。<a href="https://www.youtube.com/watch?v=gdJZNN4aJ5U">ものをつくるときに気をつけていること／ゲームクリエイター 桜井政博さん 第１回「ユーザーの身になる」</a>
を初回として、第４回まであるようだ。一回20minちょっとくらい。</p></p></div><div class=post-footer><p><time>2022-09-11 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/daily-note-watch-battery/>Daily Note: 腕時計の電池交換</a></h1><div><p><p>コロナが流行ってから外出する機会が減りそれにともない腕時計をつけることも減った。今度腕時計が必要な用事があるのだけど、電池が切れていたので交換してもらってきた。
1320円かかって、15分ほどで対応してもらえた。電池を買うと500-600円くらいかかるだろうし、工具代はもっとするだろう。作業としては簡単な気がするが、この値段でやってもらえるのはありがたい話だ。この時計の電池交換を何回することになるかはわからないが、それ以外に使いみちのない工具をさがしたり、管理する手間を考えれば安いものである。良い価格設定をしてくれている感じがして、あの時計屋さんを好きになってしまったかもしれない。</p></p></div><div class=post-footer><p><time>2022-09-11 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/ubuntu-screenshot/>Ubuntu22でスクリーンショットの保存先を変える方法</a></h1><div><p><p>Ubuntu22でデフォルトのスクリーンショットアプリはおしゃれな見た目をしていてかっこいいのだが、保存先を変える設定が見当たらなくて困っていた。デフォルトでは <code>~/Picture/スクリーンショット/</code> に保存されるのだが、<code>~/Desktop/</code> に保存されてほしいのだ。</p><p><a href=https://askubuntu.com/questions/1408611/changing-the-auto-save-directory-for-screen-shots-and-screen-cast-in-ubuntu-22-0>StackExchange</a>に回答があった。回答によると、やはり残念ながらユーザによる設定はできないようで、シンボリックリンクを張る手法が提案されていた。僕もそれに倣ったら具合が良いのでリンクをメモしておく。</p><p>別の解決方法として、<a href=https://askubuntu.com/questions/1403994/how-to-change-the-default-screenshot-folder-in-gnome-42/1428765#1428765><code>gnome-schreenshot</code> をインストールして使う方法</a>
もあるようだ。しっかり読んでいないのだが、やることが多くて面倒にみえる。</p></p></div><div class=post-footer><p><time>2022-09-11 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/todo-app/>Todo Appを作っている話</a></h1><div><p><p><strong>この記事は書きかけです。</strong></p><p>Todoアプリを作っている。就活の際に Webアプリの開発経験に関する話をするときの題材が欲しかったから。</p><p>GitHub: <a href=https://github.com/naoyafurudono/todo-app>https://github.com/naoyafurudono/todo-app</a></p><h2><a href=#%e3%83%a2%e3%83%81%e3%83%99%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3 id=モチベーション class=anchor aria-hidden=true>モチベーション</a></h2><p>Todoアプリを選んだのは、この手の目的でよく作られているイメージがあるから。FizzBazzみたいな？
見た目だけ整えてもつまらないだろうし、コマンドラインだけで完結するようなものならSQLで良い。作るからにはなにか自分にとって得るものやソフトウェアとして売りになる点が欲しい。</p><h2><a href=#%e6%8a%80%e8%a1%93%e3%81%ae%e8%a9%b1 id=技術の話 class=anchor aria-hidden=true>技術の話</a></h2><p>細かいことはreadmeにしっかり書いている。しっかり書いたことも頑張りの一つ。ソフトウェア設計のためのツールを勉強できた。この記事では技術を選んだ理由や学んだことを書く。</p><h3><a href=#%e3%83%95%e3%83%ad%e3%83%b3%e3%83%88 id=フロント class=anchor aria-hidden=true>フロント</a></h3><p>フロントはTypeScriptとReactを用いた。</p><h4><a href=#typescript%e3%81%ab%e9%96%a2%e3%81%97%e3%81%a6 id=typescriptに関して class=anchor aria-hidden=true>TypeScriptに関して</a></h4><p>JSではなくTSを使ったのは、僕が常々型がほしいと思っていて、仕事でも型を大事にしたプログラミングをしたいから。
TypeScriptはほとんど初めて書いた。型システム（といってよいのだろうか）にはクセがあるが、型システムがいてくれてよかったと思う機会が何度かあった。これが静的型付言語を用いたプログラミング体験で最良だとは思わないけど、なかなか良かった。</p><p>良かった:</p><ul><li>型としての文字列リテラル</li><li>ユニオン型</li><li>JSONとの連携</li></ul><p>enumというか、代数的データ型っぽくオブジェクトを使える。網羅性検査やコード補完もしっかり効いて快適だった。これはTSの特権だと思うのだが、JSONとの親和性がすごく良かった。</p><p>良くない:</p><ul><li>関数の型を書きにくい</li><li>ライブラリ関数の型が調べにくい、使いにくい</li><li>型推論の結果が欲しい型になかなかならない</li><li>any</li></ul><p>これらの辛さの原因は、僕の文化への慣れと、構造的部分型と型エイリアスを多用する方針のどちらかだろう。関数の型が書きにくいのは慣れの問題だろう。Haskell基準で語っているので理想が高いのかもしれない。型が調べにくいのは、なれとJS向けドキュメントによる検索汚染が原因か。
Reactみたいなライブラリの型を調べる際にはどこをみるべきなんだろうか。</p><p>型推論は型システムの方針の問題だろう。たとえばオブジェクトを返す関数を書いたとき、気持ちとしてはすでに定義してある型エイリアスを提案してほしいのだが、実際にはレコード型みたいな形の型が推論結果としてフィードバックされる。主要な型は確かにそのレコード型みたいな型だろうからその挙動は理解できるし、まっとうだと思いはする。トップレベルの関数定義では、型アノテーションを書いてから本体を定義するのがやはり良いのだろう。書きはじめのころ型アノテーションの書き方がわからなくて、VSCodeに書いてもらおうとしたときにこの不満が出たのだったと思う。</p><p>anyは本当に良くない。型をつけたプログラムをデバッグするときは、強く型がついた前提で考えるので、any周りで前提が崩れて状況の認識に失敗する。
anyを書かないように頑張ることが必要だ。デバッグの際にはanyの可能性を忘れず、JSの気持ちで考えるのが良いのだろうか？
それでは嬉しさ半減な気がするのだが。。。</p><p>不満が多くなってしまったが、TypeScriptはそれなりに好きだと思う。</p><h4><a href=#react%e3%81%ab%e9%96%a2%e3%81%97%e3%81%a6 id=reactに関して class=anchor aria-hidden=true>Reactに関して</a></h4><p>Reactの他にElmを使うとか、UIはしょぼくするとかの案があった。判断の理由はReactの話に乗ってくれる人が多そうな気がしたから。個人的に最近Reactのことを調べていて、しっかり書いてみたい気持ちもあった。</p><p>関数コンポーネントで書いたし、useEffectやuseReducerもしっかり使った（つもり）。比較対処をそんなに知っているわけではないので、感想は少なめ。<code>useEffect</code>とか<code>useReducer</code>はよくできているなと思った。うまい。</p><p>今回は複数クライアントがTodoを共有するようにした。WebSocketでサーバを通してイベントの同期をとって、同期が取らたイベントだけを反映させている。これはCroquetというメタバース環境の実装方針のアイデアを拝借した。イベント同期のためのWebSocketクライアントの管理のために<code>useEffect</code>を使い、イベント処理のために<code>useReducer</code>を用いた。</p><h3><a href=#%e3%82%b5%e3%83%bc%e3%83%90 id=サーバ class=anchor aria-hidden=true>サーバ</a></h3><p>Golangを用いた。ゴルーチンとチャンネルの使い方や、構造体型の設計がセールスポイントだろうか。特に凝ったことをしたわけではなく、「これくらいは書けます」とアピールできるだろうと見込んでいる。</p><p><del>力尽きたのであとは宿題。</del></p><p>2年越しの再開をする。</p><p>サーバは特に工夫をしなかったと思う。サーバをできる限り薄くして、アプリケーションのロジックやデータ構造の定義をフロントエンドに寄せることを意識した。サーバはデータ構造のパースをして壊れていないことを一応検証したり、イベントにタイムスタンプをつけてイベントに全順序をつけることを責務として持つようにした。
Websocketで全てのクライアントと接続して、pub/subみたいなことを実装したのも頑張りどころではあったのかな。</p></p></div><div class=post-footer><p><time>2022-08-23 +0900</time>
lastmod: <time>2024-04-18 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/python-filter/>Python のfilter関数が良い</a></h1><div><p><p><a href=https://docs.python.org/ja/3/library/functions.html#filter>ドキュメント</a> を読むのが早い。</p><p>こういうことができる。</p><pre><code class=language-sh>$ cat map-none.py                                                                                                                          17:34
def f(x):
    if x &lt; 0:
        return x

for i in filter(f, map(lambda a: a-10, range(100) ) ):
    print(i)

$ python3 map-none.py                                                                                                                      17:34
-10
-9
-8
-7
-6
-5
-4
-3
-2
-1
</code></pre><p>静的型つき言語では <code>f</code> が <code>maybe</code> を返すようにして、<code>filter</code> の代わりに <a href=https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Maybe.html#v:mapMaybe><code>mapMaybe</code></a> のような関数を使うところだ。
Python のおしいところは、<code>filter</code> という名前でよぶところか。</p><pre><code class=language-python>def map_maybe(fn, lst):
  filter(fn, lst)
</code></pre><p>とすれば良い話ではあるが。</p><p>こういう機能は Python に限らないような気はする。動的で関数型に関心のある言語ならこういう仕組みにするのが <code>None</code> のような値の扱いとして自然だろう</p><p>TODO: 他の動的言語での扱いを調べる。</p><ul><li>scheme</li><li>CL</li><li>JS</li><li>ruby</li><li>julia</li></ul></p></div><div class=post-footer><p><a class=tag href=/%20tags/python>#python</a></p><p><time>2022-08-19 +0900</time>
lastmod: <time>2023-01-06 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/learn-react/>Reactのしくみを学ぶ</a></h1><div><p><p>この記事は僕の勉強メモです。資料へのポインタが主なコンテンツになるかと思います。更新は随時入るでしょうし、煩わしいので追記した旨も基本的には記しません。</p><p>Reactの再描画に関するしくみを学ぶ。再計算をするかしないかの判断や、計算結果をDOMに反映するタイミング、言語としてみたときの意味論などを理解したい。</p><p>いわゆる普通のプログラミング言語のような実行モデルではない。どのような理解を詳しい人はしているのだろうか。サーバサイドレンダリングとかはどのように関係するか。
Partial evaluationだと思える？とか。</p><h2><a href=#%e6%83%85%e5%a0%b1%e5%8f%8e%e9%9b%86 id=情報収集 class=anchor aria-hidden=true>情報収集</a></h2><ul><li>日本語の記事で、<a href=https://www.asobou.co.jp/blog/web/react-rendering>このブログ記事</a>
の著者がまじめにReactを使うために学んでその知見を発信している。</li><li>上の記事からリンクしているが、Reactの開発者が<a href=https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/>（再）レンダリングについてまとめた記事</a>
を2020年の5月に公開している。コンセプトは、「ネットに散らばったまともな説明を一箇所にまとめて理解を得られるようにする」。体系的に説明されているし、ソースを示すリンクもたくさんはられている。良いHTMLって感じ。</li><li>上の記事で紹介されているように、Reactはアプリケーションの実行時にオブジェクトを管理するためのデータ構造として、Fiberを使っている。それについて<a href=https://postd.cc/react-fiber-architecture/>まとめた記事の日本語訳がこちら</a>。さらにそこからReact componentなどに関する公式ブログへのリンクがはられている。</li></ul><p>学術論文は探したけど見つからなかった。最新の情報はFacebookの人が発信する情報（ReactConとか）や公式ブログでのアナウンスに頼ることになりそう。
GitHubのIsuueとかも最新か。</p></p></div><div class=post-footer><p><time>2022-08-10 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/kyukyu/>救急でのITシステムについて</a></h1><div><p><p>全然詳しくないのだけれど、救急で受け入れ先の病院が見つからない問題は改善する見込みはあるのだろうか。きっと受け入れのプロトコルやデータの管理方法や、病院のキャパビリティに課題があるのだろう。プロトコルやデータ管理はITシステムをうまく構成して普及できればなんとかなるはずだ。そういうことを実現しようとする事業は既に存在するのだろうか。少なくとも今はまだ成功していないのだろう。どんなところが実現に対しての障壁になっているのだろうか。</p><p>このあたりのことを含めて医療に関する情報処理はもっとよくできるのではないだろうか。コロナでの病院の手続きとか。どういう企業が事業の実現に近いのだろう。</p></p></div><div class=post-footer><p><time>2022-08-01 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/pi/>円周率とユークリッド空間</a></h1><div><p><p>タイトルがこの記事の主なコンテンツなのだが、円周率はユークリッド空間に対して定まる量なのだろう、という推測と同じことを主張しているサイトの紹介をする。</p><p>その主張をしているのは<a href=https://www.shokabo.co.jp/keyword/2003_01_pi.html>こちらの裳華房のサイト</a>だ。裳華房は大学の理系の教科書を扱う出版社。</p><h2><a href=#%e7%96%91%e5%95%8f id=疑問 class=anchor aria-hidden=true>疑問</a></h2><p>空間で円が定義できるためには、空間に距離が入っていて欲しいだろうし直径と円周の比がすべての「円」に対して一意に定まる必要がある。</p><ul><li>円の定義はなにか<ul><li>距離があれば定義できるか？裳華房の主張いわく否なのだろう。</li></ul></li><li>円周率がwell-definedであるために必要な空間の条件はなにか</li></ul><p>裳華房のページで紹介されている『<a href=https://www.shokabo.co.jp/mybooks/ISBN978-4-7853-1516-0.htm>円の数学</a>』の１章が詳しそう。</p><h2><a href=#%e7%90%83%e9%9d%a2%e3%81%a7%e3%81%ae%e5%86%86%e5%91%a8%e7%8e%87 id=球面での円周率 class=anchor aria-hidden=true>球面での「円周率」</a></h2><p><a href=https://jp.quora.com/%E6%9B%B2%E3%81%8C%E3%81%A3%E3%81%9F%E7%A9%BA%E9%96%93%E3%81%AA%E3%82%89%E5%86%86%E5%91%A8%E7%8E%87%E3%82%92%E6%95%B4%E6%95%B0%E3%81%AB%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A7%E3%81%97%E3%82%87%E3%81%86%E3%81%8B>Quoraのポスト</a>で球面での「円周率」を議論している。ポストを見るのが早いが、一応解釈をメモ。</p><p>球面上では円周率（円周と直径の比）は定まらない。一意性が無いことを示す。</p><p>大円の長さが$L$の<strong>球面</strong>上で直径$L/2$の円を書く。この円は大円なので、導出される「円周率」は$2$である。</p><p>直径$L$の円は一点（中心の対蹠点）なので「円周率」は定まらないというか、$0$というかに」なる（一点の長さの定義に依存する）。これで証明は終了。</p><p>直径を大きくすると円周は$0$と$L$の間で振動する。したがって、「円周率」は$0$に収束することがわかる。</p></p></div><div class=post-footer><p><time>2022-08-01 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/local-file-transfer/>Local File Transfer</a></h1><div><p><p>近距離でのファイル交換はあまり洗練されていない印象がある。
Apple製品間ではAirdropが使えるし、Windowsにも似たような機能があったはずだ。でも汎用的に（たとえばOSを気にせずに）使える機能は見かけない。そういうときにはGoogle DriveやDropBoxみたいなクラウドサービスを使うか、USBメモリを使うのが一般的だろう。
Slackとかメールに頼ることもある。</p><p>インターネットに頼るのは不便だし、USBメモリが刺さらないデバイスも多い。
Blootoothを基本の通信方式として、それが使えない場合にインターネットを経由するのはいかがだろうか。</p><p>通信技術は既存手法を組み合わせるだけで良いだろう。難しいことはないだろう。一方でアプリケーションのUIには工夫が必要なのではないだろうか。</p><ul><li>どこにファイルを保存するか</li><li>OS間でのファイルの互換性</li><li>送信先の選択</li><li>受信の制御</li></ul><p>これらの選択に一般的な回答は存在するだろうか？
他のアプリに組み込む形がよいかもしれない。例えばローカルの会議で各自が自身のPCで文書や画像、図面などを編集するアプリがあったとして、参加者間でのデータ共有のために今考えているものを使う。このときUIはアプリの特性から決まるだろう。</p><p>この例に対して、スマホやPCのファイルシステムは一般的すぎて設定を決め打ちできないのではないだろうか。そうすると、ファイル共有の実行時にユーザが設定をあたえることになる。大変不便だろう。</p><p>設定ファイルの編集やディスパッチの機能をつければ楽になるか？
ルールエンジンとかは大げさだろうか。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/idea>#idea</a></p><p><time>2022-07-14 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/repl-unit/>REPLと単体テスト</a></h1><div><p><p>Pythonのことを考えていて、TDDの文脈での単体テストの意義にふと気がついた。つまり、失敗するテストを先に書いて、それを通るように実装をする、という方法論の意義に気がついた、ということだ。</p><p>PythonやHaskell、Lisp、ScalaのようなREPLがある言語で開発をするとき、僕はテストを先に書く理由が今まであまり腑に落ちていなかった。それはおそらく実装して、REPLでデータを渡せば動作確認できるからだ。</p><p>もちろんユニットテストを書いておいた方が再利用性とかを考えると良いだろうし、リファクタリングの助けになるのも分かる。ただ、コードを書き始める前にやるほどのこととは思えなくて、プログラムに対してユニットテストを書くことは、文章に対して推敲するような行為だと捉えていたのだ。コードがあっていそうなことはREPLで確認するのが手軽で、ユニットテストは重い作業というか。この重さは面倒なだけでなく、実際に開発速度を落としていたように感じる。</p><p>さらには何がほしいか明確ではない段階で単体テストを書いて、実装してみて、なんか違ったときにはたくさん変更する箇所があって、テストケースとプログラムの修正順序が逆転することもある（このプログラムは正しいので、怒っているテストを修正する、ということ）。</p><p>単体テスト as 推敲のパラダイムは割と悪くないと思っている。世間の皆さんはどう思っていて、実際的な方法はどんななんだろうか。</p><p>P.S. GoとかRustみたいな言語では単体テストは、もっとガンガン単体テストを書けば良いと思う。というのもこれらの言語にはREPLいから。単体テストを書けばmain関数に手を入れずに、比較的お手軽に小さい確認をできる。</p><p>ここまで書いて思ったのだけど、REPLで確認するレベルの動作確認をGoとかではテストで確認する必要はあるだろうか？（僕はないと思うことが多い）
型検査やlinterにかけることが気持ちとしては同等の検査？
言語が違えばプログラムの構造が質的に変わるので、細かい比較はあまり意味がないか。</p><p>結論は 「REPL ~ 静的検査」の対応がなんとなくあって、単体テストはもう少し大きめな検査？
あまりスッキリしない。この辺りの考えを胸に置いて、コーディングしていれば知見が得られるかもしれない。</p></p></div><div class=post-footer><p><time>2022-07-11 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/syscall/>UNIXでのパーミッション周りでの振る舞いを調べた</a></h1><div><p><p>systemcallを初めて書いた。パーミッションの挙動を調べるのがモチベーション。以下を実行できてほしかったのだが、sudoにそんなファイルは無いと怒られてしまう。</p><pre><code class=language-sh>gcc hello.c
chmod 000 hello.c
sudo a.out
</code></pre><p><code>a.out</code> をexecvで読んだところ、そこでもエラーが起きた。<code>errno</code> をみるとパーミッションが無いと怒られたようだ（execvを呼ぶバイナリをsudoで実行した）。</p><p>rootとして実行できていないのか、execvが認識するプロセスのユーザidがeidではなく、uidなのか&mldr;。</p><p>次の実験をした。<code>sudo</code> は関係ないようだ。
sudo su でrootになったあとの様子を切り取っている。</p><pre><code># ls -l
合計 44
---------- 1 root     root     16520  7月  8 18:22 callee
-rw-rw-r-- 1 furudono furudono   103  7月  7 15:43 callee.cpp
-rwxr-xr-x 1 root     root     16136  7月  8 18:25 caller
-rw-rw-r-- 1 furudono furudono   240  7月  8 18:25 caller.c
# cat caller.c 
#include&lt;errno.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;unistd.h&gt;

int main()
{
  char ** args = {NULL};
  char * cmd = &quot;./callee&quot;;
  errno = 0;
  int c = execv(cmd, args);  // my first system call
  fprintf(stderr, &quot;%s\n&quot;, strerror(errno));
  return c;
}

# ./caller 
Permission denied
# chmod 100 callee
# ./caller
hello world
# chmod 010 callee
# ./caller
hello world
# chmod 001 callee
# ./caller
hello world
</code></pre><p>カーネルかファイルシステムの都合でこうしているのだろうか。上で登場した <code>caller.c</code> と <code>callee.c</code> は GitHub で公開している：</p><p><a href=https://github.com/naoyafurudono/test-unix-permission>https://github.com/naoyafurudono/test-unix-permission</a></p></p></div><div class=post-footer><p><time>2022-07-08 +0900</time>
lastmod: <time>2022-07-31 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/systemd/>Systemd</a></h1><div><p><p>systemdでxremapを追加して、システム起動時に勝手にxremapが走るようにした。</p><p>僕の環境:</p><pre><code>$ lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 22.04 LTS
Release:	22.04
Codename:	jammy
</code></pre><p>xremapの作者の方が公開している設定を参考にした。</p><p><a href=https://github.com/k0kubun/xremap/blob/6e8e1f21285ecedfa7ac88d703ad80d25a2699dd/examples/systemd/xremap.service>https://github.com/k0kubun/xremap/blob/6e8e1f21285ecedfa7ac88d703ad80d25a2699dd/examples/systemd/xremap.service</a></p><p>依存先が僕の環境では存在しないと怒られたので、<code>default.target</code> を指定した。この設定ファイルを <code>~/.config/systemd/user</code> において、<code>systemctl --user enable xremap</code> を呼びだす。すると次回のsystemdが起動するときに、xremap を呼んでくれるようになる。</p><pre><code>[Unit]
Description=xremap

[Service]
KillMode=process
ExecStart=/home/furudono/.local/bin/xremap /home/furudono/.config/xremap/xremap.conf
ExecStop=/usr/bin/killall xremap
Restart=always
Environment=DISPLAY=:0.0

[Install]
WantedBy=default.target
</code></pre><p>快適になった。</p></p></div><div class=post-footer><p><time>2022-07-08 +0900</time>
lastmod: <time>2022-07-09 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/spotify-at-commit/>Spotify at Commit</a></h1><div><p><p>Spotifyの再生が一瞬途切れることがある。そしてそれがシェルコマンドを叩いたタイミングと重なる。どんなカラクリなんだろうか。ただの気のせい？
さっきはコミットしたときに一瞬途切れた。</p></p></div><div class=post-footer><p><time>2022-07-04 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/shell-commands/>Shell Commands</a></h1><div><p><p>パーミッションのことが気になって、シェルコマンドのソースコード（C言語）を読んでいるのだけど、読んでいて楽しい。<code>rm</code> から読み始めたのだが <code>errorno</code> やコマンド引数の扱い方、トラバース (ftsを使う) の書き方で学びが得られた。
Goのエラーハンドリングの強さが分かる。</p><p>なお、パーミッションはコマンドの実装とは分離されているみたいだ。ファイル削除は <code>unlinkat</code> システムコールが実現していて、その前後で権限取得みたいなことは行わない。</p><p>次に <code>chmod</code> を読んでからシステムコールとOSの話を見にいこう。</p><ul><li><a href=https://github.com/naoyafurudono/coreutils>読んでいるソースコード</a></li><li><a href=https://manpages.ubuntu.com/manpages/bionic/ja/man2/unlink.2.html><code>unlinkat</code></a></li></ul></p></div><div class=post-footer><p><time>2022-07-04 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/procon/>競技プログラミング</a></h1><div><p><p>数ヶ月前からときどきAtCoder <a href=https://atcoder.jp/users/donofuru>(my account)</a> のコンテストに参加している。就活とか関数型ではない言語でのプログラミングを意識して始めた。今回のABCで灰色を脱して茶色になったので記念に記録しておく。</p><p>はじめは入出力がなによりも難しかったし、なんなら今も悩むのはそこな気がする。次に問題文の誤読が多い。これは恥ずかしいことなので特に気をつける。慣れもあるのかもしれないが。そしてC++で書いているのに関数型な頭で取り組んで苦戦するケースもある。
forではなくて、mapとかをゴリゴリ使いたくなるのだ。今日もmapを使おうと思って検索したのだけど全然検索でヒットしなかった。まあ、mapはC++で使うべきではないことは分かる。</p><p>イテレータを使うのが面倒ですこし困る。<code>begin()</code> と <code>end()</code> をいちいち書くのは嫌なものだ。Rustに移行すれば楽になるのかな。もう少し勉強してみるか。</p><p>おかげでC++には少しなれることができた。欲しい機能がないことがよくあるけど、ちょっと頭をひねればきれいに回避できることが多い。訓練だと思ってC++で続けるのはありかもしれない。
Rust欲はあるので移行はあり。</p><p>色の話をしておこう。今のパフォーマンスだと緑色の下か真ん中くらいなようだ (900-1100)。言語と環境により慣れれば多少上がるかもしれないが、大幅な違いは生じないだろう。なにより今のアルゴリズム力で人生を終えるのは寂しいので頑張りたい。脳の老化が始まるまで、そんなに時間は残ってないはず。</p><p>とりあえず朝活するかな。</p></p></div><div class=post-footer><p><time>2022-07-03 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/phantom-type/>Phantom Type</a></h1><div><p><p>Phantom type (幽霊型) をチラッと学んだのでメモ。きっかけは <a href=https://dl.acm.org/doi/10.1145/3022671.2984009>Gentrification gone too far? affordable 2nd-class values for fun and (co-)effect</a> を読んでいるときに出てきたこと。</p><p>静的な型を持つ言語で使うテクニックで登場する型（パラメータ）のことをphantom typeという。</p><pre><code class=language-haskell>-- このaがphantom type
data Com a = String

type First ()
type Second ()
type Third ()

init :: String -&gt; Com First 
next :: Com First -&gt; Com Second
final :: Com Second -&gt; Com Third
</code></pre><p>init -> next -> finalの順で呼ぶことになる。それ以外の順番では型検査を通せない。線形型とかGADTとかと組み合わせるともっとリッチなことをできるだろう。セッションタイプを似たような概念として聞いたことがある。どのように関係があるのだろうか。</p><h3><a href=#%e8%bf%bd%e8%a8%98 id=追記 class=anchor aria-hidden=true>追記</a></h3><p><a href=https://blog.janestreet.com/howto-static-access-control-using-phantom-types/>Jane Street のテックブログでphantom typeをYaron Minskyが紹介していた</a>。
readonly/readwrite/immutableみたいなアクセス制御を実現する方法を例として紹介している。</p></p></div><div class=post-footer><p><time>2022-06-29 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/blog-code/>コードブロックの表示</a></h1><div><p><p>コードブロックの表示が気に入らない。設定をいじって白地にしたい。現状では黒地。というのは、ブログの背景が白だし、僕が普段白地になれているから。<a href=https://jp.quora.com/burauza-ya-Web-saito-nado-no-da-ku-mo-do-ha-jissai-ni-me-ni-yasashii-no-desu-ka/answers/135572570>白地を養護する主張</a> に影響を受けた。実際目が楽になったような気がする。</p></p></div><div class=post-footer><p><time>2022-06-28 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/go-learn-memory-motivation/>Golang の変数キャプチャ</a></h1><div><p><p>Golangの変数キャプチャを勉強する。</p><p>追記: 最初、変数キャプチャではなくメモリモデルを勉強しようとしていた。勉強してみて、求めている概念では無いことに気がついたのでタイトルなどを修正した。メモリモデル自体は知れて良かった。非同期処理へのコンパイラ最適化が及ぼす影響を知れる（<a href=https://go.dev/ref/mem>公式サイト</a> におせわになった）。変数キャプチャの説明は<a href=https://eli.thegreenplace.net/2019/go-internals-capturing-loop-variables-in-closures/>これ</a> を読む。３年前に僕と同じことを思ったひとがいたようだ。</p><h2><a href=#overview id=overview class=anchor aria-hidden=true>Overview</a></h2><p>クロージャをforループ内で生成してデータ構造や高階関数に渡すような処理を書いた。そこで変数の扱い（メモリモデル）でエラーを出したことがことの始まり。解決策はシンプルなのだが、イマイチしっくりこないので勉強したくなった。クロージャの変数キャプチャは言語によりけりだし、特徴が現れるように思う。
Golangがどうなっているか知るのが楽しみ。</p><h2><a href=#%e5%8b%95%e6%a9%9f%e3%81%a8%e3%81%aa%e3%81%a3%e3%81%9f%e3%83%9f%e3%82%b9 id=動機となったミス class=anchor aria-hidden=true>動機となったミス</a></h2><p>問題のコードはこんな感じ<a href=https://go.dev/play/p/unayMJyn_3g>(The Go Playground)</a>。</p><pre><code class=language-go>words := []string{&quot;foo&quot;, &quot;boo&quot;, &quot;bang&quot;}
arr := []func(){}

for i, elem := range words {
	arr = append(arr, func() {
		fmt.Printf(&quot;%d: %s\n&quot;, i, elem)
	})
}

for _, f := range arr {
	f()
}
</code></pre><p>結果は次の通り。</p><pre><code>2: bang
2: bang
2: bang
</code></pre><p>期待していたのはこれ。</p><pre><code>0: foo
1: boo
2: bang
</code></pre><p>こうすると期待通りの出力を得られる<a href=https://go.dev/play/p/xO9C4G03a0k>(The Go Playground)</a>。</p><pre><code class=language-go>words := []string{&quot;foo&quot;, &quot;boo&quot;, &quot;bang&quot;}
arr := []func(){}

for i, elem := range words {
	i := i
	elem := elem
	arr = append(arr, func() {
		fmt.Printf(&quot;%d: %s\n&quot;, i, elem)
	})
}

for _, f := range arr {
	f()
}
</code></pre><h2><a href=#%e7%90%86%e8%a7%a3 id=理解 class=anchor aria-hidden=true>理解</a></h2><p>どういう理屈で振る舞いが変わったのだろうか？一般的な理屈が知りたい。
２つの要素がある。for文のスコープとクロージャの変数束縛だ。</p><h3><a href=#for-%e6%96%87%e3%81%ae%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%97 id=for-文のスコープ class=anchor aria-hidden=true>for 文のスコープ</a></h3><p><a href=https://go.dev/ref/spec#For_range>言語仕様 (<code>range</code>つきfor文)</a> によると、<code>range</code> 節を伴ったfor文では、宣言した変数が使い回されるらしい。</p><blockquote><p>The iteration variables may be declared by the &ldquo;range&rdquo; clause using a form of short variable declaration (:=). In this case their types are set to the types of the respective iteration values and their scope is the block of the &ldquo;for&rdquo; statement; they are re-used in each iteration. If the iteration variables are declared outside the &ldquo;for&rdquo; statement, after execution their values will be those of the last iteration.</p></blockquote><h3><a href=#%e3%82%af%e3%83%ad%e3%83%bc%e3%82%b8%e3%83%a3%e3%81%ae%e5%a4%89%e6%95%b0%e6%9d%9f%e7%b8%9b id=クロージャの変数束縛 class=anchor aria-hidden=true>クロージャの変数束縛</a></h3><p><a href=https://go.dev/ref/spec#Function_literals>言語仕様 (関数リテラル)</a>
によると関数リテラル（クロージャ）は定義もとの変数を共有するとのこと。</p><blockquote><p>Function literals are closures: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.</p></blockquote><h3><a href=#%e5%95%8f%e9%a1%8c%e3%81%ae%e8%aa%ac%e6%98%8e id=問題の説明 class=anchor aria-hidden=true>問題の説明</a></h3><p>最初の例では、forループで宣言された変数 <code>i</code> をすべての関数リテラルが共有した。最初のforループが終わったあとの変数 <code>i</code> の値は最後の繰り返しでの値になる。なのですべて 2: bang` と表示した。</p><p>２つ目の例では、forループの中で、毎回変数 <code>i</code> を宣言、定義した。for文が代入する変数<code>i</code>は、for文がイテレーションで定義したものではなく、はじめに定義したものなのでそれぞれのクロージャは影響を受けない（クロージャはfor文の各繰り返しのブロックと変数を共有するが、ブロックはすぐに終了してそれぞれのクロージャだけが変数にアクセスしうるようになる）。したがってそれぞれのクロージャは別々の値をプリントする。</p><h2><a href=#%e3%81%82%e3%81%a8%e3%81%8c%e3%81%8d id=あとがき class=anchor aria-hidden=true>あとがき</a></h2><p>すっきりした。嬉しい。</p><p>GolangのキャプチャはC++の参照キャプチャと思ってよさそうだろうか。クロージャの側は多分良いけど、変数の生存期間が違うので類推しないのが安全か。</p><p>言語の理解が進むとその言語をもっと好きになるみたいだ。</p></p></div><div class=post-footer><p><time>2022-06-28 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/js-good-parts/>JavaScript The Good Partsを読んだ</a></h1><div><p><p>読んだ。きっかけはTypeScriptの関数型言語好き向けの紹介ページで事前知識として要求されていたから。読んでよかったと思う。しっかりJSの知れたのではないかと（その判定はまだできないが）。とはいえまだまだ知るべきGood Partsはある気がする、というのも<code>const</code>とか<code>let</code>が説明されていないので、情報が古いだろうと感じたから。プロトタイプの話が載っていたり、thisの動的な意味の変化のこととか、<code>var</code>のスコープとかを説得力をもって説明してくれたのはとてもありがたい。そういう点で読んでよかったと思う。DOMやevent handlerなど、ブラウザ周りの話を知りたい。</p><p>JSがSchemeに近い部分があることを知られて良かったと思う（Schemeのletがあればどんなに幸せだろうと思うけど）。
JSには偏見しかなかったけど、良い言語に思えてきた。TypeScriptも知りたい。DOMとevent handlerが先だが。
UIを扱うにはJSが強い？C# with Unityもあるのか？
TSよりも関心はDOMやevent handlerにある。</p><h2><a href=#%e8%bf%bd%e8%a8%98 id=追記 class=anchor aria-hidden=true>追記</a></h2><p>JSの<code>let</code>を勉強している。情報源は<a href=https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/let>MDN</a>。<code>var</code>が作るスコープがレキシカルスコープではないことは既に知っている。<code>let</code>はマシだが、SchemeとかOCamlで期待するような感じにはならない。<a href=https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone>MDN 一時的なデットゾーン</a>で解説されている。
MDNでも触れられているが、<code>let</code>の右側（<code>let x = &lt;ここ></code>）が常にこのletが作るスコープに所属することになる。なので、常に束縛する変数と同じ名前は<code>let</code>の右側には出現できない（e.g., <code>let x = x.foo</code>は常にエラー）。その他に、同じブロックに同じ変数に対する<code>let</code>を複数回使えない。シャドーイングが不便。これらはすべて良くないとは思うが、そんなに大きな問題でも無い気はする。</p><p><code>let</code>の仕様によって、JSでブロックを使う意味が生まれた？[^fn]<code>switch</code>でそれぞれのブランチのスコープを区切るためにブロックを使うテクニックが紹介されている。</p><p>[^fn]この疑問符は、他の用法はあったのだろうか、という意図。</p></p></div><div class=post-footer><p><time>2022-06-20 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/anime/>趣味</a></h1><div><p><p>心に残った作品を列挙しておく。順序に意図は無い。ちなみにこの記事はお酒によったときに書いたり追記したりしている。</p><h2><a href=#%e3%82%a2%e3%83%8b%e3%83%a1 id=アニメ class=anchor aria-hidden=true>アニメ</a></h2><ul><li>91Days</li><li>パリピ孔明</li><li>true tears</li><li>天元突破グレンラガン</li><li>マクロスデルタ（見た時期の影響が大きいかも）</li><li>Banana Fish</li></ul><p>マクロスデルタは大学受験のはじめのころ、モチベーションがない時期にみた。マクロスデルタのおかげで今の僕は自分のメンタルヘルスをある程度管理できるようになった。</p><h2><a href=#%e6%9c%ac id=本 class=anchor aria-hidden=true>本</a></h2><h3><a href=#%e6%b0%91%e4%b8%bb%e4%b8%bb%e7%be%a9%e3%82%84%e9%96%a2%e9%80%a3%e3%81%97%e3%81%9f%e3%83%91%e3%83%bc%e3%82%bd%e3%83%8a%e3%83%aa%e3%83%86%e3%82%a3%e3%81%ae%e3%82%88%e3%81%86%e3%81%aa%e3%81%93%e3%81%a8%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6 id=民主主義や関連したパーソナリティのようなことについて class=anchor aria-hidden=true>民主主義や関連したパーソナリティのようなことについて</a></h3><p>民主主義みたいな事柄が気にかかっていた時期があった。</p><ul><li>人間失格</li><li>それから</li><li>学問のすすめ</li><li>エヴァ（漫画、新劇場版の破以降）</li></ul><p>心には残っていないが、スッキリさせてくれたのが文科省の「民主主義」。戦後に出版されたやつ。</p><p>これらをもとに民主主義とかパーソナリティに思いをはせたのは、社会学について講義や本で学んだ経験が影響しているだろう。もしかしたら仏教の縁とかキリスト教の愛みたいな考え方を聞いたことも影響しているかもしれない。人間性をだそう思うと、個人は責任ある（あるいは、アイデンティティのある、自我のある、人格のある）主体として振る舞う必要があって、その上で他者といい関係を築くことが今どきの社会での人のあるべきありかたである、みたいな考え方をもつようになった。</p><p>僕は昔から自我みたいなものが弱い気がしていて、そこに課題を感じつつ、一つの主体として他者と交流することに憧れたり、それに向けてもがいたりしている節がある。とはいえエヴァのゲンドウがいっていた（気がする）ように、人と人は分かりあえないみたいな考え方をぼくももっていて、だからこの努力は一生終わることが無いものなのだろう。完璧な理解みたいなものはなくて、腹に落ちた感覚があるだけだと思っている。</p><h3><a href=#%e9%87%8e%e5%b4%8e%e3%81%be%e3%81%a9 id=野崎まど class=anchor aria-hidden=true>野崎まど</a></h3><ul><li>know</li><li>ファンタシスタドール イブ</li><li>うさぎと縁の本（タイトル忘れた）</li></ul><p>アムリタからハマった。</p><h2><a href=#%e9%9f%b3%e6%a5%bd id=音楽 class=anchor aria-hidden=true>音楽</a></h2><p>ボカロやJPOPがすき。うたってみたもすき。とりあえず好きなアーティスト:</p><ul><li>Ado</li><li>まふまふ</li><li>ろん</li><li>ハチ</li><li>dazbee</li><li>Vaundy</li><li>King Gnu</li></ul><p>好きな曲:</p><ul><li>まふまふの曲が何個か（タイトルは忘れた）</li><li>Snow Song Show（そらるとろん）</li><li>夢花火（まふまふ）</li><li>リストの巡礼の年のアルバムでSpotifyで最初に流れるパート</li><li>Vaundyの踊り子（MVが特に好き、かっこいい）</li><li>King Gnuのいろいろな曲</li></ul><h2><a href=#%e3%81%9d%e3%81%ae%e4%bb%96 id=その他 class=anchor aria-hidden=true>その他</a></h2><ul><li>フィンダーおじさん (Vtuber)<ul><li>トークではなくて作品</li></ul></li></ul><h2><a href=#%e3%83%a1%e3%83%a2 id=メモ class=anchor aria-hidden=true>メモ</a></h2><p>心に残ったのはこれくらい？もっとありそうなものだけど。ハマったのは他にもあるが、あれは心地よかっただけなのかもしれない。本は作家で好きになることが多い。思想や文体が好きなのか？</p><ul><li><p>野崎まど</p></li><li><p>村上春樹</p></li><li><p>西尾維新</p></li><li><p>森博嗣</p></li><li><p>夏目漱石は少し</p></li><li><p>アニメはきりがない。</p></li><li><p>映画やドラマはそんなに嗜まない。</p></li><li><p>音楽もそんなに。リストの巡礼の年の不安定なパート（ピアノのソロ）はすごいと感じたくらい。</p><ul><li>（追記）これは嘘。音楽は割と好き。書き加えておく。</li></ul></li><li><p>絵もあまり。大蔵美術館（だったか？倉敷の西洋絵画がある）でみた受胎告知はよかった。</p></li><li><p>建築はかっこいいとかこの辺がイカしてる、とか思うくらい</p></li><li><p>証明やプログラムは、ここでの関心とずれている？（僕の中での解像度が違うのか、立場が違う？）</p></li><li><p>人間は？</p></li></ul><h2><a href=#%e3%81%82%e3%81%a8%e3%81%8c%e3%81%8d id=あとがき class=anchor aria-hidden=true>あとがき</a></h2><p>これくらいにしておこう。漫画やゲームがぱっと出てこなかったのが驚きであり、また腑に落ちる感じもする。こういうことを内省するのも楽しい。きっかけは今日見たパリピ孔明がすごく良かったから。深夜テンションで書きました。</p><h3><a href=#%e4%bb%8a%e9%a3%b2%e3%82%93%e3%81%a7%e3%81%84%e3%82%8b%e3%81%8a%e9%85%92 id=今飲んでいるお酒 class=anchor aria-hidden=true>今飲んでいるお酒</a></h3><ul><li>2023-03-19: Big Peat</li></ul></p></div><div class=post-footer><p><time>2022-06-20 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/go-log/>Golangでのlog</a></h1><div><p><p>Golangの標準ライブラリに<code>log</code>がある。いろいろ関数が提供されているが、機能はざっくりいうと「引数で与えたメッセージにタイムスタンプをつけて標準エラー出力に流す」みたいな感じ。ログにレベルをつけようと思うとこれでは足りない。レベルというのは、<code>DEBUG</code>とか<code>ERROR</code>みたいなやつ。書くログ関数にレベルを設定した上で、グローバル変数とかで現在のレベルを設定する。プログラムを実行すると、現在のレベルで有効なログ関数だけが発火する。</p><p>Golangでこれをやろうと思うと、サードパーティを使うか自分で定義することになる。自分で定義するのも意外と悪くない。実装のほとんどは標準の<code>log</code>に委譲すれば済むし使い勝手は最高。設計に注意が必要なのと、面倒なのは間違い無いのでそれが難点か。
Golangのインターフェースのおかげで使い勝手を簡単によくできる。感謝。</p></p></div><div class=post-footer><p><time>2022-06-19 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/vote/>投票所のシステム</a></h1><div><p><p>選挙に行ってきた。そこで投票用紙を一枚差し出す機械を見て驚いた。あの機械が何をやっているのかは定かではないが、おそらく正確に１枚だけ投票用紙を有権者に渡すことが責務の一つなのだろう。そんな機械があるのはびっくり（皮肉を言いたいわけではない）。正確に一枚の投票用紙を渡すことは法律を遵守するために必要なことだし、機械を使わずに人の手で配る場合、複数枚渡すミスは確実に起きるだろう。なので、そこを徹底することは尤もだと思う。</p><p>では他に良い手はないだろうか。投票用紙をもらうためには、あらかじめ有権者に配布された案内票みたいなものを持っていく必要がある。それに投票用紙の機能をつけるのはどうだろうか、と思ったけど一意性の担保が難しそう。というのは、案内票は再発行できてほしいはず。たとえば郵送中に損なわれた場合や紛失した場合。再発行するには過去の案内票を間違いなくdropしないと一意性が担保されない。
dropのためにidを振るとかが考えられるが、無記名投票の原則に影響する。そういうわけで、案内票を投票用紙として使うのは難しそうだ。</p><p>ところで、最後の投票用紙を受け取るときに、案内票を回収された。これによって投票に行ったか否かがバレてしまうのが問題にならないかと思ったが、投票所を見張っていればバレることなのでいまさらか？</p><p>電子投票ではどんな性質をどのように担保しているのだろうか？
やろうと思うとフィジカルな投票所は単に、バーチャルな投票所にアクセスできない人が集う場所になるだろう。委員会のひとはネットワークやパソコンなどのセットアップをする係になりそう。求められる能力が少し変わって、人を集めるのが大変そうだ。日本での実現には10年か20年くらいかかるだろうか。今の子供がそのあたりの教育を受けることを仮定したらの話だが。とはいえ、ipadとかでもできる気がするので、そんなに難しくない？安定性が一番の懸念か？インターネットアクセスも問題になる？
とはいえそういう地域はいまでも問題になっていそうだし、電子的にしたほうが楽なイメージがある。</p><p>最後に、細かいことをたくさん書いたけど、僕はこのあたりの仕組みに興味があるのであって、現行の選挙システムのセキュリティに文句があるわけではないことを明記しておく。紙の投票用紙も好きだし。</p></p></div><div class=post-footer><p><time>2022-06-19 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/go-context/>Go Context</a></h1><div><p><p>Golangで始めてcontextを使った。リポジトリは非公開なのであしからず。</p><p>Webスクレイピングツールを作っている。ランディングページを見て良さげなページへのリンクを集め、それらのリンクから欲しいコンテンツを収集する、というのがメインの動き。基本的には起動したら放置するのだが、ときどきいらないページをスキップしたくなる。このスキップ機能を追加するためにcontextを使った。</p><p>当初は<code>context.WithCancel</code>で良いかと思ったが、同じ<code>ctx</code>に複数回cancelを送信したいので良くない。結局<code>context.WithValue</code>で受信チャンネルをもたせた。あとはキー入力を受け付けるgoroutineを立てて、良い感じに対応する送信チャンネルから<code>struct{}{}</code>を送れば良い。
(受信側はもちろんいる。もともとDOS攻撃を避けるために待つ箇所があったので、そこで<code>timer.After</code>と並行して件のチャンネルを待つことにした。)</p><p>標準入出力をいろいろな部分から使っているので操作画面がとてもきたない。とはいえ自分で使う分にはストレスなく思ったとおりに動くので道具としては満足。</p></p></div><div class=post-footer><p><time>2022-06-18 +0900</time>
lastmod: <time>2022-08-10 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/disable-ipv6-ubuntu/>UbuntuでIpv6を無効化する</a></h1><div><p><p>学内ネットにVPN接続してIEEEの論文を取得しようとしたが、学内からのアクセスだと認識されなかった。
IPv6を無効化するとうまくいった。</p><p>MacではGUIでIPv6をon/offできたが、UbuntuではCUIから設定した（<a href=https://www.server-memo.net/ubuntu/ubuntu_disable_ipv6.html>参考ページ</a>）。以下を実行する。</p><pre><code class=language-sh>sudo sysctl -w net.ipv6.conf.all.disable_ipv6=1
sudo sysctl -w net.ipv6.conf.default.disable_ipv6=1
sudo sysctl -w net.ipv6.conf.lo.disable_ipv6=1
</code></pre><p>設定は永続的ではない。永続的でないことは <code>sysctl</code> の manページや <a href=https://access.redhat.com/documentation/ja-jp/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/configuring-kernel-parameters-temporarily-with-sysctl_configuring-kernel-parameters-at-runtime>Red Hatのドキュメント</a> を参照すると分かる。</p><p>逆に有効化するためには、<code>...=1</code> を <code>...=0</code> にすればよいはずだ。こちらは動作確認をしていないことに注意。</p><p>僕へ: <code>~/.local/bin/disable-ipv6.sh</code> に上のスクリプトを書いた。パスが通っているので <code>sudo</code> をつけて実行せよ。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/ubuntu>#Ubuntu</a></p><p><time>2022-06-17 +0900</time>
lastmod: <time>2022-07-15 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/zoom-ubuntu/>Ubuntu22.04でZoomの画面共有がうまくいかなかった件</a></h1><div><p><p>追記: 先日画面共有しようとしたところ、うまく相手に表示されなかった。
Zoomから退出して、Ubuntuにログインし直し、ウィンドウシステムをWayalndからXに切り替えたところうまくいった。やはりXが安定なのか。</p><p>Ubuntu22.04で画面共有しようとすると、共有候補にホワイトボードしか表示されなかった。<a href=https://support.zoom.us/hc/en-us/articles/6634039380877>Zoomがknown issue</a>として公開していた。詳しくはリンク先を読めばよいが、waylandとの相性の問題とのこと。そのうち修正したいと書いてある。</p><p>対応策としては以下が紹介されていた。</p><ul><li>Xorgを使う</li><li>ブラウザ版zoomを使う</li><li>OBSのようなソフトで仮想カメラにキャプチャ画面をつなげて、それをzoomで共有する</li></ul><p>僕は面倒なので、常に全画面を共有するように設定した。これはzoomアプリの画面共有設定から行える。</p></p></div><div class=post-footer><p><a class=tag href=/%20tags/ubuntu>#Ubuntu</a></p><p><time>2022-06-15 +0900</time>
lastmod: <time>2022-07-10 UTC</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/nvim-clipboard/>NeoVimでクリップボードを使う</a></h1><div><p><h2><a href=#neovim-%e3%81%a7%e3%82%af%e3%83%aa%e3%83%83%e3%83%97%e3%83%9c%e3%83%bc%e3%83%89%e3%82%92%e4%bd%bf%e3%81%86 id=neovim-でクリップボードを使う class=anchor aria-hidden=true>NeoVim でクリップボードを使う</a></h2><h2><a href=#tldr id=tldr class=anchor aria-hidden=true>TL;DR;</a></h2><p><code>init.vim</code>に<code>set clipboard+=unnamedplus</code>と追記する。</p><h2><a href=#%e9%95%b7%e3%82%81%e3%81%ae%e8%aa%ac%e6%98%8e id=長めの説明 class=anchor aria-hidden=true>長めの説明</a></h2><p>Nvim では（vi や vim も）ヤンクやペーストで、nvim が管理するバッファを記憶領域として用いる。なのでクリップボードとは分離されていて不便なことが多い。</p><p>バッファとクリップボードをつなげれば良くて、その設定は上のコマンドで完結するようだ。ネットの記事には裏で<code>pbcopy</code>やそれに類するものの設定が必要、みたいなことをいう記事があるが手元の環境では上の１行を追加するだけで良かった。</p><pre><code>:version
NVIM v0.6.1
Build type: Release
LuaJIT 2.1.0-beta3
Compiled by team+vim@tracker.debian.org
</code></pre><p><a href=https://github.com/naoyafurudono/nvim-config/commit/23b1e25099abd81a096f4719c7c2d11629f725d7>該当コミット</a>：関係無い変更も同時にコミットしてる&mldr;。</p><p>複数の nvim プロセス間でクリップボードを共有できる（当然）のが地味に便利。
（普通は複数プロセス立てない？）</p></p></div><div class=post-footer><p><time>2022-06-12 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/begin-rust/>Begin Rust</a></h1><div><p><p>Rustを勉強している。やはりライフタイムとか借用のあたりで苦労している。所有権やライフタイムはわかるのだが、借用の仕組みがイマイチわからない。特に可変な借用が同時に複数あってはならない、という規則で、同時にとは一体？という気持ちになる。同時の概念を理解させてくれる文書に出会えていない。これが原因で詰まった話をする。一応問題の回避はできたが、腑に落ちきっていない。</p><p>練習がてら、状態遷移系の各ノードで、与えられたCTL-formulaが成り立つかを調べるラベリングアルゴリズムを実装した。</p><p><code>labeling</code>関数内でループを回す。考慮するすべてのCTL-formulaについて、条件が合えば <code>add_label</code> 関数を呼んでノードにその論理式への参照を追加する。ノード（<code>State</code>）につけるラベルは<code>labels: HashMap&lt;State, HashSet&lt;&amp;Formula>></code>としている。</p><p>はじめ、<code>add_label</code>は<code>labels</code>の可変参照をとるようにしていたのだが、借用チェッカに怒られてしまった。つまり<code>add_label : (..., labels: &amp;mut HashMap&lt;...>) -> ()</code>。<code>add_labels</code>の呼び出しが複数回あって、それぞれに参照で貸し出したのがまずいようだ。直感では関数呼び出しが終わると参照を捨てるから安全だし、型システムもそう思ってくれる気がしていたのだが&mldr;。</p><p><code>add_label</code>に所有権を一旦渡して、変更した上で返却するようにしたら、怒られがなくなった。つまり<code>add_label : (..., labels: HashMap&lt;...>) -> HashMap&lt;...></code>とした。呼び出し元で<code>labels</code>に再代入することで所望の追加を実現できる。</p><p>これはこれできれいだと思うけど、はじめのアイデアも悪くない気がしてしまう。きっと修行が足りないのだろう。</p></p></div><div class=post-footer><p><time>2022-06-11 +0900</time>
lastmod: <time>2023-02-12 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/favicon/>Favicon</a></h1><div><p><p>ファビコンをつけてみた。素材は<a href=https://jdenticon.com/#icon-nfurudono>JDENTICON</a>で生成した。それをもとにfavicon用のファイルを<a href=https://www.favicon-generator.org/>Favicon.ico & App Icon Generator</a>で生成。</p><p>設定はコミットを見るのが確か。<a href=https://github.com/naoyafurudono/naoyafurudono.github.io/commit/8eb6ab8952ce55832f00b3aae0264d2b9c66f227>https://github.com/naoyafurudono/naoyafurudono.github.io/commit/8eb6ab8952ce55832f00b3aae0264d2b9c66f227</a></p></p></div><div class=post-footer><p><time>2022-05-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/2022/blog-theme/>ブログの設定を変えた</a></h1><div><p><p>このブログはGitHub Pagesで公開していて、Hugoを用いて生成している。
Hugoの設定をろくに調べずに雑に書いていたのだが、今回少しドキュメントを読んで設定をした。</p><ul><li>トップページ（記事へのリンクが並ぶページ）に記事の全文が表示されていたのが改善した。<ul><li><code>asCJKLanguage = true</code>が効いていそう</li></ul></li><li>テーマを変えた</li></ul><p>最近Ubuntuを使い始めたり、講義でプログラミングする機会が増えたりした。得たTipsを積極的に記事にしよう。</p></p></div><div class=post-footer><p><time>2022-05-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/2022/april/neovim/>NeoVimを使い始めた</a></h1><div><p><p>Neo Vimが使っていて楽しい、という話。普段はVSCodeを使っていて、全然移行したわけでもないのだけれど、NVimは文字入力に対する反応が比較的早くて楽しい。ところで、いつも思うのだけど、日本語って打ちにくくないだろうか。IMEがいるのが良くない（これ以上の日本語入力方式はないだろうか？手書きよりは良いのだけれど）。</p><p>英語だとタイプミスしてもとりあえず近い単語を入力できて、大体スペルチェッカの修正機能で直せる。だからテキトーにキーを叩いてからあとはおまかせでok。入力ミスのダメージが小さい。それに対して日本語では、IMEが正しく認識できるように文字列を入力しないといけない。多少のまちがいはIMEは許容してくれることもあるけど英語の時ほどではなくて、大抵は一字一句正確に入力しないといけない。もしも間違って入力すると、IMEがうけっとた範囲の入力が全て誤って変換されるので（部分的にあっていても、正確に変換させるために全消しすることが多い）、ダメージが大きい。だから日本語入力は大変だ。</p></p></div><div class=post-footer><p><time>2022-04-16 UTC</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/2022/april/syntacticalz-editor/>構文エディタ実装の考え</a></h1><div><p><p>構文エディタとは、文字単位だけでなく抽象構文木単位での編集ができるエディタのこと。一般のコードでなく、プログラムを編集することは抽象構文木のノードやエッジの編集に対応する。ならば、そういう単位での編集をエディタが直接サポートすれば楽できるという発想（だと想像する）。</p><p>アイデアとしてはそれらしい気がする。でも流行ってるようには見えない。なんでか？</p><ul><li>需要が少ない:
プログラムを新しく書くことは構文エディタの対象外であり、プログラムがあってそれに対する選択が主な操作である。なので構文じゃない編集機能はやはり必要で、そう考えるとそんなに欲しくない。とか？</li><li>使い勝手が悪い:
使ったことがないし、具体的な機能を知らないので想像でしかないけど、おそらく思ったようにASTのノードを選択できないのではないか？そもそも選択したい「ASTのノード」が実は存在しないケースがある。<code>(e1;e2;e3)</code>のうち、<code>e1;e2</code>と<code>e2;e3</code>のどちらかは存在しないはず。この辺りの問題は工夫すれば解決できそう。既存の実装はどのくらい工夫しているのだろうか。</li><li>普通のエディタで十分:
前の/次のセミコロンまでジャンプとか、かっこまでジャンプとかがあれば済むケースは多い。</li><li>実装が大変:
使い勝手を考えるとシンタックスハイライトとかよりは大変そう。抽象構文木をアレンジした概念が必要になりそう。</li></ul><p>実装の話は Lisp なら簡単か。かっこを上手に扱う機能が入ればあとは普通のエディタの機能でほとんど構文エディタになる。</p><p>逆にシンタックスを弄りやすくして、普通のエディタが構文エディタ的な振る舞いをできるようにするのはどうだろう？Haskellはいい線いってる？文を消す &lt;&ndash;> 行を消すの対応をほとんどの言語でしているので多かれ少なかれそういう側面がある。究極的にはどこまでいけるだろうか？
エディタの基本操作は一文字入力/削除か。Vimでできることに広げるとどうだろうか。</p><p>関連して、エディタの話の制限を忘れて、言語デザインと使い勝手を考えたい。ソースコード &ndash;> AST &ndash;> typed-AST &ndash;> 実行結果 くらいの段階がプログラマが交流しうるプログラムの表現だろう（実行結果が入るのは理論的じゃないかもだけど、気持ちとしては入るはず。みんな実行のことを考えてプログラムを書くのだから）。</p><p>プログラムの概念は色々あるが、それらは必ず上のどこかの概念として捉えることができる。プログラムの挙動は実行時のことだし、行数はソースコードのこと。では型は？
typed-ASTかそれよりも前のどこかだ。例えば型アノテーションついていればソースコードの時点でわかるが、付けずに型推論に任せていれば、typed-ASTにまで頭を巡らせないとわからない。</p><p>変数の参照はどうだろう。ソースコードなことが望ましい（lexical scope）けどそうじゃない困った言語もある。</p><p>いろんな概念があるが、なんにしても、早い段階でわかったほうが嬉しいことが多いだろう。でも一方でそれをわかあるためにプログラマがコンパイラの代わりをするのは非人道的だ。型アノテーションは大切だけど型推論を邪魔者扱いする人はいない（いないよね？）。これ以上具体的なことは言語の意味論によるだろう。HaskellとSchemeを同じ土俵で議論するのは大変そう。</p></p></div><div class=post-footer><p><time>2022-04-16 UTC</time>
lastmod: <time>2024-10-06 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/2022/march/intro-cs/>読書感想: 入門 コンピュータ科学</a></h1><div><p><p>本をざっくり読んだので感想をメモ。読んでよかった。</p><p>読んだ本: <a href="https://www.amazon.co.jp/%E5%85%A5%E9%96%80-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E7%A7%91%E5%AD%A6-IT%E3%82%92%E6%94%AF%E3%81%88%E3%82%8B%E6%8A%80%E8%A1%93%E3%81%A8%E7%90%86%E8%AB%96%E3%81%AE%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98-J-Glenn-Brookshear/dp/4048930540/ref=sr_1_1?keywords=%E5%85%A5%E9%96%80%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E7%A7%91%E5%AD%A6&amp;qid=1648263011&amp;sprefix=%E5%85%A5%E9%96%80%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%2Caps%2C296&amp;sr=8-1">入門 コンピュータ科学</a>。</p><h2><a href=#%e6%84%9f%e6%83%b3 id=感想 class=anchor aria-hidden=true>感想</a></h2><p>おそらく情報工学科の学部で扱うであろう内容をまとめた本。プログラミングはしないけど、それ以外の座学は大体ざっくりまとまっていそう。僕は情報工学科の講義をとっていないので、真偽はわからないのだけど。あくまで内容はざっくりしていて、専門的な内容は省かれている感じ。インターネットとはとか、データベースとは、プログラミング言語とは、みたいなことが書かれていて、それぞれの難しさを指摘するところまでを解説してくれる。技術の実装方法や難しさの解決策とかは扱わない感じ（だったはず）。CS関連で知らないことが出てきた時に、どの辺を勉強すれば良いかの手がかりとなる概観を与えてくれたんだと思う。</p><p>この本を読んで、データベースとインターネットについてざっくりとした理解を得た。手を動かしつつ、必要に応じて勉強できそうだと思う。情報系の学部出身と言ったら、このくらいは完全に理解していて、さらに専門的なところまでいけることを社会から期待されている気がする。どのあたりの知見が僕に欠けているかを（多分）理解できたし、足りていなかったところをある程度補完できた。</p><h2><a href=#%e4%bd%99%e8%ab%871-%e5%83%95%e3%81%ae%e3%83%90%e3%83%83%e3%82%af%e3%82%b0%e3%83%a9%e3%82%a6%e3%83%b3%e3%83%89 id=余談1-僕のバックグラウンド class=anchor aria-hidden=true>余談1: 僕のバックグラウンド</a></h2><p>上の感想文を書いて、僕のバックグラウンドに疑問を抱く人がいるかもしれないと思ったので説明しておく。</p><p>僕は情報科学科（数理・計算科学系）の出身でコンピュータサイエンスを一応専攻してきた。ただ、CSだけじゃなくて統計や数学も学科が扱う範囲に入っていて、例えば確率論の基礎（σ加法族とかから初めて中心極限定理まで）とか集合と位相（和集合演算というのは&mldr;とかから濃度、ベルンシュタインの定理、選択公理をみて、位相論では分離公理（だったっけ？）とか連続性を扱った。付録的な立ち位置だったけど、有理数全体の集合を距離空間として見たとき、それを完備化して実数を構成する様も追った。）。これらは学部2年の話で、他にも色々講義があった。その傍でCSの講義も開講されていた感じなので、ある程度カルキュラムから端折ったCSの内容があったのだろうと思う。統計や数学の人からしても、端折った箇所があったと感じてるのではないかと想像する。数学か行くべきと発言していた人もいる。そういうわけで、今回本を読んで知識を補完できてよかったと思った。</p><p>学科の選択に後悔はなくて、色々楽しそうな領域を見て、そうでもないかなと判断できた。その中で生き残った楽しい領域で今勉強しているのだから、とりあえず満足。なんならプログラムングなんてしたくないと、学部3年の終わりまで思っていたし。</p><h2><a href=#%e4%bd%99%e8%ab%872-%e5%ad%a6%e9%83%a8%e3%81%ae%e8%ac%9b%e7%be%a9%e3%81%a8%e6%95%99%e7%a7%91%e6%9b%b8%e8%ac%9b%e7%be%a9%e8%b3%87%e6%96%99%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6 id=余談2-学部の講義と教科書講義資料について class=anchor aria-hidden=true>余談2: 学部の講義と教科書/講義資料について</a></h2><p>学部の授業で講義資料を作るのやめて、こういう教科書を指定するのが学生のためだと思う。講義資料を作るのは先生の自己満足なのだろうか。先生にとっては勉強になるだろうが、学生からすると比較的完成度の低い資料を与えられて、成績のためにそれに従った勉強を強いられる。授業内容は先生の専門になるほど細かいことではなく、多くの人が知っている教養的な内容なのだから、信頼できる文献を学生に与えることが教える側の責任の取り方なんじゃないかと思う。教科書を用いて講義を進めることにどんな問題があるのだろうか。</p><p>本を読むときに、人から与えられて読むか、自分で発見して読むかによって学習のモチベーションは大きく変わる。人から与えられた時には粗が気になるが、自分で読む時に美点に目がつく傾向がある。もちろん白黒はっきり分かれるわけではなくて、どちらかというと、くらいのふんわりとした傾向でしかないけど。その辺りを気にして良い教科書を紹介しないで、やる気のある人が自分で発見する機会をとっておくために自作の講義資料を使う、とか？</p><p>そうだとしたら、その判断は微妙に感じる。講義で一回目を通して、その時は読む気が起きなかった教科書も、後々（数ヶ月、1、2年後）に読み返すことは少なくない。その時には自分で発見して読むときと同じようなモチベーションで僕は読める。そういうわけで、良い本を知らずに過ごすリスクを減らすためにやはり先生には紹介してほしいと思う。それも、ただタイトルと概要を述べるだけではなく、実際に授業で本の中身を扱うことで内容を学生にわからせてほしい。</p><p>教訓:</p><ul><li>良い論文とか文献は積極的に紹介する。</li><li>紹介する時には、内容まである程度紹介するとよい。</li></ul><p>今回は読書感想文なので読んだ本の内容は紹介しない。ここでCS概論述べてもしょうがないし。僕みたいな人間がこの本を読んでどういうふうに良いと思ったかをメモすることで、似た境遇の人とかの助けになれば良いな、という程度のモチベーションでした。</p></p></div><div class=post-footer><p><time>2022-03-26 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article><article><h1><a href=https://blog.nfurudono.com/posts/2022/march/my-first-post/>My First Post</a></h1><div><p><h2><a href=#hello-hugo-and-github-pages id=hello-hugo-and-github-pages class=anchor aria-hidden=true>Hello, Hugo and GitHub Pages</a></h2><p>このサイトはHugoとGitHub Pagesを用いて運用しています。これらとGitHub Actionを組み合わせることで、マークダウンで記事を書いてGitHubにpushするだけで更新できるブログを構築しています。
Hugoは静的サイトジェネレータの一つで、設定を済ませたあとは、マークダウンで記事を書くことでコマンド一発でWebページのソースを生成してくれます。
GitHub PagesはGitHubに保存したコンテンツをWebページとして配信してくれるサービスです。</p><p>この構成は僕のアイデアではなくて、いろいろな人が手順を紹介してくれています。僕が参考にした記事を以下に紹介します。</p><ul><li><dl><dt><a href=https://gohugo.io/hosting-and-deployment/hosting-on-github/>Hugo on GitHub</a></dt><dd>GitHub Actionを用いたHugoの運用方法を解説しているドキュメントです。記載の方法に従うことで、mainブランチにmarkdownを書き、gh-pagesブランチに配布するためのHTMLなどを自動で生成できるようになります。</dd></dl></li><li><dl><dt><a href=https://gohugo.io/getting-started/quick-start/>Quick Start Hugo</a></dt><dd>Hugoの始め方。Hugoのインストールからlocalhost経由でのサイト表示の確認までを教えてくれます。</dd></dl></li></ul></p></div><div class=post-footer><p><time>2022-03-23 +0900</time>
lastmod: <time>2023-03-30 +0900</time></p></div></article></div></div><footer class=footer-mobile><div class=social-icons><a class=social-icon href=https://twitter.com/furudono2 target=_blank rel=noopener title=Twitter><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M8.991284 24.971612c10.189152.0 15.761088-8.441388 15.761088-15.761088C24.752372 8.970656 24.747512 8.731868 24.736496 8.494376 25.818008 7.712564 26.758256 6.737 27.5 5.62622c-.992628.440856-2.060748.738072-3.181248.871992 1.14372-.685584 2.02176-1.770768 2.435832-3.064176-1.070496.6345-2.25558 1.095984-3.517344 1.344492-1.010772-1.076652-2.450412-1.75014-4.043412-1.75014-3.059424.0-5.540292 2.480868-5.540292 5.539104.0.434808.0487079999999995.857412.14364 1.26306C9.19346 9.599108 5.11106 7.39472 2.3792 4.04294c-.476172.818424-.750168 1.769688-.750168 2.784132.0 1.921968.97794 3.61854 2.464992 4.61106C3.185528 11.41016 2.331788 11.160464 1.585184 10.745096 1.583888 10.768208 1.583888 10.791428 1.583888 10.815728c0 2.683152 1.909764 4.922856 4.4442 5.43078C5.562932 16.373084 5.07326 16.44134 4.56782 16.44134 4.210988 16.44134 3.863876 16.406024 3.526484 16.34144c.70524 2.200824 2.750112 3.802356 5.174928 3.8475-1.896264 1.485756-4.284576 2.37114-6.879924 2.37114C1.374476 22.56008.93362 22.534592.5 22.4834c2.451708 1.571076 5.362524 2.488212 8.491284 2.488212"/></svg>
</a><a class=social-icon href=https://www.instagram.com/donofuru/ target=_blank rel=noopener title=Instagram><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M14.0000238 2.00378571c3.2579524.0 3.6664762.0138095300000001 4.946.0721904800000002C20.222881 2.13421429 21.0949286 2.33702381 21.8579762 2.63359524 22.6468333 2.94011905 23.3158333 3.35030952 23.9827857 4.01721429 24.6496905 4.68416667 25.059881 5.35316667 25.3664524 6.14202381 25.6629762 6.90507143 25.8657857 7.77711905 25.9240238 9.05397619 25.9824048 10.3335 25.9962143 10.7420238 25.9962143 14.0000238 25.9962143 17.2579762 25.9824048 17.6665 25.9240238 18.9460238 25.8657857 20.222881 25.6629762 21.0949286 25.3664524 21.8579762 25.059881 22.6468333 24.6496905 23.3158333 23.9827857 23.9827857 23.3158333 24.6496905 22.6468333 25.059881 21.8579762 25.3664524 21.0949286 25.6629762 20.222881 25.8657857 18.9460238 25.9240238 17.6665 25.9824048 17.2579762 25.9962143 14.0000238 25.9962143 10.7420238 25.9962143 10.3335 25.9824048 9.05397619 25.9240238 7.77711905 25.8657857 6.90507143 25.6629762 6.14202381 25.3664524 5.35316667 25.059881 4.68416667 24.6496905 4.01721429 23.9827857c-.66690477-.6669524-1.07709524-1.3359524-1.38361905-2.1248095-.29657143-.7630476-.49938095-1.6350952-.55761905-2.9119524C2.01759524 17.6665 2.00378571 17.2579762 2.00378571 14.0000238 2.00378571 10.7420238 2.01759524 10.3335 2.07597619 9.05397619 2.13421429 7.77711905 2.33702381 6.90507143 2.63359524 6.14202381c.30652381-.78885714.71671428-1.45785714 1.38361905-2.12480952.66695238-.66690477 1.33595238-1.07709524 2.12480952-1.38361905C6.90507143 2.33702381 7.77711905 2.13421429 9.05397619 2.07597619 10.3335 2.01759524 10.7420238 2.00378571 14.0000238 2.00378571zm0 2.16147619C10.796881 4.1652619 10.4174524 4.1775 9.1525 4.23521429 7.98288095 4.28854762 7.34769048 4.48397619 6.92497619 4.6482619 6.36502381 4.86588095 5.96540476 5.12583333 5.54564286 5.54564286c-.41980953.4197619-.67976191.81938095-.89738096 1.37933333-.16428571.42271429-.35971428 1.05790476-.41304761 2.22752381C4.1775 10.4174524 4.1652619 10.796881 4.1652619 14.0000238 4.1652619 17.203119 4.1775 17.5825476 4.23521429 18.8475 4.28854762 20.017119 4.48397619 20.6523095 4.6482619 21.0750238 4.86588095 21.6349762 5.12588095 22.0345952 5.54564286 22.4543571 5.96540476 22.8741667 6.36502381 23.134119 6.92497619 23.3517381 7.34769048 23.5160238 7.98288095 23.7114524 9.1525 23.7647857 10.4173095 23.8225 10.7966429 23.8347381 14.0000238 23.8347381 17.2033571 23.8347381 17.5827381 23.8225 18.8475 23.7647857 20.017119 23.7114524 20.6523095 23.5160238 21.0750238 23.3517381 21.6349762 23.134119 22.0345952 22.8741667 22.4543571 22.4543571 22.8741667 22.0345952 23.134119 21.6349762 23.3517381 21.0750238 23.5160238 20.6523095 23.7114524 20.017119 23.7647857 18.8475 23.8225 17.5825476 23.8347381 17.203119 23.8347381 14.0000238 23.8347381 10.796881 23.8225 10.4174524 23.7647857 9.1525 23.7114524 7.98288095 23.5160238 7.34769048 23.3517381 6.92497619 23.134119 6.36502381 22.8741667 5.96540476 22.4543571 5.54564286 22.0345952 5.12583333 21.6349762 4.86588095 21.0750238 4.6482619 20.6523095 4.48397619 20.017119 4.28854762 18.8475 4.23521429 17.5825476 4.1775 17.203119 4.1652619 14.0000238 4.1652619zm0 13.8334762c2.2084286.0 3.9987143-1.7902857 3.9987143-3.9987143.0-2.2084762-1.7902857-3.9987619-3.9987143-3.9987619-2.2084762.0-3.9987619 1.7902857-3.9987619 3.9987619.0 2.2084286 1.7902857 3.9987143 3.9987619 3.9987143zm0-10.15895239c3.4021905.0 6.1601905 2.75799999 6.1601905 6.16023809.0 3.4021905-2.758 6.1601905-6.1601905 6.1601905-3.4022381.0-6.16023809-2.758-6.16023809-6.1601905.0-3.4022381 2.75799999-6.16023809 6.16023809-6.16023809zm7.8431429-.24338095c0 .79504762-.644523800000002 1.43952381-1.4395715 1.43952381C19.6085952 9.03592857 18.9640714 8.39145238 18.9640714 7.59640476S19.6085952 6.15683333 20.4035952 6.15683333c.795047699999998.0 1.4395715.64452381 1.4395715 1.43957143z"/></svg>
</a><a class=social-icon href=https://www.linkedin.com/in/naoya-furudono target=_blank rel=noopener title=LinkedIn><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M2 3.654102c0-.95502059.79442509-1.73012354 1.77383592-1.73012354H24.2261641C25.2058917 1.92397846 26 2.69908141 26 3.654102V24.3462148C26 25.3015521 25.2058917 26.0760215 24.2261641 26.0760215H3.77383592C2.79442509 26.0760215 2 25.3015521 2 24.3465315V3.65378524 3.654102zM9.27526132 22.1415901V11.2356668H5.65030092V22.1415901H9.27557808 9.27526132zM7.46341463 9.74691162c1.2638581.0 2.05068103-.83750395 2.05068103-1.88406715C9.49033893 6.79252455 8.72727273 5.97846056 7.48748812 5.97846056c-1.24073487.0-2.05099778.81406399-2.05099778 1.88438391.0 1.0465632.78650618 1.88406715 2.00316756 1.88406715h.02343998H7.46341463zM11.2815965 22.1415901h3.6246436v-6.089642C14.9062401 15.7263225 14.9299968 15.4000634 15.0256573 15.1675641c.261957499999999-.6515679.8584099-1.3259423 1.8599936-1.3259423 1.3113716.0 1.836237 1 1.836237 2.4662654v5.8337029h3.6246436V15.8885017c0-3.349699-1.7880899-4.9084574-4.172949-4.9084574-1.9553373.0-2.814064 1.0928097-3.2910991 1.8371872H14.9065569v-1.581248H11.2819132C11.3291099 12.2591067 11.2815965 22.1419069 11.2815965 22.1419069V22.1415901z"/></svg>
</a><a class=social-icon href=https://github.com/naoyafurudono target=_blank rel=noopener title=GitHub><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M13.9988029 1.32087331C6.82105037 1.32087331 1 7.14112562 1 14.3212723c0 5.7436386 3.72454649 10.6157955 8.89038951 12.3348169C10.5408085 26.7757983 10.7778323 26.374374 10.7778323 26.0296121 10.7778323 25.7215609 10.7666595 24.9035493 10.760275 23.8189856 7.14426471 24.6042767 6.38131925 22.0760223 6.38131925 22.0760223c-.59136253-1.5019491-1.44369072-1.9017772-1.44369072-1.9017772C3.75729765 19.3682044 5.02701126 19.3841656 5.02701126 19.3841656 6.33183953 19.4759425 7.01817121 20.7241085 7.01817121 20.7241085c1.15958133 1.9863716 3.04300319 1.4125664 3.78360289 1.0797753.1181129-.8395592.4540962-1.4125663.8251942-1.7373768C8.74038491 19.7385043 5.70536235 18.6228163 5.70536235 13.6413251c0-1.4189508.50676816-2.5801283 1.33834679-3.4883207C6.90963504 9.82420367 6.46351945 8.50181809 7.17139875 6.71256734c0 0 1.09094816-.34955032 3.57451115 1.33276037C11.78259 7.75642995 12.8950858 7.61277914 14.000399 7.60719272 15.1049142 7.61277914 16.2166119 7.75642995 17.2548881 8.04532771c2.4819669-1.68231069 3.571319-1.33276037 3.571319-1.33276037C21.5356825 8.50181809 21.0895669 9.82420367 20.9562909 10.1530044 21.7894656 11.0611968 22.2922435 12.2223743 22.2922435 13.6413251c0 4.9942601-3.039811 6.0931889-5.935173 6.4148071.4660671.401424200000001.8818564 1.194696.8818564 2.4077473C17.2389269 24.2012564 17.2229657 25.603448 17.2229657 26.0296121 17.2229657 26.3775663 17.4575954 26.7821827 18.116793 26.6552912 23.2786458 24.9322794 27 20.0633148 27 14.3212723 27 7.14112562 21.1789496 1.32087331 13.9988029 1.32087331"/></svg></a></div><div class=footer-mobile-links><p><a href=https://github.com/naoyafurudono/naoyafurudono.github.io target=_blank rel=noopener>Source of
this site</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener></a></p><p>©2025 Naoya Furudono</p></div><script src=https://blog.nfurudono.com/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script><a target=_blank rel="noopener noreferrer" href=https://github.com/naoyafurudono/naoyafurudono.github.io/actions><img src=https://github.com/naoyafurudono/naoyafurudono.github.io/actions/workflows/gh-pages.yml/badge.svg alt="github pages deploy status" style=max-width:100%></a><p><a href="https://www.amazon.jp/hz/wishlist/ls/1JBRXP4JZZ21T?ref_=wl_share">欲しい本リスト</a></p><p><a href="https://www.amazon.jp/hz/wishlist/ls/3TT5GR81VZPHP?ref_=wl_share">欲しいものリスト</a></p></footer></body></html>