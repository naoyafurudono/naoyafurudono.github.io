<!doctype html><html lang=ja-jp><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>構文エディタ実装の考え | nfurudono</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="構文エディタとは、文字単位だけでなく抽象構文木単位での編集ができるエディタのこと。 一般のコードでなく、プログラムを編集することは抽象構文木のノードやエッジの編集に対応する。 ならば、そういう単位での編集をエディタが直接サポートすれば楽できるという発想（だと想像する）。
アイデアとしてはそれらしい気がする。でも流行ってるようには見えない。 なんでか？
 需要が少ない: プログラムを新しく書くことは構文エディタの対象外であり、プログラムがあってそれに対する選択が主な操作である。なので構文じゃない編集機能はやはり必要で、そう考えるとそんなに欲しくない。とか？ 使い勝手が悪い: 使ったことがないし、具体的な機能を知らないので想像でしかないけど、おそらく思ったようにASTのノードを選択できないのではないか？そもそも選択したい「ASTのノード」が実は存在しないケースがある。(e1;e2;e3)のうち、e1;e2とe2;e3のどちらかは存在しないはず。この辺りの問題は工夫すれば解決できそう。既存の実装はどのくらい工夫しているのだろうか。 普通のエディタで十分: 前の/次のセミコロンまでジャンプとか、かっこまでジャンプとかがあれば済むケースは多い。 実装が大変: 使い勝手を考えるとシンタックスハイライトとかよりは大変そう。抽象構文木をアレンジした概念が必要になりそう。  実装の話は Lisp なら簡単か。かっこを上手に扱う機能が入ればあとは普通のエディタの機能でほとんど構文エディタになる。
逆にシンタックスを弄りやすくして、普通のエディタが構文エディタ的な振る舞いをできるようにするのはどうだろう？Haskellはいい線いってる？文を消す <&ndash;> 行を消すの対応をほとんどの言語でしているので多かれ少なかれそういう側面がある。究極的にはどこまでいけるだろうか？ エディタの基本操作は一文字入力/削除か。Vimでできることに広げるとどうだろうか。
関連して、エディタの話の制限を忘れて、言語デザインと使い勝手を考えたい。 ソースコード &ndash;> AST &ndash;> typed-AST &ndash;> 実行結果 くらいの段階がプログラマが交流しうるプログラムの表現だろう（実行結果が入るのは理論的じゃないかもだけど、気持ちとしては入るはず。みんな実行のことを考えてプログラムを書くのだから）。
プログラムの概念は色々あるが、それらは必ず上のどこかの概念として捉えることができる。 プログラムの挙動は実行時のことだし、行数はソースコードのこと。では型は？ typed-ASTかそれよりも前のどこかだ。例えば型アノテーションついていればソースコードの時点でわかるが、付けずに型推論に任せていれば、typed-ASTにまで頭を巡らせないとわからない。
変数の参照はどうだろう。ソースコードなことが望ましい（lexical scope）けどそうじゃない困った言語もある。
いろんな概念があるが、なんにしても、早い段階でわかったほうが嬉しいことが多いだろう。 でも一方でそれをわかあるためにプログラマがコンパイラの代わりをするのは非人道的だ。 型アノテーションは大切だけど型推論を邪魔者扱いする人はいない（いないよね？）。 これ以上具体的なことは言語の意味論によるだろう。HaskellとSchemeを同じ土俵で議論するのは大変そう。"><meta name=generator content="Hugo 0.97.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="構文エディタ実装の考え"><meta property="og:description" content="構文エディタとは、文字単位だけでなく抽象構文木単位での編集ができるエディタのこと。 一般のコードでなく、プログラムを編集することは抽象構文木のノードやエッジの編集に対応する。 ならば、そういう単位での編集をエディタが直接サポートすれば楽できるという発想（だと想像する）。
アイデアとしてはそれらしい気がする。でも流行ってるようには見えない。 なんでか？
 需要が少ない: プログラムを新しく書くことは構文エディタの対象外であり、プログラムがあってそれに対する選択が主な操作である。なので構文じゃない編集機能はやはり必要で、そう考えるとそんなに欲しくない。とか？ 使い勝手が悪い: 使ったことがないし、具体的な機能を知らないので想像でしかないけど、おそらく思ったようにASTのノードを選択できないのではないか？そもそも選択したい「ASTのノード」が実は存在しないケースがある。(e1;e2;e3)のうち、e1;e2とe2;e3のどちらかは存在しないはず。この辺りの問題は工夫すれば解決できそう。既存の実装はどのくらい工夫しているのだろうか。 普通のエディタで十分: 前の/次のセミコロンまでジャンプとか、かっこまでジャンプとかがあれば済むケースは多い。 実装が大変: 使い勝手を考えるとシンタックスハイライトとかよりは大変そう。抽象構文木をアレンジした概念が必要になりそう。  実装の話は Lisp なら簡単か。かっこを上手に扱う機能が入ればあとは普通のエディタの機能でほとんど構文エディタになる。
逆にシンタックスを弄りやすくして、普通のエディタが構文エディタ的な振る舞いをできるようにするのはどうだろう？Haskellはいい線いってる？文を消す <&ndash;> 行を消すの対応をほとんどの言語でしているので多かれ少なかれそういう側面がある。究極的にはどこまでいけるだろうか？ エディタの基本操作は一文字入力/削除か。Vimでできることに広げるとどうだろうか。
関連して、エディタの話の制限を忘れて、言語デザインと使い勝手を考えたい。 ソースコード &ndash;> AST &ndash;> typed-AST &ndash;> 実行結果 くらいの段階がプログラマが交流しうるプログラムの表現だろう（実行結果が入るのは理論的じゃないかもだけど、気持ちとしては入るはず。みんな実行のことを考えてプログラムを書くのだから）。
プログラムの概念は色々あるが、それらは必ず上のどこかの概念として捉えることができる。 プログラムの挙動は実行時のことだし、行数はソースコードのこと。では型は？ typed-ASTかそれよりも前のどこかだ。例えば型アノテーションついていればソースコードの時点でわかるが、付けずに型推論に任せていれば、typed-ASTにまで頭を巡らせないとわからない。
変数の参照はどうだろう。ソースコードなことが望ましい（lexical scope）けどそうじゃない困った言語もある。
いろんな概念があるが、なんにしても、早い段階でわかったほうが嬉しいことが多いだろう。 でも一方でそれをわかあるためにプログラマがコンパイラの代わりをするのは非人道的だ。 型アノテーションは大切だけど型推論を邪魔者扱いする人はいない（いないよね？）。 これ以上具体的なことは言語の意味論によるだろう。HaskellとSchemeを同じ土俵で議論するのは大変そう。"><meta property="og:type" content="article"><meta property="og:url" content="https://naoyafurudono.github.io/posts/2022/april/syntacticalz-editor/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-16T00:00:00+00:00"><meta property="article:modified_time" content="2022-04-16T00:00:00+00:00"><meta itemprop=name content="構文エディタ実装の考え"><meta itemprop=description content="構文エディタとは、文字単位だけでなく抽象構文木単位での編集ができるエディタのこと。 一般のコードでなく、プログラムを編集することは抽象構文木のノードやエッジの編集に対応する。 ならば、そういう単位での編集をエディタが直接サポートすれば楽できるという発想（だと想像する）。
アイデアとしてはそれらしい気がする。でも流行ってるようには見えない。 なんでか？
 需要が少ない: プログラムを新しく書くことは構文エディタの対象外であり、プログラムがあってそれに対する選択が主な操作である。なので構文じゃない編集機能はやはり必要で、そう考えるとそんなに欲しくない。とか？ 使い勝手が悪い: 使ったことがないし、具体的な機能を知らないので想像でしかないけど、おそらく思ったようにASTのノードを選択できないのではないか？そもそも選択したい「ASTのノード」が実は存在しないケースがある。(e1;e2;e3)のうち、e1;e2とe2;e3のどちらかは存在しないはず。この辺りの問題は工夫すれば解決できそう。既存の実装はどのくらい工夫しているのだろうか。 普通のエディタで十分: 前の/次のセミコロンまでジャンプとか、かっこまでジャンプとかがあれば済むケースは多い。 実装が大変: 使い勝手を考えるとシンタックスハイライトとかよりは大変そう。抽象構文木をアレンジした概念が必要になりそう。  実装の話は Lisp なら簡単か。かっこを上手に扱う機能が入ればあとは普通のエディタの機能でほとんど構文エディタになる。
逆にシンタックスを弄りやすくして、普通のエディタが構文エディタ的な振る舞いをできるようにするのはどうだろう？Haskellはいい線いってる？文を消す <&ndash;> 行を消すの対応をほとんどの言語でしているので多かれ少なかれそういう側面がある。究極的にはどこまでいけるだろうか？ エディタの基本操作は一文字入力/削除か。Vimでできることに広げるとどうだろうか。
関連して、エディタの話の制限を忘れて、言語デザインと使い勝手を考えたい。 ソースコード &ndash;> AST &ndash;> typed-AST &ndash;> 実行結果 くらいの段階がプログラマが交流しうるプログラムの表現だろう（実行結果が入るのは理論的じゃないかもだけど、気持ちとしては入るはず。みんな実行のことを考えてプログラムを書くのだから）。
プログラムの概念は色々あるが、それらは必ず上のどこかの概念として捉えることができる。 プログラムの挙動は実行時のことだし、行数はソースコードのこと。では型は？ typed-ASTかそれよりも前のどこかだ。例えば型アノテーションついていればソースコードの時点でわかるが、付けずに型推論に任せていれば、typed-ASTにまで頭を巡らせないとわからない。
変数の参照はどうだろう。ソースコードなことが望ましい（lexical scope）けどそうじゃない困った言語もある。
いろんな概念があるが、なんにしても、早い段階でわかったほうが嬉しいことが多いだろう。 でも一方でそれをわかあるためにプログラマがコンパイラの代わりをするのは非人道的だ。 型アノテーションは大切だけど型推論を邪魔者扱いする人はいない（いないよね？）。 これ以上具体的なことは言語の意味論によるだろう。HaskellとSchemeを同じ土俵で議論するのは大変そう。"><meta itemprop=datePublished content="2022-04-16T00:00:00+00:00"><meta itemprop=dateModified content="2022-04-16T00:00:00+00:00"><meta itemprop=wordCount content="38"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="構文エディタ実装の考え"><meta name=twitter:description content="構文エディタとは、文字単位だけでなく抽象構文木単位での編集ができるエディタのこと。 一般のコードでなく、プログラムを編集することは抽象構文木のノードやエッジの編集に対応する。 ならば、そういう単位での編集をエディタが直接サポートすれば楽できるという発想（だと想像する）。
アイデアとしてはそれらしい気がする。でも流行ってるようには見えない。 なんでか？
 需要が少ない: プログラムを新しく書くことは構文エディタの対象外であり、プログラムがあってそれに対する選択が主な操作である。なので構文じゃない編集機能はやはり必要で、そう考えるとそんなに欲しくない。とか？ 使い勝手が悪い: 使ったことがないし、具体的な機能を知らないので想像でしかないけど、おそらく思ったようにASTのノードを選択できないのではないか？そもそも選択したい「ASTのノード」が実は存在しないケースがある。(e1;e2;e3)のうち、e1;e2とe2;e3のどちらかは存在しないはず。この辺りの問題は工夫すれば解決できそう。既存の実装はどのくらい工夫しているのだろうか。 普通のエディタで十分: 前の/次のセミコロンまでジャンプとか、かっこまでジャンプとかがあれば済むケースは多い。 実装が大変: 使い勝手を考えるとシンタックスハイライトとかよりは大変そう。抽象構文木をアレンジした概念が必要になりそう。  実装の話は Lisp なら簡単か。かっこを上手に扱う機能が入ればあとは普通のエディタの機能でほとんど構文エディタになる。
逆にシンタックスを弄りやすくして、普通のエディタが構文エディタ的な振る舞いをできるようにするのはどうだろう？Haskellはいい線いってる？文を消す <&ndash;> 行を消すの対応をほとんどの言語でしているので多かれ少なかれそういう側面がある。究極的にはどこまでいけるだろうか？ エディタの基本操作は一文字入力/削除か。Vimでできることに広げるとどうだろうか。
関連して、エディタの話の制限を忘れて、言語デザインと使い勝手を考えたい。 ソースコード &ndash;> AST &ndash;> typed-AST &ndash;> 実行結果 くらいの段階がプログラマが交流しうるプログラムの表現だろう（実行結果が入るのは理論的じゃないかもだけど、気持ちとしては入るはず。みんな実行のことを考えてプログラムを書くのだから）。
プログラムの概念は色々あるが、それらは必ず上のどこかの概念として捉えることができる。 プログラムの挙動は実行時のことだし、行数はソースコードのこと。では型は？ typed-ASTかそれよりも前のどこかだ。例えば型アノテーションついていればソースコードの時点でわかるが、付けずに型推論に任せていれば、typed-ASTにまで頭を巡らせないとわからない。
変数の参照はどうだろう。ソースコードなことが望ましい（lexical scope）けどそうじゃない困った言語もある。
いろんな概念があるが、なんにしても、早い段階でわかったほうが嬉しいことが多いだろう。 でも一方でそれをわかあるためにプログラマがコンパイラの代わりをするのは非人道的だ。 型アノテーションは大切だけど型推論を邪魔者扱いする人はいない（いないよね？）。 これ以上具体的なことは言語の意味論によるだろう。HaskellとSchemeを同じ土俵で議論するのは大変そう。"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">nfurudono</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">構文エディタ実装の考え</h1><time class="f6 mv4 dib tracked" datetime=2022-04-16T00:00:00Z>April 16, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>構文エディタとは、文字単位だけでなく抽象構文木単位での編集ができるエディタのこと。
一般のコードでなく、プログラムを編集することは抽象構文木のノードやエッジの編集に対応する。
ならば、そういう単位での編集をエディタが直接サポートすれば楽できるという発想（だと想像する）。</p><p>アイデアとしてはそれらしい気がする。でも流行ってるようには見えない。
なんでか？</p><ul><li>需要が少ない:
プログラムを新しく書くことは構文エディタの対象外であり、プログラムがあってそれに対する選択が主な操作である。なので構文じゃない編集機能はやはり必要で、そう考えるとそんなに欲しくない。とか？</li><li>使い勝手が悪い:
使ったことがないし、具体的な機能を知らないので想像でしかないけど、おそらく思ったようにASTのノードを選択できないのではないか？そもそも選択したい「ASTのノード」が実は存在しないケースがある。<code>(e1;e2;e3)</code>のうち、<code>e1;e2</code>と<code>e2;e3</code>のどちらかは存在しないはず。この辺りの問題は工夫すれば解決できそう。既存の実装はどのくらい工夫しているのだろうか。</li><li>普通のエディタで十分:
前の/次のセミコロンまでジャンプとか、かっこまでジャンプとかがあれば済むケースは多い。</li><li>実装が大変:
使い勝手を考えるとシンタックスハイライトとかよりは大変そう。抽象構文木をアレンジした概念が必要になりそう。</li></ul><p>実装の話は Lisp なら簡単か。かっこを上手に扱う機能が入ればあとは普通のエディタの機能でほとんど構文エディタになる。</p><p>逆にシンタックスを弄りやすくして、普通のエディタが構文エディタ的な振る舞いをできるようにするのはどうだろう？Haskellはいい線いってる？文を消す &lt;&ndash;> 行を消すの対応をほとんどの言語でしているので多かれ少なかれそういう側面がある。究極的にはどこまでいけるだろうか？
エディタの基本操作は一文字入力/削除か。Vimでできることに広げるとどうだろうか。</p><p>関連して、エディタの話の制限を忘れて、言語デザインと使い勝手を考えたい。
ソースコード &ndash;> AST &ndash;> typed-AST &ndash;> 実行結果 くらいの段階がプログラマが交流しうるプログラムの表現だろう（実行結果が入るのは理論的じゃないかもだけど、気持ちとしては入るはず。みんな実行のことを考えてプログラムを書くのだから）。</p><p>プログラムの概念は色々あるが、それらは必ず上のどこかの概念として捉えることができる。
プログラムの挙動は実行時のことだし、行数はソースコードのこと。では型は？
typed-ASTかそれよりも前のどこかだ。例えば型アノテーションついていればソースコードの時点でわかるが、付けずに型推論に任せていれば、typed-ASTにまで頭を巡らせないとわからない。</p><p>変数の参照はどうだろう。ソースコードなことが望ましい（lexical scope）けどそうじゃない困った言語もある。</p><p>いろんな概念があるが、なんにしても、早い段階でわかったほうが嬉しいことが多いだろう。
でも一方でそれをわかあるためにプログラマがコンパイラの代わりをするのは非人道的だ。
型アノテーションは大切だけど型推論を邪魔者扱いする人はいない（いないよね？）。
これ以上具体的なことは言語の意味論によるだろう。HaskellとSchemeを同じ土俵で議論するのは大変そう。</p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://naoyafurudono.github.io>&copy; nfurudono 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>