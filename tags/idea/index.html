<!doctype html><html lang=ja><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>Idea | ツイートするには長すぎる</title><link rel=apple-touch-icon sizes=57x57 href=/images/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/images/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/images/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/images/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/images/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/images/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/images/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/images/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/images/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/images/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=manifest href=/images/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/images/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><meta property="og:url" content="https://blog.nfurudono.com/tags/idea/"><meta property="og:site_name" content="ツイートするには長すぎる"><meta property="og:title" content="Idea"><meta property="og:locale" content="ja"><meta property="og:type" content="website"><meta property="og:image" content="https://blog.nfurudono.com/images/thumbnail.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.nfurudono.com/images/thumbnail.png"><meta name=twitter:title content="Idea"><meta name=description content="Ideaに関連する記事の一覧です。"><meta property="og:description" content="Ideaに関連する記事の一覧です。"><meta name=twitter:description content="Ideaに関連する記事の一覧です。"><link rel=stylesheet href=https://blog.nfurudono.com/css/main.min.680546ad85e4ae010fb2c6d6e29f48227e146cc09f57f4dc75b7ae0782d1139e.css><link rel=alternate type=application/rss+xml href=https://blog.nfurudono.com/tags/idea/index.xml title=ツイートするには長すぎる><script async src="https://www.googletagmanager.com/gtag/js?id=G-ES42FPF4D5"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ES42FPF4D5")}</script></head><body><nav><header><div class=site-title><a href=/>ツイートするには長すぎる</a></div></header><div class=nav-menu><a class="color-link nav-link" href=/profile/>Profile</a>
<a class="color-link nav-link" href=/tags/>Tags</a>
<a class="color-link nav-link" href=/about/>about</a>
<a class="color-link nav-link" href=/tags/idea/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons><a class=social-icon href=https://twitter.com/furudono2 target=_blank rel=noopener title=Twitter><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M8.991284 24.971612c10.189152.0 15.761088-8.441388 15.761088-15.761088C24.752372 8.970656 24.747512 8.731868 24.736496 8.494376 25.818008 7.712564 26.758256 6.737 27.5 5.62622c-.992628.440856-2.060748.738072-3.181248.871992 1.14372-.685584 2.02176-1.770768 2.435832-3.064176-1.070496.6345-2.25558 1.095984-3.517344 1.344492-1.010772-1.076652-2.450412-1.75014-4.043412-1.75014-3.059424.0-5.540292 2.480868-5.540292 5.539104.0.434808.0487079999999995.857412.14364 1.26306C9.19346 9.599108 5.11106 7.39472 2.3792 4.04294c-.476172.818424-.750168 1.769688-.750168 2.784132.0 1.921968.97794 3.61854 2.464992 4.61106C3.185528 11.41016 2.331788 11.160464 1.585184 10.745096 1.583888 10.768208 1.583888 10.791428 1.583888 10.815728c0 2.683152 1.909764 4.922856 4.4442 5.43078C5.562932 16.373084 5.07326 16.44134 4.56782 16.44134 4.210988 16.44134 3.863876 16.406024 3.526484 16.34144c.70524 2.200824 2.750112 3.802356 5.174928 3.8475-1.896264 1.485756-4.284576 2.37114-6.879924 2.37114C1.374476 22.56008.93362 22.534592.5 22.4834c2.451708 1.571076 5.362524 2.488212 8.491284 2.488212"/></svg>
</a><a class=social-icon href=https://www.instagram.com/donofuru/ target=_blank rel=noopener title=Instagram><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M14.0000238 2.00378571c3.2579524.0 3.6664762.0138095300000001 4.946.0721904800000002C20.222881 2.13421429 21.0949286 2.33702381 21.8579762 2.63359524 22.6468333 2.94011905 23.3158333 3.35030952 23.9827857 4.01721429 24.6496905 4.68416667 25.059881 5.35316667 25.3664524 6.14202381 25.6629762 6.90507143 25.8657857 7.77711905 25.9240238 9.05397619 25.9824048 10.3335 25.9962143 10.7420238 25.9962143 14.0000238 25.9962143 17.2579762 25.9824048 17.6665 25.9240238 18.9460238 25.8657857 20.222881 25.6629762 21.0949286 25.3664524 21.8579762 25.059881 22.6468333 24.6496905 23.3158333 23.9827857 23.9827857 23.3158333 24.6496905 22.6468333 25.059881 21.8579762 25.3664524 21.0949286 25.6629762 20.222881 25.8657857 18.9460238 25.9240238 17.6665 25.9824048 17.2579762 25.9962143 14.0000238 25.9962143 10.7420238 25.9962143 10.3335 25.9824048 9.05397619 25.9240238 7.77711905 25.8657857 6.90507143 25.6629762 6.14202381 25.3664524 5.35316667 25.059881 4.68416667 24.6496905 4.01721429 23.9827857c-.66690477-.6669524-1.07709524-1.3359524-1.38361905-2.1248095-.29657143-.7630476-.49938095-1.6350952-.55761905-2.9119524C2.01759524 17.6665 2.00378571 17.2579762 2.00378571 14.0000238 2.00378571 10.7420238 2.01759524 10.3335 2.07597619 9.05397619 2.13421429 7.77711905 2.33702381 6.90507143 2.63359524 6.14202381c.30652381-.78885714.71671428-1.45785714 1.38361905-2.12480952.66695238-.66690477 1.33595238-1.07709524 2.12480952-1.38361905C6.90507143 2.33702381 7.77711905 2.13421429 9.05397619 2.07597619 10.3335 2.01759524 10.7420238 2.00378571 14.0000238 2.00378571zm0 2.16147619C10.796881 4.1652619 10.4174524 4.1775 9.1525 4.23521429 7.98288095 4.28854762 7.34769048 4.48397619 6.92497619 4.6482619 6.36502381 4.86588095 5.96540476 5.12583333 5.54564286 5.54564286c-.41980953.4197619-.67976191.81938095-.89738096 1.37933333-.16428571.42271429-.35971428 1.05790476-.41304761 2.22752381C4.1775 10.4174524 4.1652619 10.796881 4.1652619 14.0000238 4.1652619 17.203119 4.1775 17.5825476 4.23521429 18.8475 4.28854762 20.017119 4.48397619 20.6523095 4.6482619 21.0750238 4.86588095 21.6349762 5.12588095 22.0345952 5.54564286 22.4543571 5.96540476 22.8741667 6.36502381 23.134119 6.92497619 23.3517381 7.34769048 23.5160238 7.98288095 23.7114524 9.1525 23.7647857 10.4173095 23.8225 10.7966429 23.8347381 14.0000238 23.8347381 17.2033571 23.8347381 17.5827381 23.8225 18.8475 23.7647857 20.017119 23.7114524 20.6523095 23.5160238 21.0750238 23.3517381 21.6349762 23.134119 22.0345952 22.8741667 22.4543571 22.4543571 22.8741667 22.0345952 23.134119 21.6349762 23.3517381 21.0750238 23.5160238 20.6523095 23.7114524 20.017119 23.7647857 18.8475 23.8225 17.5825476 23.8347381 17.203119 23.8347381 14.0000238 23.8347381 10.796881 23.8225 10.4174524 23.7647857 9.1525 23.7114524 7.98288095 23.5160238 7.34769048 23.3517381 6.92497619 23.134119 6.36502381 22.8741667 5.96540476 22.4543571 5.54564286 22.0345952 5.12583333 21.6349762 4.86588095 21.0750238 4.6482619 20.6523095 4.48397619 20.017119 4.28854762 18.8475 4.23521429 17.5825476 4.1775 17.203119 4.1652619 14.0000238 4.1652619zm0 13.8334762c2.2084286.0 3.9987143-1.7902857 3.9987143-3.9987143.0-2.2084762-1.7902857-3.9987619-3.9987143-3.9987619-2.2084762.0-3.9987619 1.7902857-3.9987619 3.9987619.0 2.2084286 1.7902857 3.9987143 3.9987619 3.9987143zm0-10.15895239c3.4021905.0 6.1601905 2.75799999 6.1601905 6.16023809.0 3.4021905-2.758 6.1601905-6.1601905 6.1601905-3.4022381.0-6.16023809-2.758-6.16023809-6.1601905.0-3.4022381 2.75799999-6.16023809 6.16023809-6.16023809zm7.8431429-.24338095c0 .79504762-.644523800000002 1.43952381-1.4395715 1.43952381C19.6085952 9.03592857 18.9640714 8.39145238 18.9640714 7.59640476S19.6085952 6.15683333 20.4035952 6.15683333c.795047699999998.0 1.4395715.64452381 1.4395715 1.43957143z"/></svg>
</a><a class=social-icon href=https://www.linkedin.com/in/naoya-furudono target=_blank rel=noopener title=LinkedIn><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M2 3.654102c0-.95502059.79442509-1.73012354 1.77383592-1.73012354H24.2261641C25.2058917 1.92397846 26 2.69908141 26 3.654102V24.3462148C26 25.3015521 25.2058917 26.0760215 24.2261641 26.0760215H3.77383592C2.79442509 26.0760215 2 25.3015521 2 24.3465315V3.65378524 3.654102zM9.27526132 22.1415901V11.2356668H5.65030092V22.1415901H9.27557808 9.27526132zM7.46341463 9.74691162c1.2638581.0 2.05068103-.83750395 2.05068103-1.88406715C9.49033893 6.79252455 8.72727273 5.97846056 7.48748812 5.97846056c-1.24073487.0-2.05099778.81406399-2.05099778 1.88438391.0 1.0465632.78650618 1.88406715 2.00316756 1.88406715h.02343998H7.46341463zM11.2815965 22.1415901h3.6246436v-6.089642C14.9062401 15.7263225 14.9299968 15.4000634 15.0256573 15.1675641c.261957499999999-.6515679.8584099-1.3259423 1.8599936-1.3259423 1.3113716.0 1.836237 1 1.836237 2.4662654v5.8337029h3.6246436V15.8885017c0-3.349699-1.7880899-4.9084574-4.172949-4.9084574-1.9553373.0-2.814064 1.0928097-3.2910991 1.8371872H14.9065569v-1.581248H11.2819132C11.3291099 12.2591067 11.2815965 22.1419069 11.2815965 22.1419069V22.1415901z"/></svg>
</a><a class=social-icon href=https://github.com/naoyafurudono target=_blank rel=noopener title=GitHub><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M13.9988029 1.32087331C6.82105037 1.32087331 1 7.14112562 1 14.3212723c0 5.7436386 3.72454649 10.6157955 8.89038951 12.3348169C10.5408085 26.7757983 10.7778323 26.374374 10.7778323 26.0296121 10.7778323 25.7215609 10.7666595 24.9035493 10.760275 23.8189856 7.14426471 24.6042767 6.38131925 22.0760223 6.38131925 22.0760223c-.59136253-1.5019491-1.44369072-1.9017772-1.44369072-1.9017772C3.75729765 19.3682044 5.02701126 19.3841656 5.02701126 19.3841656 6.33183953 19.4759425 7.01817121 20.7241085 7.01817121 20.7241085c1.15958133 1.9863716 3.04300319 1.4125664 3.78360289 1.0797753.1181129-.8395592.4540962-1.4125663.8251942-1.7373768C8.74038491 19.7385043 5.70536235 18.6228163 5.70536235 13.6413251c0-1.4189508.50676816-2.5801283 1.33834679-3.4883207C6.90963504 9.82420367 6.46351945 8.50181809 7.17139875 6.71256734c0 0 1.09094816-.34955032 3.57451115 1.33276037C11.78259 7.75642995 12.8950858 7.61277914 14.000399 7.60719272 15.1049142 7.61277914 16.2166119 7.75642995 17.2548881 8.04532771c2.4819669-1.68231069 3.571319-1.33276037 3.571319-1.33276037C21.5356825 8.50181809 21.0895669 9.82420367 20.9562909 10.1530044 21.7894656 11.0611968 22.2922435 12.2223743 22.2922435 13.6413251c0 4.9942601-3.039811 6.0931889-5.935173 6.4148071.4660671.401424200000001.8818564 1.194696.8818564 2.4077473C17.2389269 24.2012564 17.2229657 25.603448 17.2229657 26.0296121 17.2229657 26.3775663 17.4575954 26.7821827 18.116793 26.6552912 23.2786458 24.9322794 27 20.0633148 27 14.3212723 27 7.14112562 21.1789496 1.32087331 13.9988029 1.32087331"/></svg></a></div><p><a href=https://github.com/naoyafurudono/naoyafurudono.github.io target=_blank rel=noopener>source of this site</a></p><p><a href=https://gohugo.io target=_blank rel=noopener></a></p><p>©2025 Naoya Furudono</p><script src=https://blog.nfurudono.com/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script><a target=_blank rel="noopener noreferrer" href=https://github.com/naoyafurudono/naoyafurudono.github.io/actions><img src=https://github.com/naoyafurudono/naoyafurudono.github.io/actions/workflows/gh-pages.yml/badge.svg alt="github pages deploy status" style=max-width:100%></a><p><a href="https://www.amazon.jp/hz/wishlist/ls/1JBRXP4JZZ21T?ref_=wl_share">欲しい本リスト</a></p><p><a href="https://www.amazon.jp/hz/wishlist/ls/3TT5GR81VZPHP?ref_=wl_share">欲しいものリスト</a></p></footer></nav><div id=content class=content-container><h1>"idea"</h1><article><h2><a href=https://blog.nfurudono.com/posts/read-nice-books/>良書を読む文化がもっと流行ってほしい</a></h2><div><p><p>この記事は、技術者の成長において「良書を読み込む文化」の重要性を論じた文章です。</p><h2><a href=#%e8%89%af%e6%9b%b8%e3%82%92%e8%aa%ad%e3%81%bf%e8%be%bc%e3%82%80%e3%81%93%e3%81%a8%e3%81%ae%e6%9c%89%e5%8a%b9%e6%80%a7 id=良書を読み込むことの有効性 class=anchor aria-hidden=true>良書を読み込むことの有効性</a></h2><p>新しいメンタルモデルを手にいれるための手法として、良書を読み込むことが有効だと考えます。</p><p>Known unknown（知らないことを知っている、例えばOSにはプロセスとスレッドというのがあるらしいが、何が違うかわからない）な対象を理解するためには、質問に回答してくれるチュータやNotebookLMのようなツールを用いれば良いでしょう（プロセスとスレッドの違いを質問すればいい）。一方で、考え方を新しく身につけるためにはその手法は効きません。なぜなら古いメンタルモデルしか持たない人間が新しいメンタルモデルを獲得するための質問をすることが困難だからです。</p><p>メンタルモデルを新しく説明して頭に叩き込むことは大変です。説明する側はよく整理しないといけない（聞き手が察することには期待できないので）し、聞き手は誤解をしないように注意深く説明を腹落ちさせる必要があります。</p><p>例えば技術研修は新しいメンタルモデルを研修生に叩き込む手段の一つです。やはり大変な営みなので技術研修をする講師には高いレベルのエンジニアの工数を注ぎ込む必要があるし、研修を受ける人々には研修期間中はそれに集中することが許されています。</p><p>技術研修は効果的ですがスケールしません。一方で良書を読み込むことはスケールします。さらに良書は研修よりも洗練されています。なので僕は良書を読み込むことが有効だと考えるのです。</p><p>まず、技術研修がスケールしないことを主張します。講師をアサインする必要があることがネックです。アサインするためには社内に適任者がいるとか、社外から適任者を頑張って呼び出すとかする必要があります。そもそもアサインできないことが多いでしょうし、できたとしても労力と金銭的なコストがかかります。</p><p>良書は安いです。大体の技術書は一万円も出せば購入できます。給料をもらって働いている人間なら程度の差こそあれ世界最高レベルの技術書を年に一回買うことは容易いのではないでしょうか。また良書は簡単に入手できます。Amazonで1分で注文できます。どんなに時間がかかっても、一週間もあれば本が手元に手に入るのではないでしょうか。そして大体の研修に比較して、よりレベルの高い専門家がより労力をかけて作成しています。技術的にも説明としてもレベルが高いはずです。</p><h2><a href=#%e8%89%af%e6%9b%b8%e3%82%92%e8%aa%ad%e3%81%bf%e8%be%bc%e3%81%be%e3%81%aa%e3%81%84%e3%81%ae%e3%81%af%e3%81%aa%e3%81%9c%e3%81%8b id=良書を読み込まないのはなぜか class=anchor aria-hidden=true>良書を読み込まないのはなぜか</a></h2><p>研修をするのはそれはそれで良いとして、研修は受けるのに良書を読み込むことはしない人がいるのはなぜでしょう。要因として以下があるのではないでしょうか</p><ul><li>良書を知らない、見つけられない</li><li>本を読み込むことを選択肢に持っていない</li><li>英語を読むことを選択肢に持っていない</li></ul><p>知らない、見つけられないのはある程度しょうがないでしょう。人に教えてもらうのが有効と思います。幸いなことに社内では本を紹介し合う文化が多少あります。そこで一定解決できるでしょう。インターネットには良書を紹介してくれる人がちらほらいます。アンテナを貼っておくと良いでしょう。</p><p>本を読み込むことを選択肢に持っていないのは経験の問題でしょう。読み込んだことのある人と一緒に読み込む練習をすれば良いと思います。大学の研究室でやられている輪講会はこの目的を持つと考えます。</p><p>また、良書は往々にして英語で書かれています。気合いで読めば読めるので、これも経験の問題でしょう。</p><h2><a href=#%e8%bc%aa%e8%ac%9b%e4%bc%9a%e3%81%ab%e3%82%88%e3%82%8b%e3%82%a2%e3%83%97%e3%83%ad%e3%83%bc%e3%83%81 id=輪講会によるアプローチ class=anchor aria-hidden=true>輪講会によるアプローチ</a></h2><p>輪講会に参加するモチベーションを高めて開催すれば参加してくれるでしょう。参加してくれれば良書を読み込む経験による慣れと、一冊の良書を読み込んだことによる新しいメンタルモデルを身につけることができます。</p><p>社内で二つの輪講会を開催しています。両方を狙って開催しているのが A philosophy of software designの輪講で、慣れを狙ったのが型システムの輪講です。</p><h2><a href=#%e3%81%8a%e3%81%be%e3%81%91%e8%89%af%e6%9b%b8%e3%81%ae%e7%b4%b9%e4%bb%8b id=おまけ良書の紹介 class=anchor aria-hidden=true>おまけ、良書の紹介</a></h2><p>僕が思う良書です。どれも文句なしにおすすめです。どういう領域のメンタルモデルを手に入れられるかはそれぞれの本の冒頭に書いてあるはずです。</p><ul><li>プログラミング in OCaml</li><li>Essentials of Programming Languages</li><li>A Philosophy of Software Design</li><li>プログラミング言語Go</li><li>K and R</li></ul><h2><a href=#%e3%81%8a%e3%81%be%e3%81%91%e3%82%a4%e3%83%b3%e3%82%bf%e3%83%bc%e3%83%8d%e3%83%83%e3%83%88%e3%81%ab%e3%81%af%e8%89%af%e6%9b%b8%e3%82%92%e7%b4%b9%e4%bb%8b%e3%81%97%e3%81%a6%e3%81%8f%e3%82%8c%e3%82%8b%e4%ba%ba id=おまけインターネットには良書を紹介してくれる人 class=anchor aria-hidden=true>おまけ、インターネットには良書を紹介してくれる人</a></h2><ul><li><a href=https://izumisy.work/>https://izumisy.work/</a></li><li><a href=https://zenn.dev/yoshiko>https://zenn.dev/yoshiko</a><ul><li>本ではなくインターネットの記事の紹介が多いですが、ご本人の記事もそこで引用される記事も良いものと感じます</li></ul></li><li><a href=https://ohbarye.hatenablog.jp/>https://ohbarye.hatenablog.jp/</a></li></ul><p>パッとはそんなに出てこなかったです。</p></p></div><div class=post-footer><time>June 15, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-06-15/>2025-06-15</a></h2><div><p><p><a href=/posts/2025-06-11/>2025-06-11</a> で不変条件を上手に設定して保つことがプロダクトを成長させるために効き、その効き具合は投下できるリソースの増加に応じて増すみたいなことを書いた。不変条件に限る必要はないはずで、内部品質を高めることが効くと思う。内部品質の高めかたの一つとして不変条件をいい感じにする方法がある。</p><h2><a href=#ai%e5%89%8d%e6%8f%90%e3%81%ae%e9%96%8b%e7%99%ba id=ai前提の開発 class=anchor aria-hidden=true>AI前提の開発</a></h2><p>CI・CDでは開発・運用から動作検証とデプロイを自動化した。つまり、それに必要な人手をゼロにした。それらに必要な人間の頭がゼロになったのではなくて、求められる頭の使い方と必要な作業の種類を変えた（作業の量を減らして負荷の高いスポットな労働に変換した）。</p><p>AI前提な開発をそのパターンに当てはめて考える。</p><p>例えばブランチを切ることから始まるプルリクエストの作成を自動化することはAI前提な開発の一つの形態である。ブランチを切る時点で達成するべきコードベースの変更の目標が定まっていて、それをプロダクトとしての品質を保ちながら意味あるスコープで実現するのがここでいうプルリクエストの作成である。コードベースがまともで、CIが整備されていればその手のプルリクエストを人間であれAIであれできる。この自動化が広く実現するようになると、プルリクエストでどんな変更を実現したいかを決めることと、プルリクエストをマージして良いことを検証することが自動化した仕事の周辺に残る。そしてこれらは今まで単に実装するだけよりも少しレベルの高い作業として認識されてきたものである。</p><p>多少抽象的な課題から、それを具体的に落とし込んで、どのようなプルリクエストが必要かを洗い出すことも最近商用化されているAIには可能である。この自動化が広く実現するようになると、周辺に残る仕事は多少抽象的な課題を抽出することと、プルリクエストをマージして良いことを検証することである。</p><p>多少抽象的な課題を抽出することは、claude codeの開発のためにやられていそうという観測<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>がある。インターネットを徘徊してユーザの反応を見れば良い。</p><p>プルリクエストをマージして良いことの検証はCIとそのメンテナンスとしてAIである程度自動化できるだろう。AIが直接判定しても良い。これはまだ現時点では難しいように感じる。僕が実現させられていないだけかもしれないが。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://zenn.dev/mizchi/articles/claude-code-singularity-point#%E8%87%AA%E5%88%86%E3%81%AE%E8%82%8C%E6%84%9F%3A-%E4%BB%8A%E3%81%AE-ai-%E3%81%AB%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%8C%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%8B%EF%BC%9F>https://zenn.dev/mizchi/articles/claude-code-singularity-point#%E8%87%AA%E5%88%86%E3%81%AE%E8%82%8C%E6%84%9F%3A-%E4%BB%8A%E3%81%AE-ai-%E3%81%AB%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%8C%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%8B%EF%BC%9F</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></p></div><div class=post-footer><time>June 15, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-06-11/>2025-06-11</a></h2><div><p><p>不変条件とそれをできるだけでかくとることについて語りたい。</p><p>不変条件はさまざまな対象に対して課される。例えばプログラム実行時の不変条件、永続化されるデータの不変条件、コードベースの不変条件などなどある。それらがロバストであり（条件を課す対象の変化に対して不変条件が変わりずらく）条件が強ければ強いほど良い不変条件だと考える。</p><p>不変条件の例として、型エラーにならないとか、メモリリークが起きないとか、データ競合が起きない、二重決済が起きない、外部モジュールのデータ構造は公開されているコンストラクタのみから構成する、外部サービスのデータにはAPIを通してのみアクセスする、などがある。アーキテクチャとか静的解析とかでは不変条件をプログラムとかサービスとかに課していて、開発ではそれを守りながら（時には条件を手入れしながら）変更を加える。</p><p>不変条件を手入れするのは一般的に難しいがそれに乗っかって済む変更は失敗したときにすぐわかるので嬉しいし、それに乗っかっている限り不変条件が守ってくれる範囲の誤りは起きないことが保証される。だからロバストで強い不変条件は良いものである。</p><p>開発に投下できるリソースが増えるほど不変条件をよく手入れすることがプロダクトを成長させるために効く。不変条件の手入れを細切れにやるのも大事だと思うが、不変条件の品質を高める技術が重宝されるとも思える。</p><p>書いてみると当たり前か。</p><hr><p>生成AIによって変更の速度が上がったしコストをかけるのが簡単になった（採用しなくても金を払えば労働力がすぐに手に入るようになったという意味で）。この背景の変化によって不変条件を扱う戦略はどのように変えるのが最適だろうか。</p></p></div><div class=post-footer><time>June 11, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-06-10/>2025-06-10</a></h2><div><p><p>大阪旅行に土曜日から行っていて今朝帰ってきた。飲み会が先週の水曜日から連日会ったのと金曜日が一日研修のあとやはり飲み会でそれらが連続して記憶されているからちょっとした旅行と感じている。</p><p>水曜日から金曜日は酒の飲み方が良くなくて週末に話を聞いたり振り返ったりして反省していた。人に迷惑かけるのが良くないし、自分の幸せにもつながらないのでただ愚か。その線引きをあらかじめした上で自制できないのが良くないと思う。周囲に甘やかしてもらっているだけなのでそろそろ改善しよう。</p><hr><p>大阪旅行は二泊三日の予定で、万博に行き、中日に山崎にいくことと、泊まる宿だけを決めていた。</p><p>最終的には僕は二泊では帰れず泊まる宿は寝る直前にみんなで変更したので半分くらいは行き当たりばったり。あと僕は初日に遅刻した。</p><p>全部ここに書くのはめんどいので思い出したトピックを箇条書きでメモ</p><ul><li>土曜日<ul><li>ぼくが帰宅に失敗</li><li>起床に失敗</li><li>たこ結び</li><li>合流</li><li>先輩</li><li>TW</li><li>かき氷</li><li>未来都市</li><li>水</li><li>住所が曖昧</li><li>串カツ</li><li>ブルートフォース</li><li>やつの登場</li><li>アイス</li><li>おっちゃん</li><li>風呂</li></ul></li><li>日曜日<ul><li>電車</li><li>おにぎり</li><li>街並み</li><li>神社</li><li>森</li><li>ID</li><li>釜？</li><li>桶</li><li>5m</li><li>スチルポッド</li><li>樽</li><li>アルコール</li><li>庭</li><li>原酒</li><li>ブレンド</li><li>反応</li><li>ハイボール</li><li>酔い始め</li><li>飲み比べ</li><li>ノンエージ</li><li>ニューポッド</li><li>暴れはじめ</li><li>銅・新しい樽材</li><li>そば・天ぷら</li><li>寝落ち</li><li>ラーメン・アイス</li><li>昼寝</li><li>お散歩</li><li>プラダ</li><li>天馬</li><li>寿司</li><li>串カツ</li><li>ワイン</li><li>連行</li><li>水</li><li>シラフの振り</li><li>脱走</li><li>たこ焼き</li><li>サウナ</li></ul></li><li>月曜日<ul><li>寝坊</li><li>郵便局</li><li>紀伊國屋</li><li>店</li><li>イタリア風おじさん</li><li>フランクフルト</li><li>ティモール</li><li>アゼルバイジャン</li><li>雨</li><li>傘・ポンチョ</li><li>側</li><li>360</li><li>紅茶</li><li>チュロス</li><li>庭</li><li>おいしいごはんが</li><li>仲良し</li><li>紳士</li><li>イタリア<ul><li>傘</li><li>優先</li><li>工芸</li><li>映像</li><li>編集・体験</li><li>心臓</li><li>インタビュ</li><li>絵？</li><li>加速</li><li>空間</li><li>侘び？</li><li>重いやつ抱えたおじさん・筋肉・毛束</li><li>筋肉聖人</li><li>筋</li><li>絵</li><li>パン・平和</li><li>ミケランジェロ</li><li>写真・時間</li><li>工業・展示方式</li><li>庭</li><li>花</li><li>レストラン</li><li>ピザじゃないやつ</li></ul></li><li>終電</li><li>車</li><li>エスカレータ</li><li>光るやつ</li><li>サイクロイド</li><li>ショップ</li><li>充電</li><li>発券</li><li>新大阪</li><li>駅員さん</li><li>ラーメン</li><li>飲み会</li><li>31</li><li>サンライズ</li><li>車掌さん</li><li>パジャマ</li></ul></li><li>火曜日<ul><li>近く</li></ul></li></ul></p></div><div class=post-footer><time>June 10, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/posts/avoid-23-59-59/>23:59:59という時刻を扱うのはやめよう</a></h2><div><p><p>この記事は生成AIを使って書いた記事です。ほとんど生成したものですが、レビューしてありますし加筆修正を人間が行なっています。</p><hr><p>プログラミングやシステム設計において、しばしば「23:59:59」という時刻が“終端”（end of day）として扱われます。しかし、このアプローチには多くの落とし穴（pitfalls）や混乱が潜んでいます。本稿では、なぜ23:59:59のような終端時刻を避けるべきかを整理し、より堅牢で明快な代替手法をご紹介します。</p><h2><a href=#%e8%aa%b2%e9%a1%8c id=課題 class=anchor aria-hidden=true>課題</a></h2><h3><a href=#1-%e5%a2%83%e7%95%8c%e5%80%a4boundary-value%e3%81%ae%e5%95%8f%e9%a1%8c id=1-境界値boundary-valueの問題 class=anchor aria-hidden=true>1. 境界値（Boundary Value）の問題</a></h3><ul><li><strong>オフバイワンエラー（Off-by-one Error）</strong>
23:59:59を終了時刻として設定すると、しばしば「23:59:60」や「24:00:00」をどう扱うかで混乱が生じます。特に、うるう秒（leap second）の挿入時には「23:59:60」が発生し、想定外のバグを誘発することがあります。</li><li><strong>不明瞭な閉区間（Closed Interval）と開区間（Half-open Interval）</strong>
23:59:59を含むか否か、すなわち区間を[00:00:00, 23:59:59]（閉区間）で扱うのか、[00:00:00, 23:59:59)（半開区間）で扱うのかが曖昧になり、仕様書（specification）と実装に齟齬が生じがちです。</li></ul><h3><a href=#2-%e6%97%a5%e4%bb%98%e5%a4%89%e6%9b%b4%e3%81%a8%e3%81%ae%e9%bd%9f%e9%bd%ac id=2-日付変更との齟齬 class=anchor aria-hidden=true>2. 日付変更との齟齬</a></h3><ul><li><strong>日次バッチ（Daily Batch）とカレンダー表示</strong>
例えば、日次バッチ処理を「23:59:59までのデータを集計」と定義すると、処理が終わるわずかな遅延で翌日の00:00:00以降のデータが取りこぼされたり、重複集計されたりする恐れがあります。</li><li><strong>ユーザーインターフェース（UI）の混乱</strong>
ユーザーに「23:59:59表示」を強いると直感的ではなく、かえって誤操作を招くことがあります。多くの人にとって「23:59:59」はピンと来にくく、特にミリ秒（milliseconds）やタイムゾーン（time zone）をまたぐ場合の理解が難しくなります。</li></ul><h3><a href=#3-%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e5%ae%9f%e8%a3%85%e3%81%ae%e8%a4%87%e9%9b%91%e5%8c%96 id=3-システム実装の複雑化 class=anchor aria-hidden=true>3. システム実装の複雑化</a></h3><ul><li><strong>データベース（Database）のクエリ</strong>
<code>WHERE timestamp &lt;= '2025-04-30 23:59:59'</code> といった条件は、ミリ秒精度のタイムスタンプやタイムゾーンが絡むと正確性を欠きやすいです。</li><li><strong>テスト（Testing）とモック（Mock）の難易度</strong>
テスト時に23:59:59を意図的に生成・モックするのは手間がかかり、テストケースの網羅性を落とす原因となります。</li></ul><h2><a href=#%e8%a7%a3%e9%87%88%e3%82%92%e5%a4%89%e3%81%88%e3%81%a6000000240000%e3%82%92%e6%89%b1%e3%81%86 id=解釈を変えて000000240000を扱う class=anchor aria-hidden=true>解釈を変えて00:00:00(24:00:00)を扱う</a></h2><p>23:59:59を扱いたいときは、きっと何かの期間の終わりを表すことを目的としているでしょう。「終わりの時刻まで」、と捉える代わりに終わりの時刻の直前までと捉えることで、23:59:59ではなく00:00:00を扱えば済むようになってすっきりします。具体的には以下の通りです。</p><h3><a href=#%e5%8d%8a%e9%96%8b%e5%8c%ba%e9%96%93half-open-interval%e3%82%92%e4%bd%bf%e3%81%86 id=半開区間half-open-intervalを使う class=anchor aria-hidden=true>半開区間（Half-open Interval）を使う</a></h3><ul><li><strong>[開始, 終了) の形式</strong>
例：[2025-04-01 00:00:00, 2025-05-01 00:00:00)<ul><li>「2025-04-01 00:00:00以上かつ2025-05-01 00:00:00未満」という明確な条件設定が可能。</li><li>オフバイワンエラーを防ぎ、うるう秒も意識不要。</li></ul></li></ul><h3><a href=#iso-8601%e3%81%ae2400%e3%82%92%e6%b4%bb%e7%94%a8%e3%81%99%e3%82%8b id=iso-8601の2400を活用する class=anchor aria-hidden=true>ISO 8601の24:00を活用する</a></h3><ul><li><strong>「24:00」表記</strong><ul><li>同日23:59:59の次に位置づけられるため、論理的な終端（end-of-day）を明示できます。</li><li>例：<code>2025-04-30T24:00:00</code> は <code>2025-05-01T00:00:00</code> と同一視されます。</li><li>ただし、すべてのライブラリがサポートしているわけではない点に注意。</li></ul></li></ul><hr><p>23:59:59を終端時刻として安易に扱うのは、多くの境界値エラーや実装・運用の混乱を招く原因となります。代わりに、半開区間（half-open interval）[開始, 終了)やISO 8601の24:00表記を採用し、仕様（spec）から実装（implementation）、テスト（testing）まで一貫して明確な時刻管理を行いましょう。これにより、バグの減少と運用コストの削減が期待できます。</p><hr><p><strong>参考情報</strong></p><ul><li>ISO 8601: 日付及び時刻のデータ要素と交換形式</li><li>ソフトウェアテストにおける境界値分析（Boundary Value Analysis）</li><li>半開区間について過去に調べた記事: <a href=https://dev.nfurudono.com/posts/semi-open-interval/>https://dev.nfurudono.com/posts/semi-open-interval/</a></li></ul><p>以上を踏まえ、次回からは「23:59:59」という時刻を見直し、より堅牢な方法で時刻管理（time management）を実践してみてはいかがでしょうか。</p></p></div><div class=post-footer><time>April 30, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/posts/read-a-philosophy-of-softfare-design/>A Philosophy of Software Designの読書メモ</a></h2><div><p><p>各章のまとめをする。随時僕の思ったことを差し込む。なのでこのドキュメントを読んであの本を読んだ気になってはいけないし、あの本と同じくらいに信頼してはいけない。</p><h2><a href=#preface id=preface class=anchor aria-hidden=true>Preface</a></h2><h3><a href=#%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2%e3%81%ae%e8%a8%ad%e8%a8%88%e3%81%a8%e3%81%8b%e8%89%af%e3%81%84%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2%e3%81%8c%e4%bd%95%e3%81%8b%e3%81%a8%e3%81%8b%e3%81%ae%e8%ad%b0%e8%ab%96%e3%81%8c%e6%9c%aa%e7%86%9f%e3%81%a7%e3%81%82%e3%82%8b id=ソフトウェアの設計とか良いソフトウェアが何かとかの議論が未熟である class=anchor aria-hidden=true>ソフトウェアの設計とか、良いソフトウェアが何かとかの議論が未熟である</a></h3><ul><li>以下のような事項については議論がされている<ul><li>開発プロセス</li><li>開発ツール</li><li>プログラミングテクニック<ul><li>OOP</li><li>functional</li></ul></li><li>デザインパターンとかアルゴリズム</li></ul></li><li>設計については1971の &ldquo;On the Criteria to be used in Decomposing Systems into Modules&rdquo; から発展がない</li></ul><h3><a href=#%e8%a8%ad%e8%a8%88%e6%8a%80%e6%b3%95%e3%82%92%e4%bd%93%e7%b3%bb%e7%9a%84%e3%81%ab%e8%ba%ab%e3%81%ab%e3%81%a4%e3%81%91%e3%81%a6%e8%a4%87%e9%9b%91%e3%81%95%e3%82%92%e6%b8%9b%e3%82%89%e3%81%9b%e3%82%8b%e3%82%88%e3%81%86%e3%81%ab%e3%81%99%e3%82%8b%e3%81%93%e3%81%a8%e3%82%92%e7%9b%ae%e6%8c%87%e3%81%99 id=設計技法を体系的に身につけて複雑さを減らせるようにすることを目指す class=anchor aria-hidden=true>設計技法を体系的に身につけて複雑さを減らせるようにすることを目指す</a></h3><ul><li>分割統治が大きな関心ごとだが、そのための教育はされていない<ul><li>どのように問題を分割するか</li><li>問題の分割を決めることは設計のでかいタスクの一つ</li></ul></li><li>プログラマの品質とか生産性にはそれなりにばらつきがある<ul><li>能力には才能ではなくて良い練習が効くのは一般的に言われているらしい</li></ul></li><li>設計のスキルがプログラマのすごい・普通を分けるだろうと仮定して、学部一年生に対して講義を始めた<ul><li>原理・原則を座学で伝える</li><li>ソフトウェア開発のプロジェクトもやって、それらを活かす練習をする<ul><li>学生はたくさんコードを書いて講師にレビューを受けて改善する</li></ul></li></ul></li><li>その講義で伝えた設計の原則を集めたのがこの本</li><li>この本を書いた人はスタンフォードの教授で色々ソフトウェアを作ってきた</li><li>複雑さを減らすことがどの原則よりも大切</li></ul><h2><a href=#chapter-1-introduction-its-all-about-complexity id=chapter-1-introduction-its-all-about-complexity class=anchor aria-hidden=true>Chapter 1. Introduction (It&rsquo;s all about complexity)</a></h2><h3><a href=#%e8%89%af%e3%81%84%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2%e3%82%92%e3%81%84%e3%81%84%e6%84%9f%e3%81%98%e3%81%ab%e4%bd%9c%e3%82%8b%e3%81%9f%e3%82%81%e3%81%ab%e3%81%af%e8%a4%87%e9%9b%91%e3%81%95%e3%81%ab%e5%af%be%e5%87%a6%e3%81%99%e3%82%8b%e3%81%93%e3%81%a8%e3%81%8c%e5%bf%85%e8%a6%81 id=良いソフトウェアをいい感じに作るためには複雑さに対処することが必要 class=anchor aria-hidden=true>良いソフトウェアをいい感じに作るためには複雑さに対処することが必要</a></h3><ul><li>ソフトウェアはそれがどんなものであるかを表現できれば作れたも同然である。例えば筋肉がなくても作れる</li><li>そのためソフトウェアを書くのを律速する能力は、作っているシステムがどんなものであるかを理解する能力である</li><li>残念なことにプログラムを成長させていくに連れて複雑さは増していく。</li><li>複雑さを増すとそのソフトウェアを理解することは難しくなり、成長させる速度やコストは増す。バグも入る</li><li>開発ツールで複雑さに対処することはできるし、そうしてきた<ul><li>コード生成とかバージョン管理とかプログラミング言語とかはその例</li></ul></li><li>ツールの力だけでなんとかしきることは、とはいえ無理</li><li>ソフトウェアを簡単に作れるようになって、もっとすごいシステムを安価に作れるようになるためにはソフトウェアをシンプルに保つことが必要</li><li>まあ複雑さはどう頑張っても増えるものではあるのだけど、設計をシンプルにしておけばソフトウェアがでかく強力になってもまだ耐えられるようにできる</li></ul><h3><a href=#%e8%a4%87%e9%9b%91%e3%81%95%e3%82%92%e6%b8%9b%e3%82%89%e3%81%99%e3%81%9f%e3%82%81%e3%81%ab%e3%81%af%e4%ba%8c%e3%81%a4%e3%81%ae%e3%82%a2%e3%83%97%e3%83%ad%e3%83%bc%e3%83%81%e3%81%8c%e3%81%82%e3%82%8b id=複雑さを減らすためには二つのアプローチがある class=anchor aria-hidden=true>複雑さを減らすためには二つのアプローチがある</a></h3><ul><li>コードをシンプルで明らかにすること: こっちはまあそうでしょう、と思える<ul><li>名前の付け方に一貫性を持たせる</li><li>特別扱いを減らす</li></ul></li><li>複雑性をカプセル化する。(moduler designと呼ぶらしい)<ul><li>分割統治をするということ</li><li>丁寧に説明すると、でかい問題を解決するために部分問題の証明を忘れられるようにすること</li></ul></li></ul><h3><a href=#%e9%96%8b%e7%99%ba%e8%80%85%e3%81%af%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2%e3%81%ae%e8%a4%87%e9%9b%91%e3%81%95%e3%81%ab%e5%af%be%e5%87%a6%e3%81%97%e7%b6%9a%e3%81%91%e3%82%8b%e5%bf%85%e8%a6%81%e3%81%8c%e3%81%82%e3%82%8b id=開発者はソフトウェアの複雑さに対処し続ける必要がある class=anchor aria-hidden=true>開発者はソフトウェアの複雑さに対処し続ける必要がある</a></h3><p>橋とかのデザインと違って、ソフトウェアはずっと設計を変え続けるもの。この考え方に足していないのがウォーターフォールな開発で、一度に全体を設計したらそれを開発の過程で変更することはなく、もし微妙なところが出ても書く開発対象の範囲内で対処する。</p><p>アジャイル開発は設計を変え続けるアプローチに即している。将来的に開発したいでかいものは見据えつつ全体の設計は後回しにして欲しいソフトウェアのサブセットをまずは設計して開発する。開発の段階でまずそうとわかった設計は、次の開発の前に変更してまずさを潰す。こうすることで設計の問題が小さいうちに課題を発見し解決できる見込みが増える。</p><p>こういうイテレーティブな開発では設計が終わることはない。開発者は常に設計に気をかける必要があるし再設計する必要がある。改善するために小さく刻んで開発しているのだからそれはそう。設計を改善できないのならば、アジャイルに開発する意味がない。</p><p>今日ではアジャイルな開発をしているわけで、開発者常に設計の課題について考える必要がある。設計のことに常に気をかけないということは、常に複雑さに対処しなければならないということ。</p><h3><a href=#%e3%81%93%e3%81%ae%e6%9c%ac%e3%81%ae%e7%9b%ae%e7%9a%84 id=この本の目的 class=anchor aria-hidden=true>この本の目的</a></h3><p>二つある</p><ol><li>ソフトウェアの複雑さを理解すること</li></ol><ul><li>複雑さとは何か</li><li>複雑さは何が問題なのか</li><li>不必要な複雑さを持っていることにどのようにして気がつくか</li></ul><ol><li>ソフトウェア開発にあたって、複雑さを最小化するための個別なテクニックを習得すること</li></ol><h2><a href=#chapter-2-the-nature-of-complexity id=chapter-2-the-nature-of-complexity class=anchor aria-hidden=true>Chapter 2. The Nature of Complexity</a></h2><p>この章では複雑さとは何かや、どのようにシステムが不必要に複雑であるかを見分けるかを議論する。設計がシンプルかを見分けるだけでは設計をシンプルに作ることはできないが、その判断をもとにシンプルに作るためのアプローチをできる。</p><p>設計方針を色々試してみれば良くて、その結果いい感じになるやつを使えば良い。そのいい感じになるかの評価をできるようにすることがこの章の目的である。</p><h3><a href=#%e8%a4%87%e9%9b%91%e3%81%95%e3%81%ae%e5%ae%9a%e7%be%a9 id=複雑さの定義 class=anchor aria-hidden=true>複雑さの定義</a></h3><p>この本で議論を進めるために以下のように複雑さを定義する: 複雑さはソフトウェアシステムの構造に関するもののうち、システムの理解や修正を難しくするものである。</p><p>例えば以下のような例がある</p><ul><li>コード片がどのように動作しているか理解できない</li><li>システムのどこを修正して良いかわからない</li><li>他に影響を与えずにバグ修正をするのがむずい</li></ul><p>要するに、理解と修正が難しければそのソフトウェアシステムは複雑であるということ。それが簡単だったらシンプル。</p><p>システムの複雑さは、コンポーネントの複雑さをその変更頻度で重み付けした上での総和であると思える。</p><p>また、読み手にとっての複雑さと書き手にとっての複雑さは異なる。書き手にとってシンプルであっても読み手にとって複雑であればそれは複雑である。自分がそういうコードの書き手であったら、その分断が起きた理由を探ると良いだろう。そのギャップを埋める必要がこの仕事にはあるのだから。</p><h3><a href=#%e8%a4%87%e9%9b%91%e3%81%95%e3%81%ae%e7%97%87%e7%8a%b6 id=複雑さの症状 class=anchor aria-hidden=true>複雑さの症状</a></h3><p>一般的に三つの兆しがあって、開発を辛くする</p><ul><li>変更範囲の拡大: 簡単にできそうな変更が思ったより大変なパターン。メンタルモデルとその実現方法があっていないときに生じる。メンタルモデルを表現する力が足りていない</li><li>認知負荷: うまく使うためにやらないといけないことが多いことが原因</li><li>unknow unknown: 変更する必要性に気がつけなくなっていること</li></ul><p>unknown unknownが特に辛い。変更範囲が広いのはめんどいのは間違い無いのだけど、全部対処すれば自信を持って変更を完遂できる。一方でunknown unknownは自信を持つために全てのコードを読む必要があって辛い。システムがでかいとそもそも無理。</p><p>設計の目標の一つにシステムを明らかにすることがある。認知負荷とunknown unknownを減らすことにつながる。理解もコーディングもシュッとできるのがいい。何かを考えてそれが実際に通じるかの判断も簡単になる。</p><h3><a href=#%e8%a4%87%e9%9b%91%e3%81%95%e3%81%ae%e5%8e%9f%e5%9b%a0 id=複雑さの原因 class=anchor aria-hidden=true>複雑さの原因</a></h3><p>複雑さの症状をざっと見て、なんでソフトウェア開発が辛くなるのかを議論した。次に複雑さの原因を議論してシステムに問題が入らないように設計できるようになりたい。</p><p>複雑さは依存と不明瞭さによって生じる。ここではそれらをざっくり語って、後の章では細々とした設計での意思決定がどのようにそれらと関係するかをみる。</p><h4><a href=#%e4%be%9d%e5%ad%98 id=依存 class=anchor aria-hidden=true>依存</a></h4><p>扱う対象がそれ単体では理解できない、変更できないときに一緒に変更するやつに依存するという。頻繁に変更するコンポーネントが他のコンポーネントに依存していると、依存されているコンポーネントまで頻繁に変更するハメになる。そこで以下のシステムの複雑さの定義の言い換えを思い出す。</p><blockquote><p>システムの複雑さは、コンポーネントの複雑さをその変更頻度で重み付けした上での総和であると思える。</p></blockquote><p>依存が多いシステムではたくさんのコンポーネントの変更頻度が上がるため、システムの複雑さも大きい。</p><p>特に複雑なコンポーネントを他の変更が多いコンポーネントから依存させないことがシステム全体の複雑さを抑えるために効く。</p><h4><a href=#%e4%b8%8d%e6%98%8e%e7%9e%ad%e3%81%95 id=不明瞭さ class=anchor aria-hidden=true>不明瞭さ</a></h4><p>大事な要素が明らかになっていないことを指す。例えば数値の単位がわからないとか、名前がなんの意味も表してないとか。あるいは依存が存在することが明らかじゃ無いのもそう。一貫性のなさもこの要因で、同じ名前が異なる用途に使われているとやばい。</p><p>ドキュメントがやばいことが多くの原因で、コメントをちゃんと書けばよかったりする。デザインが良ければそもそも明らかであってドキュメントを不要にすることもできる。</p><p>めっちゃコメントがいるような場合はデザインがまずいことの兆しだし、明瞭さを増すためにはシステムの設計を改善するのが正攻法。</p><p>依存は変更範囲の拡大と認知負荷に作用して、不明瞭さはunknown unknownと認知負荷に作用する。依存と不明瞭さを下げる設計技法が手に入ればソフトフェアの複雑さを下げられるはずだ。</p><h3><a href=#%e8%a4%87%e9%9b%91%e3%81%95%e3%81%af%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e5%85%a8%e4%bd%93%e3%81%ae%e3%82%82%e3%81%ae id=複雑さはシステム全体のもの class=anchor aria-hidden=true>複雑さはシステム全体のもの</a></h3><p>一個一個の細かい要因が全体を壊すほどの複雑さ単独で生むわけではなくて、複数が重なり合って首が回らなくなるもの。対処するためには &ldquo;zero tolerance&rdquo; philosophy に従うべきらしい。</p><p>複雑さは既存のコードベースを修正することを難しく、またリスキーにする。</p><h2><a href=#chapter-3-working-code-isnt-enough-strategic-vs-tactical-programming id=chapter-3-working-code-isnt-enough-strategic-vs-tactical-programming class=anchor aria-hidden=true>Chapter 3. Working Code Isn&rsquo;t Enough (Strategic vs. Tactical Programming)</a></h2><p>プログラミングタスクに際してのマインドセットは良いソフトウェア設計のために大事な要素である。</p><p>良いデザインを得るためには、すぐにコードが動くことを至上とするするtacticalなマインドセットではなくて、綺麗なデザインのために時間をかけた上で問題点を修正する方針が必要だ。</p><p>この章ではなんで戦略的なアプローチが良い設計を生むのか、そして戦略的なアプローチの方が結果的には安いことを主張する。</p><h3><a href=#tactical-programming%e3%81%a8%e3%81%af%e3%81%a9%e3%82%93%e3%81%aa%e3%81%8b id=tactical-programmingとはどんなか class=anchor aria-hidden=true>Tactical Programmingとはどんなか</a></h3><p>多くの開発ではtacticalな手法が取られる。例えばバグを治すためにその場しのぎの対症療法をするようなこと。確かにそのときは早いのだけど、良いシステムの設計が得られることはないだろう。そういうときに、少しずつ不必要な複雑さがシステムに入り込む。</p><p>そのうちしんどさに気がついてリファクタリングとかをしたくなるのだけれど、仕事には期限があって新しい機能を追加しないといけないからやはり複雑さは残ったままになる。今見えている問題にはすぐに効くパッチだけ当てて、全体をよくすることはない。</p><p>そのうちマジでヤバくなるのだけど、その頃には全体を治すのが大変になっていて、当然そんな時間を取ることはできないので諦めてずっとその場しのぎの変更を入れ続けることになる。</p><p>一回tacticalな道に足を踏み入れるとそこから抜け出すことは容易ではないのだ。</p><h3><a href=#storategic-programming%e3%81%a8%e3%81%af%e3%81%a9%e3%82%93%e3%81%aa%e3%81%8b id=storategic-programmingとはどんなか class=anchor aria-hidden=true>Storategic Programmingとはどんなか</a></h3><p>まともなソフトウェア設計者になるための第一歩は動くだけのコードでは不十分であることに気が付くことだ。タスクを早く終わらせるために不必要な複雑さをコードに入れることは許されない。コードは既存のものに追加されていくものなので、今書かれているコードを将来誰かが編集することにもなる。なので今書くコードは動くだけでなく素晴らしい設計を体現することを目標にしないといけない（もちろん動く必要はあるけど）。</p><p>Strategic programmingには投資の心構えが必要で、例えばよく考えることに時間を投資するとか、いくつか設計してみて一番綺麗なやつを選ぶとかする。変更の可能性をいくつか想定してみてまあいけそうだと思えることを検証する。良いドキュメントを書くこともその一環である。
colliraryとして、良い設計をするためにはソフトウェアを変更する能力が効く、が主張できる。ソフトウェアを変更する能力がないひとは変更に強いことを主張できないが、変更する能力がある人はその設計がどこまでの変更をどのくらいの大変さで実施できるかを評価できる。他にも、設計がまずいことに気がついたときに目を瞑るのではなくちょっと時間をかけてよくする必要がある。</p><h3><a href=#%e3%81%a9%e3%82%8c%e3%81%8f%e3%82%89%e3%81%84%e6%8a%95%e8%b3%87%e3%81%99%e3%82%8b%e3%81%b9%e3%81%8d%e3%81%8b id=どれくらい投資するべきか class=anchor aria-hidden=true>どれくらい投資するべきか</a></h3><p>最初に全部設計するのは効果的ではなさそう。理想的な設計は作りながらわかっていくものなので、少しずつのたくさんの投資を基礎の上で行うこと。
1-2割の時間を設計にかけることをここでは提案している。スケジュールを破壊するほどは長くはないし、利益を産むために十分な時間でもあるはず。</p><h3><a href=#%e3%82%b9%e3%82%bf%e3%83%bc%e3%83%88%e3%82%a2%e3%83%83%e3%83%97%e3%81%a0%e3%81%8b%e3%82%89%e3%81%bf%e3%81%9f%e3%81%84%e3%81%aa%e8%a8%80%e3%81%84%e8%a8%b3%e3%81%af%e9%80%9a%e3%81%98%e3%81%aa%e3%81%95%e3%81%9d%e3%81%86 id=スタートアップだからみたいな言い訳は通じなさそう class=anchor aria-hidden=true>スタートアップだから、みたいな言い訳は通じなさそう</a></h3><p>Facebook, Google, VMWareを引き合いに出してstorategicにやった方が良さそうですよ、と主張している。意味的に新しいことはここでは特に言ってなさそう。よくある（本当によくある）tactical programmingの正当化への反論をここではしている。</p><h3><a href=#%e6%95%99%e8%a8%93 id=教訓 class=anchor aria-hidden=true>教訓</a></h3><ul><li>storategic programmingをしろ、効果は思ったよりもすぐに現れる</li><li>明日ではなく今日やるもの</li><li>全てのエンジニアが良い設計への投資をすることが効果的</li></ul><h2><a href=#chapter-4-modules-should-be-deep id=chapter-4-modules-should-be-deep class=anchor aria-hidden=true>Chapter 4. Modules Should Be Deep</a></h2><p>開発者がシステム全体ではなく一部の複雑さだけに対処すれば良い方にすることを目的とするソフトウェア設計着本がある。
Modular designと呼ばれていて、ソフトウェアの複雑さをなんとかするためにすごく大切。</p><p>この章ではこの基本的な原則を解説する。</p><h3><a href=#modular-design%e3%81%a8%e3%81%af%e4%bd%95%e3%81%8b id=modular-designとは何か class=anchor aria-hidden=true>Modular designとは何か</a></h3><p>ソフトウェアシステムを複数の（それなりに独立した）モジュールに分解する。ここでいうモジュールはクラスかもしれないし、サブシステムかもしれないし、サービスかもしれない。理想的にはそれぞれのモジュールは他には全く依存しないで欲しい、つまり開発者はそれぞのれモジュールを他のモジュールのことを完全に忘れて開発できるようになっていて欲しい。そういう理想的な世界では、ソフトウェアシステムの複雑さはそれを構成するモジュールたちの複雑さの中で一番複雑なやつの複雑さである（あれ、そういう定義だったか。まあ気持ちはわかる）。</p><p>現実世界ではそうは問屋が卸さなくて、あるモジュールは他のモジュールの関数とかを呼ぶ必要があって、多かれ少なかれ他のモジュールを知っておく必要がある。モジュールの間いに依存が生じることもあるはず（つまりあるモジュールを変更したら、他のモジュールを変更する必要が出てくるかもしれないということ）。
Modular designの目的はモジュール間の依存を最小化すること。</p><p>依存を管理するためにはモジュールを二つの要素、インターフェースと実装に分けて捉えると良いだろう。モジュールを外から使うために知っておくべきものがインターフェースで、そのモジュールが何をするかを表す。それをどのように実現するかは表さないのが典型的。実装はインターフェースを満たすためのもの。あるモジュールで仕事をする開発者は、他のモジュールのインターフェース、そのモジュールのインタフェース、そのモジュールの実装を頭に入れて働くことになる。他のモジュールの実装を頭に入れる必要はないし、そうしないべきである。</p><p>ここでいうインターフェースはプログラミング言語の意味論で強制されるものに限らなくて、自然言語でドキュメントとして記述されることもある。そのモジュールを使うために開発者が知るべき情報は全てインターフェースの一部である。形式的でない部分はコメントとして書くしかなくて、それが正しいことをプログラミング言語が保証することはできない。そして残念なことにそういう形式的でない部分は複雑でより多い傾向にある。</p><p>明瞭に書かれたインターフェースは開発者がそのモジュールを使うために知る必要のあることを占めることであって、unknown unknownを減らす。</p><h3><a href=#%e6%8a%bd%e8%b1%a1%e5%8c%96 id=抽象化 class=anchor aria-hidden=true>抽象化</a></h3><p>Modular designと関係する概念。抽象化は対象を単純化した見方のことで、重要でない詳細を捨てたもの。複雑なことをしなくてもそれを扱えるようになるので抽象化は便利。</p><p>モジュラなプログラミングではモジュールがインターフェースによってその抽象化を提供することになる。インターフェースはモジュールの単純化された機能を説明することになるということ。モジュールを使うためには重要でない詳細を捨ててそのモジュールを理解すれば済むので嬉しい。</p><p>捨てているのが重要でない部分であるのが大切。抽象化のミスり方には二つある。</p><ol><li>重要でない詳細を抽象化に含めること: 抽象化を複雑にする点でよくない</li><li>重要な詳細を抽象化に含めないこと: 不明瞭なシステムになるのが良くない。抽象化だけをみている開発者はその抽象化を正しく使うために必要な情報を見落とすことになる</li></ol><p>後者のことをfalse abstractionと呼ぶ。一見シンプルだけど実はそうでもないやつ。抽象化を設計するためにはどんな情報が大切かと、どのように大切な情報を減らすかが鍵。</p><h3><a href=#deepshallow-modules-classiti id=deepshallow-modules-classiti class=anchor aria-hidden=true>Deep/shallow modules, classiti</a></h3><p>機能的でシンプルなインターフェースを持つモジュールが最高のモジュールということになりそう。抽象化がうまくいったやつがいい。そういうモジュールのことをdeepなモジュールと呼んでいる。</p><p>反対にインターフェースが複雑な割に大した機能を提供してないものはshallowなモジュール。</p><p>我々はモジュールをdeepにすることを目指すべきであって、そのインターフェースの絶対的なサイズは問題ではない。</p><h3><a href=#%e3%81%be%e3%81%a8%e3%82%81 id=まとめ class=anchor aria-hidden=true>まとめ</a></h3><ul><li>モジュールをインターフェースと実装に分けて捉えることで、その複雑さをシステムの他の部分から隠せる</li><li>そのモジュールを使う側はそのインターフェースだけに気をかければ良い</li><li>大事なことはモジュールが深くなるように設計すること。そうすれば隠蔽できる複雑さを最大化できてシステム全体の複雑さを抑えることに貢献できる</li></ul></p></div><div class=post-footer><time>April 29, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-04-27/>2025-04-27</a></h2><div><p><p>学生の頃に数学の先生が図書館で本読むとインターネットとかで調べるのと違って周りの本とかにも目がいって視野が広がっていいぞ、みたいなことを話していた。いらないことを言わないで聞いたことに対して察して回答をしてくれるAIがついているので、視野が以前に増して広がりにくくなっているだろう、と考えられる。実際にそうかの判断はまだ下せないと思うけど。脱線とか下手くそな質問によって見えていなかったものが見えることもあるし、そもそも今までは答えに辿り着けなかった疑問に対しても今なら到達しやすくなったと思う。速度が上がればもっと遠くに行ける気もする。なので視野が広がる力が働いているとも思える。</p><p>AIも検索も読書もすればいい</p></p></div><div class=post-footer><time>April 27, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-03-25/>2025-03-25</a></h2><div><p><ul><li><input disabled type=checkbox> 以下の三つについて紹介しつつ、ぼくの信じる主張をする<ul><li>how to design programs</li><li>a philosophy of software design</li><li>di: これについては良い書籍を思いつかなかった、気持ちは以下からえている<ul><li>インターフェース設計</li><li>unixというかパイプ、gatherじゃないけどあのschemeの書籍に書いてあったアレみたいな原則</li><li>mock</li><li>逆数学</li><li>取り回しやすい、仮説と結論の関連付けをする含意</li><li>effect system</li><li>type class</li></ul></li></ul></li></ul><h2><a href=#%e8%a8%ad%e5%ae%9a%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e3%82%92%e4%b8%80%e7%99%ba%e3%81%a7%e9%96%8b%e3%81%8f%e3%82%b3%e3%83%9e%e3%83%b3%e3%83%89 id=設定ファイルを一発で開くコマンド class=anchor aria-hidden=true>設定ファイルを一発で開くコマンド</a></h2><p>fishで設定ファイルを一発で開くコマンドを書いた。導入したてのツールだとこまめに設定ファイルを編集したい。わざわざ.confgまで行ってあれこれするのが面倒なので、このコマンドを使うと幸せ。</p><pre><code class=language-fish>function conf  --description 'この関数にハードコードした設定ファイル一覧からをfzfで選択してEDITORで開く'
    set -q EDITOR; or set EDITOR vim

    # パスはfishの組み込みによって解釈される
    # 相対パスに解釈される場合はXDG_CONFIG_HOMEを常に基点として扱う
    set -l configs \
        'fish/config.fish' \
        'fish/functions/conf.fish' \
        '~/.local/fish/init.fish.secret' \
        'ghostty/config' \
        'git/config' \
        'nvim/init.lua'

    # 名前一覧をfzfで表示
    set -l selected_path (
        printf '%s\n' $configs | fzf --prompt=&quot;Edit config&gt; &quot;
    )

    test -n &quot;$selected_path&quot;; or return

    # パス展開（~など対応）
    # https://fishshell.com/docs/current/cmds/path.html#normalize-subcommand
    set selected_path (path normalize &quot;$selected_path&quot;)

    # 絶対パスでないならXDG_CONFIG_HOMEを前置
    if not string match -q --regex '^/' $selected_path
        set selected_path &quot;$XDG_CONFIG_HOME/$selected_path&quot;
    end

    # ファイルの存在確認をしてエディターを起動
    if test -f &quot;$selected_path&quot;
        $EDITOR &quot;$selected_path&quot;
    else
        echo &quot;Config file not found: $selected_path&quot;
        return 1
    end
end
</code></pre></p></div><div class=post-footer><time>March 25, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-02-18/>2025-02-18</a></h2><div><p><h2><a href=#%e7%94%9f%e6%88%90ai%e3%81%ab%e5%90%a6%e5%ae%9a%e3%81%97%e3%81%a6%e3%82%82%e3%82%89%e3%81%a3%e3%81%a6%e6%96%87%e5%8f%a5%e3%81%ae%e3%81%a4%e3%81%91%e3%82%88%e3%81%86%e3%81%8c%e3%81%aa%e3%81%84%e4%b8%bb%e5%bc%b5%e3%82%92%e4%bd%9c%e3%82%8b id=生成aiに否定してもらって文句のつけようがない主張を作る class=anchor aria-hidden=true>生成AIに否定してもらって文句のつけようがない主張を作る</a></h2><p>生成AIを壁にして議論することが不毛に感じる。自分で思考することを放棄して生成AIに言わせたいことを言わせるゲームになるのが不毛であるように感じる。あいつはぼくに質問をしてこなくて、なされるがままに僕の願いを叶えるようにチューニングされている。ぼくは議論を通じて思考を深めて問題領域の理解を深めたいが、そのための思考をあいつに渡してしまうことになる。俺が論じるからお前は俺の考えをできるだけ簡潔に論破しろ、とか言えばいいのだろうか。</p><p>試したらいい感じだが、体力が必要。</p><h3><a href=#%e8%bf%bd%e8%a8%98 id=追記 class=anchor aria-hidden=true>追記</a></h3><p>文句のつけようがない主張をすると、へりくつ捏ねる子になっちゃった。難しい。</p><h2><a href=#%e3%82%a4%e3%83%99%e3%83%b3%e3%83%88%e3%81%ae%e3%81%82%e3%82%8c%e3%81%93%e3%82%8c id=イベントのあれこれ class=anchor aria-hidden=true>イベントのあれこれ</a></h2><p>去年のどこか暗いからTwitterの僕のTLとかその周りでWebアプリケーションのバックエンドのロールを作るためにイベントの概念にフォーカスすることが流行っているように感じる。</p><p>以下のようなバズワードが飛び交っている。</p><ul><li>イベントストーミング</li><li>イベントベースなドメイン駆動設計</li><li>イベントソーシング</li><li>EDA (イベント駆動アーキテクチャ)</li><li>CQRS</li><li>非同期処理</li></ul><p>それぞれがどのレイヤ（プログラミングの工程）で使われる言葉なのかを分類すると以下のようになると思う。</p><ul><li>問題領域のモデリング<ul><li>イベントストーミング</li></ul></li><li>問題を解決するためのシステム設計（システムのモデル作成）<ul><li>イベントベースなドメイン駆動設計?</li></ul></li><li>永続化する際のデータ表現とその解釈<ul><li>イベントソーシング</li><li>イベントベースなドメイン駆動設計?</li><li>CQRS?</li><li>非同期処理</li></ul></li><li>コンポーネント間での通信方式<ul><li>EDA</li><li>CQRS?</li><li>非同期処理</li></ul></li></ul><h3><a href=#todos id=todos class=anchor aria-hidden=true>todos</a></h3><ul><li><input disabled type=checkbox> ソースはどこだよ！って感じなので文章をあさって明記したい。</li><li><input disabled type=checkbox> 有効性は？<ul><li>これらの考え方、開発手法、アーキテクチャはどんなときに有効で、どんなときにもっと普通で良い解決方法があるだろうか。</li></ul></li></ul><h3><a href=#%e3%83%a1%e3%83%a2 id=メモ class=anchor aria-hidden=true>メモ</a></h3><p>イベントを永続化して、それを発展させるための手法を紹介する書籍として、<a href=https://leanpub.com/esversioning>Versioning in an Event Sourced System</a>がある。</p><h2><a href=#%e5%ae%a3%e4%bc%9d id=宣伝 class=anchor aria-hidden=true>宣伝</a></h2><p>エンジニアのフォロイーがTwitterで増えてきたように感じるので、RSSからTwitterに投稿するのをやっても良いかも。</p><p>以下の記事を参考にできそう。</p><p><a href=https://efcl.info/2023/05/28/rss-to-twitter/>https://efcl.info/2023/05/28/rss-to-twitter/</a></p><p>僕はブログを</p><ul><li>長めで</li><li>自分の資産として管理可能な</li><li>編集可能な</li></ul><p>ツイートだと思っている。なのでTwitterrで宣伝するのはターゲットが合致して良いだろう。</p></p></div><div class=post-footer><time>February 18, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-02-11/>2025-02-11</a></h2><div><p><h2><a href=#zed%e3%81%a7ghes%e3%81%ae%e3%83%91%e3%83%bc%e3%83%9e%e3%83%aa%e3%83%b3%e3%82%af%e3%82%92%e5%8f%96%e5%be%97%e3%81%a7%e3%81%8d%e3%82%8b%e3%82%88%e3%81%86%e3%81%ab%e3%81%97%e3%81%9f%e3%81%84 id=zedでghesのパーマリンクを取得できるようにしたい class=anchor aria-hidden=true>ZedでGHESのパーマリンクを取得できるようにしたい</a></h2><h3><a href=#%e8%aa%bf%e6%9f%bb id=調査 class=anchor aria-hidden=true>調査</a></h3><p>普通のGitHubのリポジトリのコードではパーマリンクをコマンドから取得できるのだが、GHESだと何かがうまくいかない。エラーメッセージは以下。</p><blockquote><p>Failed to copy permalink: failed to parse Git remote URL</p></blockquote><p>おそらくremoteのドメイン名がハードコードされているとかだろう。</p><p>該当のエラーメッセージを出力しているのはここみたい。</p><p><a href=https://github.com/zed-industries/zed/blob/2e7bb11b7d5de6a79bef2491fa5ce8ecfd2bca15/crates/project/src/buffer_store.rs#L1673-L1675>https://github.com/zed-industries/zed/blob/2e7bb11b7d5de6a79bef2491fa5ce8ecfd2bca15/crates/project/src/buffer_store.rs#L1673-L1675</a></p><p>そしてそこで呼ばれているのがこれ</p><p><a href=https://github.com/zed-industries/zed/blob/2e7bb11b7d5de6a79bef2491fa5ce8ecfd2bca15/crates/git/src/hosting_provider.rs#L168-L184>https://github.com/zed-industries/zed/blob/2e7bb11b7d5de6a79bef2491fa5ce8ecfd2bca15/crates/git/src/hosting_provider.rs#L168-L184</a></p><pre><code class=language-rust>pub fn parse_git_remote_url(
    provider_registry: Arc&lt;GitHostingProviderRegistry&gt;,
    url: &amp;str,
) -&gt; Option&lt;(
    Arc&lt;dyn GitHostingProvider + Send + Sync + 'static&gt;,
    ParsedGitRemote,
)&gt; {
    provider_registry
        .list_hosting_providers()
        .into_iter()
        .find_map(|provider| {
            provider
                .parse_remote_url(url)
                .map(|parsed_remote| (provider, parsed_remote))
        })
}
</code></pre><p>正しくURLをパースできるhosting providerが存在しないのでエラーになっていそう。Hosting providerは以下で設定されている。</p><p><a href=https://github.com/zed-industries/zed/blob/2e7bb11b7d5de6a79bef2491fa5ce8ecfd2bca15/crates/git_hosting_providers/src/git_hosting_providers.rs#L11-L38>https://github.com/zed-industries/zed/blob/2e7bb11b7d5de6a79bef2491fa5ce8ecfd2bca15/crates/git_hosting_providers/src/git_hosting_providers.rs#L11-L38</a></p><pre><code class=language-rust>/// Initializes the Git hosting providers.
pub fn init(cx: &amp;App) {
    let provider_registry = GitHostingProviderRegistry::global(cx);
    provider_registry.register_hosting_provider(Arc::new(Bitbucket));
    provider_registry.register_hosting_provider(Arc::new(Codeberg));
    provider_registry.register_hosting_provider(Arc::new(Gitee));
    provider_registry.register_hosting_provider(Arc::new(Github));
    provider_registry.register_hosting_provider(Arc::new(Gitlab::new()));
    provider_registry.register_hosting_provider(Arc::new(Sourcehut));
}

/// Registers additional Git hosting providers.
///
/// These require information from the Git repository to construct, so their
/// registration is deferred until we have a Git repository initialized.
pub fn register_additional_providers(
    provider_registry: Arc&lt;GitHostingProviderRegistry&gt;,
    repository: Arc&lt;dyn GitRepository&gt;,
) {
    let Some(origin_url) = repository.remote_url(&quot;origin&quot;) else {
        return;
    };

    if let Ok(gitlab_self_hosted) = Gitlab::from_remote_url(&amp;origin_url) {
        provider_registry.register_hosting_provider(Arc::new(gitlab_self_hosted));
    }
}
</code></pre><p>ここでgithub.com以外の処理を諦めている。</p><p><a href=https://github.com/zed-industries/zed/blob/2e7bb11b7d5de6a79bef2491fa5ce8ecfd2bca15/crates/git_hosting_providers/src/providers/github.rs#L111-L128>https://github.com/zed-industries/zed/blob/2e7bb11b7d5de6a79bef2491fa5ce8ecfd2bca15/crates/git_hosting_providers/src/providers/github.rs#L111-L128</a></p><h3><a href=#%e6%89%80%e6%84%9f id=所感 class=anchor aria-hidden=true>所感</a></h3><p>現在のプロジェクトがどのGitHostingProviderを使っているかを誰も管理していない（？）ぽくて、外部からそれに依存した操作をする際は、GitHostingProviderRegistryに登録されたもの全てを試してうまくいった結果を使う、としているのがよくなさそう。以下のように作りを変えると良いだろう。</p><ul><li>まずはプロジェクトに対してGitHostingProviderを対応づけること</li><li>外部からGit関連の操作をするときはRegistryを経由しないでプロジェクトをに登録されているGitHostingProviderを使うこと</li><li>必要に応じて手動で対応づけや設定をできるようにすること</li></ul><p>あるいは拡張機能としてねじ込むのが正解か？GitHubとGitHub Enterprise Serverの違いがどんなものか次第でもあるので、そちらの調査もしたい。</p><h2><a href=#zed%e3%81%ae%e6%8b%a1%e5%bc%b5%e6%a9%9f%e8%83%bd%e3%82%92%e4%bd%9c%e3%82%8b id=zedの拡張機能を作る class=anchor aria-hidden=true>Zedの拡張機能を作る</a></h2><p>LSPサーバがある前提で、そのクライアントをZedに追加する。PythonのLSPクライアントの実装があるので、それを参考にbuf LSPを使えるようにする。</p><p><a href=https://github.com/rgbkrk/python-lsp-zed-extension/blob/main/src/python_lsp.rs>https://github.com/rgbkrk/python-lsp-zed-extension/blob/main/src/python_lsp.rs</a></p><p>何も理解してないけどローカルでクライアントをビルドして定義ジャンプを実行するところまではできた。次は何が起きているかを調べていい感じにする。
zedにマージするまでがゴール。</p><p>Zed extensionを理解して、gitのアレをextensionとして実現できないか判断したい。</p></p></div><div class=post-footer><time>February 11, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-02-07/>吉祥寺.pmとBurikaigiに登壇参加した</a></h2><div><p><p>1/31に吉祥寺.pmのLT、2/1にBuriKaigiのセッションで発表しました。カレンダー上で予定かぶっていないことだけしか確認せず勢いで楽しそうなカンファレンスの楽しそうな枠に申し込んだところ、発表の間の時間が12時間くらいしかなくて大変でした。とはいえそれぞれの発表に対して準備をして知見を得られたし、聴衆と意思疎通できたとも思っています。登壇できてよかった。</p><p>主催者のかた、参加者のかた、ありがとうございました！</p><p>この記事では発表したことにフォーカスして感想をメモしますが、参加者として発表を聴いたり懇親したりするのもとても楽しかったし刺さるセッションがいくつもありました。本当に参加できてよかった。</p><h2><a href=#%e5%90%89%e7%a5%a5%e5%af%bapm id=吉祥寺pm class=anchor aria-hidden=true>吉祥寺.pm</a></h2><p>waiwai-aiを入社2ヶ月の エンジニア3人と作るための さいきょうのアーキテクチャ<a href=https://speakerdeck.com/naoyafurudono/waiwai-aiworu-she-2keyue-no-ensinia3ren-tozuo-rutameno-saikiyounoakitekutiya>（スライド）</a>では、昨年5月に新卒研修の一環（自分はメンター）で参加したお産合宿について話しました。</p><p>逆コンウェイの話をツイッターで指摘していただいたり、ブログで記事を参照していただいたりと反応を頂けて嬉しいです。</p><p>お産合宿は業務での開発が佳境な時期に参加しており、直前まで本当に参加できるかも怪しかったことを思い出します。翌日のBuriKaigiでwaiwai-aiを発展させたデモを3人の新卒エンジニアのうちの一人がしており、意外と長生きだなと思います。</p><h2><a href=#burikaigi id=burikaigi class=anchor aria-hidden=true>BuriKaigi</a></h2><p>CLIツール開発をProtocol Buffers スキーマで駆動する<a href=https://speakerdeck.com/naoyafurudono/cliturukai-fa-woprotocol-buffers-sukimadequ-dong-suru>（スライド）</a>ではHow to Design Programsを引用して、上手なプログラミングはどのように行うものであるかを主張しました。そこでは関数を実装するための上手いやり方を主張しており、それをWeb API開発やCLI開発に応用する（より大きな粒度のエンジニアリングに適用する）ために、具体的に何をすれば良いのかや、どのような障壁がありそれらはどう取り除けるのかを主張しました。</p><p>スキーマ駆動のこととCLIについての話をすることだけ先に決めており、How to Design Programsやそのアイデアを引用すると良いことに発表直前の月曜日に気がついたため準備が忙しかったです。今回の最大の収穫はその気づきを得たことだと考えています。学生の頃に取り入れた知見がまさかこんな形で役に立っていたとは思わずすっきりした気持ちになりました。</p><p>セッション直後に余った時間で2,3名の方から質問を頂けた（しかも芯を喰っていた！）し、ツイッターやブログでも感想をいただけたので主張は伝わったのだろうと感じています。嬉しい。</p><p>鰤しゃぶを初めて食べたのですがとてもおいしかったです。また食べたい。</p><h2><a href=#%e8%a3%8f%e3%83%86%e3%83%bc%e3%83%9e-%e4%b8%8a%e6%89%8b%e3%81%ab%e7%99%ba%e8%a1%a8%e6%ba%96%e5%82%99%e3%81%99%e3%82%8b id=裏テーマ-上手に発表準備する class=anchor aria-hidden=true>裏テーマ: 上手に発表準備する</a></h2><p>また今回は資料作りについて裏テーマを二つ設けていて、それらがうまくいったのも嬉しかったポイント。</p><ol><li>スライドデッキの構成を決めてからスライドをつくる。スライド作成での手戻りを極力減らす</li><li>図を上手につくる</li></ol><p>発表の準備に時間がかかること、疲れることがこれまでの課題だった。考えることに時間と体力を使いたい、思考の速度で準備したいのがモチベーション。今まではスライドデッキを作ってから「この主張をここでしてもしょうがないな」とか「この図はいらないな」が多少あった。それらを排除して不要なスライドを作成するのに労力を割かないようにするのが1個目の目標。</p><p>CfPがあるタイプのセッションだったので、発表内容が完成する前にタイトルとセッションの内容を決める必要があったのが効いたと思う。考えているうちにそれが本題ではなくなってしまったのだが、うまく話を構成するためにだいぶ主張と構成を練ることに繋がった。あと、時間が本当になかったのと完成度に対する欲求があったので、この目標を達成することが満足のいく発表をするための必要条件でもあったのだ。切羽詰まった結果実現できたパターンでもあったということ。</p><p>Google Slideの作図機能はそこまでリッチなわけではないし、どんなに頑張っても限界がある、表現力もそんなにという具合で、サクッと数分で準備をするには良いが気合いを入れるときに使うものではないと感じていた。出来上がる図も綺麗でもなければ図自体がわかりやすくなることはなかったと思う。全体的にいい感じに仕上げることは何度かできたけど。</p><p><a href=https://www.drawio.com/>draw.io</a>を試しもしたが、字が小さいとか矢印の扱いが難しいとかでしっくりきておらず他のツールをなんとなく探していたのだった。そんな中、発表直前の木曜日に自席に遊びにきていたデザイナの同僚から紹介された<a href=https://www.figma.com/ja-jp/figjam/>FigJam</a>がいい感じ。初めて紙で書くより上手に図を書けている。矢印が本当にいい感じになるし色んな微調整もしやすい。</p><p>学生の頃はこのあたりのテクニックなしで、発表の数日前からギリギリの顔をして資料作成にフルコミットすることで乗り越えていたが、今回は日中は仕事をしつつ準備を終えることができた。成長。</p></p></div><div class=post-footer><time>February 7, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-01-26/>2025-01-26</a></h2><div><p><h2><a href=#etchosts-%e3%81%a7%e3%83%84%e3%82%a4%e3%83%83%e3%82%bf%e3%83%bc%e3%82%92%e5%b0%81%e5%8d%b0 id=etchosts-でツイッターを封印 class=anchor aria-hidden=true>/etc/hosts でツイッターを封印</a></h2><p><code>/etc/hosts</code> で以下のようにしてツイッターを封印している。</p><pre><code>127.0.0.1     twitter.com
127.0.0.1     x.com
</code></pre><p>次の週末にある登壇資料を作っている。インターネットにある情報を拾う必要のあるケースもあるので、インターネットには繋がりたいが、ツイッターを開いた瞬間に全てが終わる。そんなぼくをがツイッターに吸い込まれるのを防ぐために、DNS問い合わせを潰している。だいぶ助けられている。</p><h2><a href=#%e7%99%ba%e8%a1%a8%e6%ba%96%e5%82%99 id=発表準備 class=anchor aria-hidden=true>発表準備</a></h2><p><a href=https://www.graco.c.u-tokyo.ac.jp/labs/morihata/presentation_memo.htm#o-enumerate>https://www.graco.c.u-tokyo.ac.jp/labs/morihata/presentation_memo.htm#o-enumerate</a> これを読みながらやっている。学生の頃からチラチラ見ていたが、だんだん染み付いてきた。</p></p></div><div class=post-footer><time>January 26, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-01-13/>2025-01-13</a></h2><div><p><h2><a href=#%e3%83%93%e3%83%bc%e3%83%ab%e5%b7%a5%e5%a0%b4%e8%a6%8b%e5%ad%a6 id=ビール工場見学 class=anchor aria-hidden=true>ビール工場見学</a></h2><p>昨日は友達とキリンビール工場に行ってきた。500円のツアーがあってビール作りの概要を教えてもらいつつビールを飲ませてもらえる。だいぶ楽しかった。あの体験は優しさで成立していると思う。</p><p>原料となる麦やホップを食べさせてもらえたほか、ビール製造の中間生成物である麦汁の飲み比べをさせてもらえた。何より説明してくれるお姉さんがビール好きで、1つ質問すると厳選した3つを返してくれるのが良かった。一緒に飲んで欲しい。飲ませてもらったビールもめちゃくちゃおいしいし。併設されているレストランに行けていない（リサーチ不足でご飯を食べてから行ってしまった）のと、他にも見学コースがあるみたいなのでまた行きたい。</p><p>ホップを使ったリンスを買って使ってみたら、髪からフルーティ系なビールの匂いがして最高。</p><h2><a href=#ai%e3%81%a8%e8%81%b7%e6%a5%ad%e3%82%bd%e3%83%95%e3%83%88%e3%82%a6%e3%82%a7%e3%82%a2%e3%82%a8%e3%83%b3%e3%82%b8%e3%83%8b%e3%82%a2%e3%83%aa%e3%83%b3%e3%82%b0 id=aiと職業ソフトウェアエンジニアリング class=anchor aria-hidden=true>AIと職業ソフトウェアエンジニアリング</a></h2><p>AIに仕事を奪われることはないだろう。とはいえ単に作業をするだけの労働はAIに奪われる。コードを単に書くのは作業であって、仕様からコードを生み出すだけならAIでやった方が早いし（今の相場なら）安いから。</p><p>とはいえそんな単純作業が仕事であることはなくて、将来のこととか仕様の考慮に入っていなかったことをコードを書きながら調整して主体として責任を持って成果を出すことは、社会がまだAIに対して認めていないように感じる。</p><p>誰もが優秀な部下を持つようになったが、人々は誰かに責任を持った主張をして欲しくいのだろう。ポジションをとって主張をし、ダメだったときは失落したり挽回することを人格に求めている。信頼をして仕事を任せる相手は人間じゃないと嫌だと社会が思っている。</p><h3><a href=#%e4%ba%ba%e9%96%93%e3%81%8b%e3%82%89%e3%81%ae%e5%bd%b9%e5%89%b2%e6%9c%9f%e5%be%85%e3%81%8c%e7%94%9f%e6%88%90ai%e3%82%92%e5%be%8b%e9%80%9f%e3%81%99%e3%82%8b id=人間からの役割期待が生成aiを律速する class=anchor aria-hidden=true>人間からの役割期待が生成AIを律速する</a></h3><p>そういうわけで人間は労働力としての生成AIを手に入れただけであって、人間社会で主体として認められたあらたな人格を手に入れたわけではない（今のところは）。成果を出すためには社会が理解できるポジションを取ることが必要で、そのロールモデルの振る舞いとして社会と交流しないといけない。どんな振る舞いをするのが良いか決めるために生成AIを駆使する仕事の仕方が増えるだろう。ロールモデルには矛盾なくとりうるアトミックな行動があって（思想とか哲学みたいなもの）、それを組み合わせることでその人らしい振る舞いが形成される。思想とか哲学とかに一貫性がないと社会から信頼してもらえない。一方で外部から同じ要求がなん度もくることはないため、それに応じた異なる振る舞いをする必要はある。思想や哲学から外部刺激に対して振る舞うことにはエネルギーとか思考とかが必要で面倒だから生成AIを使うと便利だろう。</p><p>これはプログラミングにも応用できる。アプリケーションのコアなロジックのインターフェースは綺麗に設計されてクライアントから受け入れてもらう必要がある。そこがブレると利用するのがそもそも大変だし、見出した価値がすぐに失われてしまうだろう。一方で、それを活用して振る舞いを追加したり修正することは生成AIがこなすだけで十分なのではないだろうか。振る舞いを追加することは、そのアプリケーションのコアな部分のインターフェースと世の中によく知られた技術要素のインターフェースを組み合わせて表現できるだろう。</p><h3><a href=#%e5%bd%b9%e5%89%b2%e6%9c%9f%e5%be%85%e3%81%ae%e5%a4%89%e5%8c%96%e3%81%ab%e3%81%af%e3%82%af%e3%83%a9%e3%82%a4%e3%82%a2%e3%83%b3%e3%83%88%e3%81%ae%e5%a4%89%e5%8c%96%e3%81%8c%e5%bf%85%e8%a6%81 id=役割期待の変化にはクライアントの変化が必要 class=anchor aria-hidden=true>役割期待の変化にはクライアントの変化が必要</a></h3><p>外部からの要求に応答して振る舞いをしたりインターフェースを利用して新たな機能を提供する際に、コアな思想を見直してアップデートすることもあるだろう。とっているポジションをちょっと変えるということ。使う側からすると理解の仕方をちょっと変えないといけないのでこの変更が気に食わなかったり理解できなかったりすると嫌な感じがする。変化の速度が早すぎて理解が追いつかないとたとえ良い変化であったとしてもアンチになってしまい信頼をなくすことに繋がる。そのため人間に直接理解されるインターフェースは人間に合わせた進化をしないと社会に適合できなず、市民権を失う。</p><p>したがって生成AIはインターフェースを提供するソフトウェアエンジニアの職業を奪うことはない。一方でインターフェース設計に関与しない、定義されたインターフェースの中だけで作業をして、他人と相互作用をするインターフェースを定義しないエンジニアリングは生成AIのコストに負けて自動化されるだろう。</p><h3><a href=#%e5%bd%b9%e5%89%b2%e3%81%ae%e8%a8%ad%e8%a8%88%e3%81%af%e5%ae%89%e5%ae%9a%e3%81%97%e3%81%a6%e3%81%84%e3%82%8b%e3%81%a8%e6%80%9d%e3%81%86 id=役割の設計は安定していると思う class=anchor aria-hidden=true>役割の設計は安定していると思う</a></h3><p>次に、他人と相互作用するインターフェースのあり方が変化するかが問題になる。これまで公開されて使われていたようなインターフェースは今後も必要だろうか。インターフェースを解釈するのが生成AIだけになれば、その変化が早くても理解が追いつくためわざわざポジションをとったり人間の理解速度に変化の速度に合わせる必要がなくなる。これは作り上げるものの抽象度の違いに依存するだろう。何かを作り上げたかったらその一段下の抽象度の言葉で構成を説明してほしい。妥当性を検証するために。そこから下は信じることにして（信じられる何らかの根拠を持つことになる、ここも何か困難があるかも、今は著名なOSSだからokとか言って信用することにしている）、欲しいものの一段下のレイヤで自分で納得がいけば良いものであると判断する。</p><p>そして、人間の思考とか議論のレイヤは高々10とかにおさまっており、それが生成AIの登場で変わるとも思わない。なのでインターフェースを人間が作ってポジションをとる必要性も今後変わらないと思う。根拠はなくて直感だし、多分僕の願望も入っっている。</p><h3><a href=#%e7%8e%8b%e9%81%93%e3%81%ae%e5%bd%b9%e5%89%b2%e3%81%af%e3%81%95%e3%82%89%e3%81%ab%e5%af%a1%e5%8d%a0%e3%81%95%e3%82%8c%e3%82%8b id=王道の役割はさらに寡占される class=anchor aria-hidden=true>王道の役割はさらに寡占される</a></h3><p>良いインターフェースを定めるために、鍛錬を積む必要はあり、それは生成AIによって取って代わられる仕事でなされることが多い。生成AIを使って仕事をやる先端のインターフェース提供者と、そこから学べない後進が場所によっては生成AIがやる仕事をするローカライズされたインターフェースの提供者が並行して存在する世界になるだろう（生成AIに限らずこの状況はあるだろうが）。</p></p></div><div class=post-footer><time>January 13, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-01-04/>2025-01-04</a></h2><div><p><h2><a href=#rust%e3%81%ae%e3%82%8f%e3%81%8b%e3%82%89%e3%82%93%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88 id=rustのわからんポイント class=anchor aria-hidden=true>Rustのわからんポイント</a></h2><p>過去に何個か一人でCLIツールを作ったことがある。そのときに雰囲気で乗り越えてしまいストレスの少ない綺麗な書き方を知りたかった概念をあげる。</p><ul><li>エラーハンドリング</li><li>参照周りの型変換<ul><li>特にパターンマッチやforループ、関数定義で <code>&</code> 記号を書く構文特有の意味があるときがよくわからない</li></ul></li><li>ライフタイム<ul><li>実用的に我々はどんな塩梅で書くのが良いかとか、誰が所有するのが良いかを判断するためのベストプラクティスを持っていない</li></ul></li><li>トレイトの勘所<ul><li>ユーザ定義型に機能を実装するときに、どういうインターフェースを持たせるか迷う。どのようなトレイトを実装するかを決められない。クライアントとしての標準を知らないのでサーバとして何を提供するか、常識をもとに判断できない</li></ul></li></ul><h2><a href=#%e6%b7%b1%e5%a4%9c%e3%81%abai%e3%81%ab%e4%bb%95%e4%ba%8b%e3%82%92%e3%81%a9%e3%82%8c%e3%81%8f%e3%82%89%e3%81%84%e5%a5%aa%e3%82%8f%e3%82%8c%e3%82%8b%e3%81%8b%e8%80%83%e3%81%88%e3%81%9f%e3%81%a8%e3%81%8d%e3%81%ae%e3%83%a1%e3%83%a2 id=深夜にaiに仕事をどれくらい奪われるか考えたときのメモ class=anchor aria-hidden=true>深夜にAIに仕事をどれくらい奪われるか考えたときのメモ</a></h2><p>要件を定めてそれを保証する仕事がソフトウェアエンジニアの仕事になるだろう。それだと単発の仕事か。進み方を把握して、それを促進する作りにする必要はあるはず。</p><p>プログラムの開発（状態や環境に反応するソフトウェアの開発）自体は生成AIによって簡単になった。要求や要件を実現することしかまだ生成AIのブラックボックスに入れられていない。要求や要件の整理の道具として生成AIを利用してはいるが、</p><p>これからは生成したプログラムに対して保証された機能の制限が大事になってくるだろう。プロダクション環境で動くプログラムを見る人間は減り、その代わりにソフトウェア検証、パーミッションの制限で安全性を保証したり、デモで振る舞いを確認する未来がくるだろう。ソフトウェアを実装するコストが低くなり、つまりソースコードに向き合う機会が減り、コードの振る舞いを静的に理解しなくなっていく。あるいは言語を高級にするだろうか。言語にどんな性質があると幸せ？</p><p>生成して良い言語に良い性質を持たせることはありそうなアプローチ。</p><h2><a href=#%e7%b6%9a%e3%81%8d id=続き class=anchor aria-hidden=true>続き</a></h2><p>仕事は確かにたくさん奪われそうだけど、契約をデザインして（うまくそれを表現することを含む！）プログラムを作り上げる営みは楽しいからずっと続けると思う。</p></p></div><div class=post-footer><time>January 4, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2025-01-03/>2025-01-03</a></h2><div><p><h2><a href=#go%e3%81%a7%e3%82%a8%e3%83%a9%e3%83%bc%e3%81%ab%e3%82%b9%e3%82%bf%e3%83%83%e3%82%af%e3%83%88%e3%83%ac%e3%83%bc%e3%82%b9%e5%85%a5%e3%82%8c%e3%82%8b%e8%a9%b1 id=goでエラーにスタックトレース入れる話 class=anchor aria-hidden=true>Goでエラーにスタックトレース入れる話</a></h2><p><a href=https://dev.nfurudono.com/posts/go-errors-stacktrace>https://dev.nfurudono.com/posts/go-errors-stacktrace</a> に移転しました。</p><h2><a href=#%e6%8e%83%e9%99%a4 id=掃除 class=anchor aria-hidden=true>掃除</a></h2><p>大掃除は年末にしたのだけど、コーヒーグラインダーを掃除し忘れていたのでやった。結構な量の粉が中から出てきて驚いた。豆を砕く場所と粉が出てくる穴の間に傾斜した通路があってそこに溜まっていた。</p><h2><a href=#%e6%96%99%e7%90%86 id=料理 class=anchor aria-hidden=true>料理</a></h2><p>今日も餃子を作った。昨日たねを作りすぎたので。ちょうど買い足した餃子の皮を消費できた。蒸しと焼きの両方やって昨日と同じ感想だった。たねを作るときに白菜の水分を抜く工程を入れていたが次回は外してみようと思う。</p><p>明日は鮭のホイル焼きをしようと思う。衛宮さんちの今日のご飯に感化された。</p><ul><li>鮭・玉ねぎ・にんじん・しめじを適切に処理する<ul><li>鮭には酒と塩を振って5-10min放置してから拭き取る</li><li>その後酒に塩胡椒を振る</li></ul></li><li>玉ねぎ・にんじんを敷いて、その上にコンソメをかける</li><li>全てを載せつつバターも添えてホイルに包む</li><li>加熱する</li><li>パセリか何かをかけるらしい</li><li>わさびマヨがあっても良いとか</li></ul><p><del>朝は納豆とかかな。卵も食べよう。</del>
朝はサンドウィッチにする。ほうれん草、卵、ベーコンを入れたい。卵しかないので買い出しが必要。パンもない。</p></p></div><div class=post-footer><time>January 3, 2025</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-12-25/>2024-12-25</a></h2><div><p><h2><a href=#%e5%a5%91%e7%b4%84%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0%e4%b9%b1%e6%96%87%e3%81%a7%e3%81%99 id=契約プログラミング乱文です class=anchor aria-hidden=true>契約プログラミング（乱文です）</a></h2><p>関数の引数はそれぞれ何で、どんな性質を期待するかや、そのほかの事前条件を満たした上でこの関数を呼び出すと、その結果としてどんな返り値が得られてそれ以外にどんな副作用があるかを表明するのが関数の契約。文章を用いるのが簡単だし、伝えやすくするには図を用いても良いし、型とかバリデーションのための式で表現しても良い。何にしても契約を表明すると楽しくプログラミングできる。</p><p>この関数の呼び出し側はどんなふうにこの関数を使って処理を実現するだろうかとか、この関数を実装するときはどんなふうに作ろうかと考えるのがまず楽しい。みんなが幸せになれる契約をデザインするのが楽しい。ソフトウェアのテストは契約を守っていることを検証することだと思う。型を用いた表現は契約の表明で、型検査が検証（それも厳密な）である。</p><p>このように良い契約をデザインするのがプログラミングでまずやることだと思う。その次に自動で検証するためのコードを書くのがTDDの人だし、関数型の怖い人は型で契約を表現しようとするかもしれない。そのためにすごい表現力を持つ型システムを考えて勉強して使う印象がある。</p><p>TDDで最初から完成版のテストを書かないことからわかるように、契約を最初から詳細まで書く必要はない。そんな契約を満たす実装を書けるだろうかと思うこともある。なので最初はふんわり「ユーザの情報を返すAPI」とか決めておいて、IDが欲しいとか、シャーディングしてるから作成日時も欲しい、みたいな事前要件を足したり、ユーザ情報全部返すのはきついし呼び出しがわも幸せじゃないから、名前とメルアドだけ返すことにする、みたいな調整も入るだろう。課金が滞っているユーザに対しては普通の結果は返さない、代わりにエラーを返す、みたいな変更も実装したり呼び出しているうちにしたくなるはず。</p><p>結局のところ普通のプログラミングをしようと言っているだけなのだが、僕が強調したいのは契約と実装を分けて考えようということ。契約が先にあってそれに実装を合わせる（合ってない状態はバグってる状態）考え方でいたいし、僕と契約を共有する人には（その共有する契約のレイヤで）いて欲しいと思う。</p><p>僕はmac osのコードがどうなっているかを気にすることはなくて、普通にパソコンが動けば満足するし、実際動いているので不満はない。キーボード叩いたら文字が出るという契約を守ってくれている。でもosのapiを叩く友達はそもそもドキュメントが公開されてなくて辛い、みたいなことを言っていた。このように、自分が関心のあるレイヤの契約が問題になるのだと思う。</p><p>契約はプログラミングの細かいレベルだと変数の名前とか、改行の置き方によって表明されるもので、大きいレベルだとサービスやロールの責務として表現されると思う。サービスのAPIは代表的な契約だと思う。APIという言葉は契約と同じような意味だと思うけど、エンドポイントみたいな意味でも使われているし責務みたいな概念には適用されないと思っていて使わない。</p><p>僕たちが欲しいものは何かを表明しよう、というのが契約を表明しようということだと言い換えられる。使う側からしたらその実現方法は関係ないし、提供する側からしたら契約さえ満たせば何をやっても良い。
getterとsetterを提供するからと言ってそういうフィールドをよく知られた方法で提供しないといけないわけではないし、バッファリングとか遅延実行をしても良い。</p><p>未定義な状況とか意図しない状況はある。今と昔では状況が変わって、その頃は妥当に思えた契約が時代に合わなくなることもある。契約がないと実装が良くないで話が終わってしまうが、契約があれば仮定が違ったのだと結論づけられる。人の記憶があればその人の心に契約があって仮定が違ったと判断できるだろう。記憶を失ったりその人が失われたりする場合は契約を表明しておくべきだろう。</p><p>型はデータ構造やその不変条件を表現したりそれらに名前をつけることで、契約を表現する。そして型を用いて表明された契約は普通型検査によって契約が満たされていることを検証する。正しい場合には正しいと判定するし、正しくない場合には正しくないと判定する。さらに、ある程度ちゃんとした型検査器は、どのように契約が満たされなかったかを説明してくれる。</p><p>テストは契約を検証するためのコードで、そのテストが契約のどんな部分を検証するか、テストケースの名前として表明される。その表明を満たすようにテストコードが実装されて、テストランナーに呼ばれる。契約のどんな側面をそれぞれのテストケースで検証するか、検証すると幸せか（誰にとって？）を決めるのはテスト実装者のスキルに依存するだろう。契約の中で脆いところを普通は検証するのだろう。明らかに正しそうなやつは手を抜いてしまえるはず。</p><p>バリデーションも契約を表現する手段の一つ。契約を検証処理として実装して表明するのがバリデーション。型と同じようにすべての実行について契約が満たされるかを検証する。一方でテストと同じように実際に動くものに対して検証を行う。</p><p>実際に動かして試すのは何だろう。契約とはあまり関係なさそう。実装したやつがどんな感じになってるか微妙なので試して動作を観察するのがとりあえず動かしてみる目的。これは脇道だったな。ただし、あまりによくわからなくなっているときは分割統治をするときだと思う。自分の手の中にある対象をコンポーネントに分割して、それぞれに対して契約をデザインする。その契約を満たすように実装しつつ、その契約を期待して組み合わせて元々の目的を達成すれば良い。わからない部分が新しい契約の内側にはいれば小さくなった簡単な契約を満たすことに問題は帰着できたし、それらの契約を組み合わせることに課題があるなら詳細を忘れて便利な道具を手に入れられたのだからやはり問題は簡単になっているはず。うまく契約を設計することが難しいなら、それは楽しいから問題ない。ずっと取り組んでいればいい。</p><p>何にしても契約を表明することが何より先にくる。これだけでプログラミングが楽しくなる。その後に型、テスト、バリデーションを書いたり実装をしたりする。</p><p>そういう考え方が how to design programsにデザインレシピとして書いてあるのでよかったら読んでみてください。</p><p>プログラミング言語はこの辺りが優秀で、型システムの研究とかで契約を表明して保証する方法を検討しているし実際に生かされている。なので言語に守られているうちは割と安心できる。あとは怠慢にならなければいいだけ。</p><p>プログラミング言語に閉じられなくなるとき、例えばWeb APIを提供するときは急に難易度が上がる。Web APIでも契約を表明して検証するためにスキーマ駆動開発がある。契約を書き下すことを支援するのはもちろん、型とかバリデーションで表明することも支援する。テストツールの支援もある。</p><p>僕たちが求めているのは以下である。</p><ul><li>契約を表明すること</li><li>契約を洗練すること</li><li>契約を犯せないようにすること</li><li>契約を犯しかけたらなるはやで誰かに教えてほしい</li><li>これらを簡単に実現できること</li></ul><p>最初のやつは設計しようぜ！という話。次が設計技法とか良い設計みたいな話。三つ目は型とかバリデーション、テストの話。次もそう。最後のやつはそれら全てを支援するエンジニアリングの話。</p><h2><a href=#%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0%e3%83%91%e3%83%a9%e3%83%80%e3%82%a4%e3%83%a0 id=プログラミングパラダイム class=anchor aria-hidden=true>プログラミングパラダイム</a></h2><p>契約の話をしたのでパラダイムの話をしたい。オブジェクト指向と普通のやつの話。どっちでもいいけど、契約を表明しやすいパラダイムが良いと思う。</p><p>オブジェクト指向な考え方だと、内部状態を持つオブジェクトがメソッドを受信してその結果内部状態を変えたり返信したりする。そういうふうに契約を表明して守っていくならオブジェクト指向を使えばいい。</p><p>関数型みたいな普通のやつは、仮定が与えられた状況で関数を呼ぶと結果を出す。そういう契約の書き方をするなら関数型みたいに書けばいい。</p><p>どちらも相互に変換可能だから力まず表現しやすい言葉遣いを使えば良いだろうと思う。</p><h2><a href=#%e6%84%9f%e6%83%b3 id=感想 class=anchor aria-hidden=true>感想</a></h2><p>割と思いの丈をダンプした。これは就職したからできたことのように思う。学生の頃に培った理想が現実世界では必ずしも簡単に実現しないことを体験できた。自明だと思っていた領域の非自明な部分に気がついて思うところが出てきた。</p><h2><a href=#%e5%a5%91%e7%b4%84%e3%82%92%e8%a8%ad%e8%a8%88%e3%81%99%e3%82%8b%e6%a5%bd%e3%81%97%e3%81%95 id=契約を設計する楽しさ class=anchor aria-hidden=true>契約を設計する楽しさ</a></h2><p>プログラミングの楽しいところは、ロールを分けてうまく契約群を設計することにあると思う。フレームワークを作るのはそういう契約の集まりを定義することだから楽しい。一方でフレームワークを使うと契約を設計する機会を奪われる分楽しくないかもしれない。</p><p>その分他のレイヤに注力すればいいのだろうが。</p><p>自分が自由に設計したいレイヤで他人に契約を決められるとストレスだろう。本当につまらない。反対に自分が関心なくて誰かにうまくやって欲しいときには良い契約を強い人に決めて欲しいと思う。そういうレイヤを担当するフレームワークを使って欲しいし、技術を選定したい。</p><p>アーキテクチャ設計についても言及できそう。アーキテクチャは中長期的には変遷するものだが、短期的には変わらない。アーキテクチャに乗っかってここのコンポーネントを作り込む。ここのコンポーネントをストレスなく作り込みやすくするアーキテクチャが良いアーキテクチャなのだろう。</p></p></div><div class=post-footer><time>December 25, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-12-13/>2024-12-13</a></h2><div><p><ul><li><input disabled type=checkbox> kamakura.goの感想とかを書く</li></ul></p></div><div class=post-footer><time>December 13, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-12-12/>2024-12-12</a></h2><div><p><blockquote><p>We recommend that all third-party code generators be written as plugins, as this allows all generators to provide a consistent interface and share a single parser implementation.</p></blockquote><p><a href=https://protobuf.dev/reference/other/#plugins>https://protobuf.dev/reference/other/#plugins</a></p><p>はえ〜って感じ。Goのライブラリはだいぶ使い勝手良かったのでまあ確かにと思ってる。</p></p></div><div class=post-footer><time>December 12, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-12-05/>2024-12-05</a></h2><div><p><p>viperってinit使わないといけないのかな。
viperに依存性を注入するような使い方をしたい。Facadeを受け取ってCLIを返すようなCLIジェネレータを定義しようとしていて、CLIジェネレータを実装するためにviperの諸々をinitとかで終えようと思うと困る。実行時にfacadeを入れたいので。</p></p></div><div class=post-footer><time>December 5, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-11-28/>2024-11-28</a></h2><div><p><p>Reactのカスタムフックの心をわかっていなかったけど、クロージャに変数をキャプチャさせて、状態をもつクロージャ（の組）を返す関数がカスタムフックぽい。組と言ったのは、getterとsetterが別々に提供されることがあるから。例えば <code>const [v, setV] = useState()</code> は <code>v</code> がgetterで <code>setV</code> がsetterと思える。</p><p>カスタムフックの呼び出しもとの再レンダリングのたびに返却する関数の実態が同じにするかしないかは、<code>useCallback</code> を用いて制御できる。例えば <code>useState</code> は <code>useCallback</code> してると思える。</p><p>このようなプログラミングテクニックを用いると、振る舞いを実現するクロージャだけが定義されていて、それが裏で扱う状態遷移がフック定義の中で隠蔽されるのが嬉しい。</p><p>カスタムフックのモチベーションは単に状態を関数型っぽいやり方で扱いたいだけなのだと理解した。</p><p><a href=https://courses.cs.cornell.edu/cs3110/2021sp/textbook/mut/ex_counter.html>OCamlでのmutable counterの実装例</a>を見つけた。鉄板の例だと思う。僕はこれをイメージして状態を保つクロージャと呼んでいた。</p></p></div><div class=post-footer><time>November 28, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-11-27/>2024-11-27</a></h2><div><p><ul><li><input disabled type=checkbox> <a href=https://incepter.github.io/how-react-works/>https://incepter.github.io/how-react-works/</a> これ面白そうなので読む。定期的にくるReactの仕組みを深掘りしたくなる時期。</li><li><input disabled type=checkbox> ブログのMakefileを書く</li></ul><h2><a href=#branded-type%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%a6%e3%81%bf%e3%81%9f id=branded-typeを使ってみた class=anchor aria-hidden=true>Branded typeを使ってみた</a></h2><p>Branded typeはTSでnominal typingっぽいことをするためのプログラミングテクニックの一つ。<a href=https://zenn.dev/okunokentaro/articles/01gmpkp9gzfyr1za5wvrxt0vy6#branded-types>Branded Typesを導入してみる / TypeScript一人カレンダー</a> が詳しい。</p><p>僕はこんな感じに実装に入れてみた。<a href=https://github.com/naoyafurudono/naoyafurudono.github.io/commit/778270955b4c4e7672f50600fb28dff6c12b9fa0>https://github.com/naoyafurudono/naoyafurudono.github.io/commit/778270955b4c4e7672f50600fb28dff6c12b9fa0</a></p><p>全てがstringになりがちで不安になるけど、これなら安心安全。型の名前を信用できるようになって、名前をつける意欲も湧く。嬉しい。</p><h2><a href=#makefile%e3%81%aehelp id=makefileのhelp class=anchor aria-hidden=true>Makefileのhelp</a></h2><p>makeって、ある種CLIのDSLみたいなものだが、helpを自動生成してはくれない。いい感じにやるための工夫を見つけたのでシェアする。</p><p>以下は<a href=https://github.com/connectrpc/examples-go/blob/5f010eac8870fcd366b804f2734efe80b29ae5a0/Makefile#L17-L29>connectrpcのサンプル実装リポジトリにあったmakefileの一部</a>。</p><pre><code class=language-makefile>.PHONY: help
help: ## Describe useful make targets
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = &quot;:.*?## &quot;}; {printf &quot;%-30s %s\n&quot;, $$1, $$2}'


.PHONY: all
all: ## Build, test, and lint (default)
	$(MAKE) test
	$(MAKE) lint


.PHONY: clean
clean: ## Delete intermediate build artifacts
	@# -X only removes untracked files, -d recurses into directories, -f actually removes files/dirs
	git clean -Xdf
...
</code></pre><p><code>make help</code> とすると、呼び出せるmakeのtarget一覧とその説明を出力してくれる。便利。コメントのフォーマットを定めておいて、helpを呼ぶときにはawkとかでmakefile自身を処理することでヘルプを出している。</p></p></div><div class=post-footer><time>November 27, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-11-26/>2024-11-26</a></h2><div><p><h2><a href=#%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%82%ab%e3%83%b3%e3%83%95%e3%82%a1%e3%83%ac%e3%83%b3%e3%82%b9%e3%83%a1%e3%83%a2 id=アーキテクチャカンファレンスメモ class=anchor aria-hidden=true>アーキテクチャカンファレンスメモ</a></h2><p><a href=https://architecture-con.findy-tools.io/>https://architecture-con.findy-tools.io/</a> これに来ている。</p><p><a href=https://findy-tools.io/events/archives/architecture-con-2024/1/materials>登壇資料のまとめがあるとのこと</a>。</p><p>これはあくまで僕のメモであって、発表とか僕がお話しした人がこのまま主張したわけではないです。変なところがあれば僕のせいだし、良い主張があれば彼らのおかげです。繰り返しですが僕のメモなので第三者が読んで何かに活かしたり議論の種にすることは、しない想定です。僕が便利なのでインターネットにおいておくだけ。</p><h3><a href=#%e7%99%ba%e8%a1%a8 id=発表 class=anchor aria-hidden=true>発表</a></h3><h4><a href=#%e3%82%ad%e3%83%bc%e3%83%8e%e3%83%bc%e3%83%88 id=キーノート class=anchor aria-hidden=true>キーノート</a></h4><ul><li>トレードオフ分析をすることが仕事<ul><li>最強ソリューションを出すことではない</li></ul></li><li>トレードオフは絶対にある、ないと思ったらまだ見つかってないだけ</li><li><a href="https://speakerdeck.com/findyinc/modern-trade-off-analysis?slide=15">https://speakerdeck.com/findyinc/modern-trade-off-analysis?slide=15</a><ul><li>デザインは挙動に関する議論であるがアーキテクチャは能力に関するものであるから、徐々に変えるのではなく最初からスパッとやらないといけない</li></ul></li><li>フィードバックが早いのは良い。軌道修正はできる</li><li>ex マイクロサービスの粒度<ul><li>単一の責任だけでは曖昧で無理</li><li>分ける要因と統合する要因を考えるべきだと主張</li><li>ハードパーツの本に書いてあったやつだな</li></ul></li><li>名前つけるのが難しいから、名前がつく粒度まで分解しちゃう、みたいな話が出てびっくりしてる。理にかなっている気もするがパッと受け入れられてない<ul><li>メッセージングの件</li></ul></li><li>ベストプラクティスは、状況に対して何をやれば良い、という提案。ベストなので判断の余地はない</li><li>組織の目的は考える必要がある<ul><li>絶対壊れちゃいけない v.s. 要望からリリースまでの時間の短さ</li></ul></li><li>設計を繰り返すために定性分析して、結果的に定量分析しよう</li><li>過去のベスプラが今野アンチパターンになるのはエコシステムがコンスタントに変わるから</li><li>それに追従するためにも分析を続けるのがよかろうということかな</li></ul><p>感想: トレードオフとビジネス要求、をみて決めるのだなという気持ちと、無限に時間がかかるのでタイムボックスを決めてガッと決めることなのだろうと思った。それを何回も適宜行うイメージ。</p><h4><a href=#saas id=saas class=anchor aria-hidden=true>SaaS</a></h4><p>saas: 業務のベスプラを提供するモデルテナント: 契約の提供を受ける単位のことコントロールプレーンとアプリケーションプレーンなるほど。コントロールプレーンはなるだけ作りたくないテナント、本当に必要なのか？は気になる。ここで主張されるテナントには何が含まれるのだったか。テナントの本存在するのか。</p><h4><a href=#%e3%82%b3%e3%83%ad%e3%83%97%e3%83%a9 id=コロプラ class=anchor aria-hidden=true>コロプラ</a></h4><ul><li>クライアントでブラウザを使わない、リアルタイムサーバがあるのがwebアプリとの違いっぽい</li><li>専用ゲームサーバ: DGS, dedicated game serer</li><li>DBがやばかったのはspannerを使うことでなんとかなった</li></ul><h4><a href=#bitkey id=bitkey class=anchor aria-hidden=true>bitkey</a></h4><ul><li><p>モブプロ</p></li><li><p>BDD</p></li><li><p>イベントソーシング</p></li><li><p>どんなコンポーネントがあって、どう連携するかを決める</p></li></ul><h4><a href=#%e5%a2%97%e7%94%b0%e3%81%95%e3%82%93 id=増田さん class=anchor aria-hidden=true>増田さん</a></h4><ul><li>vuca, ooda</li><li>観察とか行動とかは具体的に何をするんだろう</li><li>マイケルポーター 競争優位</li><li>ask the speaker<ul><li>競合優位性でググろう、本を読もう</li><li>エンジニアがやっていくとスムーズそう</li><li>増田さんの会社がワークショップを開催したり、本を出したりするかも</li></ul></li></ul><h4><a href=#%e3%82%b3%e3%83%b3%e3%83%91%e3%82%a6%e3%83%b3%e3%83%89 id=コンパウンド class=anchor aria-hidden=true>コンパウンド</a></h4><p>なんで全く新しく作らなかったのだろう</p><ul><li>バンブーで1日かけて設計したとのことだが、どうやって決めた？意思決定プロセスが気になる。強い人？<ul><li>強い人が決めると決めてる。領域ごとに担当者がいる。これはknowledgeworkの意思決定プロセス（口頭でシュッと聞いただけなので、書いた内容は正確ではなさそう）</li><li>もちろんレビュー依頼などはする</li><li>それだと独裁になるのがいや。なのでこの会議で決めるとしている</li><li>そこまでに議題は共有されている。異論があれば準備しておく</li><li>異論が出なければ決まる</li></ul></li></ul><p>scim: azureとかでユーザ作ったらsaasでもユーザ作るみたいなやつ</p><p>バッチとバックエンドはapi呼び出しで繋がってたのかな</p><h4><a href=#flatt id=flatt class=anchor aria-hidden=true>flatt</a></h4><p>IRでのシナリオ気になる。エンドポイントだけでなくシナリオを作ってるのかな</p><h4><a href=#%e5%af%be%e8%ab%87 id=対談 class=anchor aria-hidden=true>対談</a></h4><p>取り巻く環境の中で継続的な改善可能性をもつシステムを作る環境に合わせる話は大事変化を発見したときにちゃんとついていく。変化を捉えることは必要そう</p><ul><li>実現したいことをトッププライオリティにおく、ビジネスissueとしても重視する。それを実現する手段には拘らない。でもその分野についてのビギナーには手段が中心に見える。その目的が見えない。なんでその手段を取るかを理解するのは難しい</li><li>こうしたら良くなるの提案を頑張って説明する。自分の主張も大体間違ってると思ってドキュメントを事実ベースで論理的に書くと成功確率上がる。言語化して検証する。</li></ul><h4><a href=#%e6%84%9f%e6%83%b3 id=感想 class=anchor aria-hidden=true>感想</a></h4><ul><li>いろんなところがconnect使ってる。layerx、knowledgework、flattが確か使っているとのことだった。</li><li>アーキテクチャの話を聞きにきたはずが意思決定の進め方とか社内での役割について質問していたし勉強になることが多かった。あとは共感できないか、もう知っていることが多かった</li></ul><h4><a href=#%e6%87%87%e8%a6%aa%e4%bc%9a id=懇親会 class=anchor aria-hidden=true>懇親会</a></h4><p>オフレコのつもりで話していた方もいるだろうからここには詳細書かない方が良さそうかな。知らない業種の話を聞けたり、一方的に存じ上げていた方のお悩みをお聞きしたのが印象的。また増田さんや他の登壇者の方に質問したり、そこから発展したお話し伺えて楽しかった。ドメインエキスパートどこにいるんだよ、いなくない&mldr;?みたいな話を質問した。他にも色々お話し聞けた。</p><h3><a href=#%e6%8c%af%e3%82%8a%e8%bf%94%e3%82%8a id=振り返り class=anchor aria-hidden=true>振り返り</a></h3><p>増田さん、川中さんのお話が響いたし、発表後に質問に伺って教えていただいた知見が良かった。熱い気持ちになっている。そのほかのセッションではFlattセキュリティの内容が面白かった。ASM、そんなステップが中にあることを今まで全くイメージできてなくて、概要を知れたことが嬉しかった。
Webアプリケーションの構造を始めて学んだときみたいな気持ち。登壇者がラムダノートのWebブラウザセキュリティの本の著者だと聞いてなるほどな気持ち。</p><p>増田さんからはドメインモデリングと事業を進める話を学んだ。訳書である「ドメイン駆動設計をはじめよう」を読んで、今回の発表内容の結構な部分を腹落ちさせていたのだが、増田さんがどこをどういう形で支持しているかを知れたのが収穫。また、僕が抱えていた悩みとして「ドメインモデリングしたいが、ソフトウェアだけじゃなくてドメイン自体の設計も僕たちが結局やる必要がある。ではドメインをどう作っていくのが良いだろう」というのがあった。それを増田さんにぶつけてそれが真っ当な悩みっぽいと共感していただけた（と僕は思っている）ことと、それへの対処（競争優位を重視して作るとか、エンジニアから歩み寄ってディレクタとかと会話するとか）を引き出せたことが収穫。あと懇親会で色々お話し聞けて楽しかった。ここのお話しから収穫あったのはそうだけど、人柄を知れたのがでかい。</p><p>川中さんからはプロダクト開発における意思決定の進め方を学んだ。初期には対象範囲（バックエンドとかフロントエンドとか）を決めて強い人が決める、それに対して責任を持つ、範囲の境界の契約（APIスキーマとか）はちゃんと決めて厳格に運用する。まあ確かにシュシュっと決まりそうだし、なんとかする未来を描きやすそう。</p><p>その他の意思決定の仕方として、やはり強い人が提案をして決めにかかるやり方もあるそうだが、それだと独裁になっちゃうので最終決定を会議でするようにしてるとのこと。決める内容はあらかじめ共有しておいて、反論があれば会議までには用意する必要がある。会議で異論がなければ決まる。もちろんレビューを依頼することはある。</p></p></div><div class=post-footer><time>November 26, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-11-25/>2024-11-25</a></h2><div><p><ul><li><input checked disabled type=checkbox> それぞれの記事に「次の記事」と「前の記事」へのリンクをつける<ul><li>記事のレンダリングとは別にページの属性として前後の記事のURLかパスを持たせるように、テンプレートみたいにすると良い。計算フェーズを分ける</li></ul></li></ul></p></div><div class=post-footer><time>November 25, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-11-20/>2024-11-20</a></h2><div><p><h2><a href=#%e3%82%b9%e3%82%ad%e3%83%bc%e3%83%9e%e9%a7%86%e5%8b%95cli%e3%83%84%e3%83%bc%e3%83%ab%e9%96%8b%e7%99%ba%e3%82%92%e6%94%af%e6%8f%b4%e3%81%99%e3%82%8b%e3%83%84%e3%83%bc%e3%83%ab%e3%82%92proto%e3%81%ab%e4%b9%97%e3%81%a3%e3%81%8b%e3%81%a3%e3%81%a6%e4%bd%9c%e3%82%8a%e3%81%9f%e3%81%84 id=スキーマ駆動cliツール開発を支援するツールをprotoに乗っかって作りたい class=anchor aria-hidden=true>スキーマ駆動CLIツール開発を支援するツールをprotoに乗っかって作りたい</a></h2><ul><li><input checked disabled type=checkbox> proto2cliを実装する<ul><li>やった<ul><li>zennに紹介記事を書いた <a href=https://zenn.dev/nfurudono/articles/719e3aafac6065>https://zenn.dev/nfurudono/articles/719e3aafac6065</a></li><li>kamakura.go #7で発表した <a href=https://kamakurago.connpass.com/event/336353/>https://kamakurago.connpass.com/event/336353/</a><ul><li>スライドはこれ <a href=https://speakerdeck.com/naoyafurudono/protocol-bufferssukimading-yi-kara-gonocliwosheng-cheng-suru>https://speakerdeck.com/naoyafurudono/protocol-bufferssukimading-yi-kara-gonocliwosheng-cheng-suru</a></li></ul></li><li>まだ本番環境に組み込めてないのと、機能開発とか開発環境の整備ができていない。やる</li></ul></li><li>名前を決める：connectはブラウザやgRPCと互換性のあるAPIを提供するのに必要なボイラープレートが必要なのを軽減してくれるやつ。<ul><li>これはそれらにCLIをインターフェースとして加える。つまりローカルから、サーバを立てる事なく実行できるようにする。そういう立ち位置がいい。単にインターフェースを一個加えるだけ。実装はできるだけシェアしたい。</li><li>まずはconnectを採用するアプリケーションを一個用意して、それにCLIを入れる。ここで上手い入れ方を探る</li><li>次にその入れる作業を自動化する。そのためのCLIがproto2cli</li></ul></li><li>サブコマンドでサービス、位置引数でメソッド、フラグ引数(<code>-d</code>)でリクエストメッセージを受け取る。<ul><li>サブコマンドと位置引数は最初は特に区別しなくていいか。 <code>cmd &lt;service> &lt;method> -d &lt;request message json></code> の形式で呼び出すだけ。</li><li>CLIへの入力はそのままサービス名、メソッド名、リクエストメッセージがそれぞれbyte列かstringのどちらかで得られる。それらをなんとかするのは一旦別のコンポーネントの役割にしよう</li><li>ここまでは普通にflagsパッケージとかを使うだけでいける</li></ul></li><li>次にリクエストメッセージのデコードを自動化する。<ul><li><code>func unmarshalRPC(service, method, req string) (MessageInterface, error)</code><ul><li>対応する型のunmarshellerへのディスパッチとその呼び出しが責務</li></ul></li><li><code>dispatchUnMarshelelr(service, method string) (func(byte[], MessageInterface) error, error)</code><ul><li>ディスパッチだけでも良さそう</li></ul></li></ul></li><li>次に、サービスの呼び出しを行う<ul><li>connect サーバをclient経由で呼び出す</li><li>単にサービスを呼び出す<ul><li>インターセプタを通過できない、特にproto validateを通せない</li></ul></li><li>インターセプタとサービスを合成する<ul><li>できればhttpサーバの仕組みに乗っかりたい</li><li>でも無理がありそう、intercepter (unaryfunc) を受け入れてデコレートする感じにしそう</li></ul></li></ul></li><li></li></ul></li></ul><p>以下のようなprotoスキーマを定義する。</p><pre><code class=language-proto>syntax = &quot;proto3&quot;;

package nfurudono.sample.v1;

service SampleService {
  rpc Say(SayRequest) returns (SayResponse) {}
}

// SayRequest is a single-sentence request.
message SayRequest {
  string sentence = 1;
}

// SayResponse is a single-sentence response.
message SayResponse {
  string sentence = 1;
  bool dry_run = 2;
}
</code></pre><p>こんな定義があるときに</p><pre><code class=language-sh>$ ./sample say --sentence &quot;hello world&quot; --dryrun
sentence: &quot;I will say: hello world&quot;
</code></pre><p>みたいなやりとりを定義するためのCLIテンプレート生成ツールを作る。あくまでテンプレートなので、生成ツールではインターフェースとかグルーコードだけ提供して、ユーザは以下のようなコードを書くことになる。</p><ul><li>connectとかでサービスとサーバの起動を定義してmainからいい感じに呼ぶようにすると、gRPCサーバがたつのに対して、</li><li>CLIテンプレート作成ツールでサービスとCLIコマンドの呼び出しを定義してmainからいい感じに呼ぶようにすると、CLIから実行できる</li></ul><h3><a href=#%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e3%81%ae%e5%ae%9f%e8%a3%85 id=サービスの実装 class=anchor aria-hidden=true>サービスの実装</a></h3><pre><code class=language-go>package service

import (
	&quot;fmt&quot;
	
  sample &quot;github.com/nfurudono/gen/go/sample&quot;
)

type SampleImpl struct {}
// sample.SampleServiceはprotocとかが生成するようなinterface。gRPCとかconnectとかで使われているようなやつ。
var _ sample.SampleService = &amp;NewSampleImpl()

func NewSampleImpl() { return SampleImple{} }

func (* SampleImpl) Say(ctx *context.Context, req *connect.Request[samplev1.SayRequest]) (*connect.Response[samplev1.Response], error) {
	s := req.GetSentence()
	d := req.GetDryRun()
	if d {
		return fmt.Sprintf(&quot;I will say: %s&quot;, s), nil
	}
	return fmt.Sprintf(&quot;%s!!&quot;, s), nil
}
</code></pre><h3><a href=#%e3%82%a8%e3%83%b3%e3%83%88%e3%83%aa%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88 id=エントリポイント class=anchor aria-hidden=true>エントリポイント</a></h3><pre><code class=language-go>package main

import (
	slog
	
	tool &quot;github.com/naoyafurudono/good-tool&quot;
	&quot;github.com/naoyafurudono/sample-cli/service&quot;
)

func main() {
	s := service.NewSampleImpl()
	// NewCLI()の結果（CLI）はサービスを登録される。
	// サービスを保持するCLIはサービスが契約するrpc（名前、入力、出力）を知っている。
	// これらはprotoの仕組みで生成される。protovalidateなどのプラグインもそのレイヤで対応できるはず。
	cli := tool.NewCLI().AddService(s)  // このあたりのインターフェースはもうちょい考えても良いかも？
	// Runがコマンドライン引数を読んで以下を半ドアリングする
	//   - 呼び出すrpcの判定（ルーティング）、サブコマンドの名前が対応する
	//   - rpcに渡す入力messageのデコード、サブコマンドへのフラグ引数が対応する
	//   - rpcの出力メッセージやエラー内容の出力、コマンドの標準出力、標準エラー出力、コマンドのステータスコードの出しわけが対応する
	if err := cli.Run(); err != nil {
		slog.Fatalf(&quot;unexpected input: %w&quot;, err)  // 予期しないサブコマンドが来たらエラーを返すのもまた一興かな。
	}
}
</code></pre><p>便利じゃない？</p></p></div><div class=post-footer><time>November 20, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-11-13/>2024-11-13</a></h2><div><p><p>fzfで表示される選択肢と選択した結果得られる値を分けられるようにしたいので作った。
yamlでkey-valueペアのリストを保持しておいて、そのキーの選択をfzfで行い、得られる値はvalueである、みたいな感じ。</p><pre><code class=language-bash>#!/bin/bash

# ヘルプメッセージ
function print_help {
    echo &quot;Usage: $0 &lt;yaml_file&gt;&quot;
    echo
    echo &quot;This script allows you to select a key from a YAML file using fzf, and outputs the corresponding value.&quot;
    echo
    echo &quot;Options:&quot;
    echo &quot;  -h    Show this help message and exit&quot;
    echo
    echo &quot;Sample YAML format:&quot;
    echo &quot;  key1: value1&quot;
    echo &quot;  key2: value2&quot;
    echo &quot;  key3: value3&quot;
}

# -hオプションのチェック
if [ &quot;$1&quot; == &quot;-h&quot; ]; then
    print_help
    exit 0
fi

# 引数チェック
if [ -z &quot;$1&quot; ]; then
    echo &quot;Error: No YAML file specified.&quot; &gt;&amp;2
    print_help
    exit 1
fi

# 引数からYAMLファイルのパスを取得
YAML_FILE=&quot;$1&quot;

# YAMLファイルの存在チェック
if [ ! -f &quot;$YAML_FILE&quot; ]; then
    echo &quot;Error: File '$YAML_FILE' not found.&quot; &gt;&amp;2
    exit 1
fi

# キーをfzfで選択
selected_key=$(yq e 'keys | .[]' &quot;$YAML_FILE&quot; | fzf)

# キーが選択されていない場合
if [ -z &quot;$selected_key&quot; ]; then
    echo &quot;No key selected.&quot; &gt;&amp;2
    exit 1
fi

# 選択されたキーに対応する値を取得
selected_value=$(yq e &quot;.${selected_key}&quot; &quot;$YAML_FILE&quot;)

# 値を標準出力に表示
echo &quot;$selected_value&quot;
exit 0
</code></pre><p>上のコマンドを <code>fzf-keyvalue-select</code> という名前でパスを通しておく。その上で以下のような関数を登録しておくと便利。</p><pre><code class=language-fish>function notion
    set url (fzf-keyvalue-select ~/.local/fish/notion.yaml)
    and open $url
end
</code></pre></p></div><div class=post-footer><time>November 13, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-10-16/>2024-10-16</a></h2><div><p><h2><a href=#%e8%aa%ad%e6%9b%b8%e3%83%a1%e3%83%a2 id=読書メモ class=anchor aria-hidden=true>読書メモ</a></h2><ul><li><input disabled type=checkbox> <a href=https://browser.engineering/intro.html#browser-code-concepts>https://browser.engineering/intro.html#browser-code-concepts</a> 以前まで読んだ。このセクションから再開する。</li></ul><h2><a href=#%e3%83%96%e3%83%ad%e3%82%b0%e9%96%8b%e7%99%ba%e3%82%a2%e3%82%a4%e3%83%87%e3%82%a2 id=ブログ開発アイデア class=anchor aria-hidden=true>ブログ開発アイデア</a></h2><ul><li><input disabled type=checkbox> トピックをセクションのタイトル (hN要素) で宣言して、それを集約したページを勝手に生成するようにしたい。<ul><li><code>about:&lt;TOPIC_NAME> &lt;TEXT></code> という名前のタイトルをヘッダにつけたら、<code>/topic/&lt;TOPIC_NAME></code> というページを生成して、　　そこに <code>&lt;TEXT> - &lt;DATE></code> みたいな名前のセクションを埋め込みたい。元記事へのパーマリンクも添えておくと良さそう。</li><li>読書記録に使えそう</li><li>その他にも普通のブログではタグを記事につけるようなノリで使うのも可能。記事の単位だとタグによる分類は不便に思うのだけど、セクションくらいの粒度ならつけるときも読む時もちょうど良いだろうと思う</li></ul></li></ul><h2><a href=#%e4%bb%8a%e3%81%ae%e7%92%b0%e5%a2%83%e3%81%a0%e3%81%a8%e6%af%94%e8%bc%83%e7%9a%84%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0%e3%81%8c%e5%be%97%e6%84%8f%e3%81%8b%e3%82%82%e3%81%97%e3%82%8c%e3%81%aa%e3%81%84%e3%81%a8%e6%80%9d%e3%81%86%e3%82%88%e3%81%86%e3%81%ab%e3%81%aa%e3%81%a3%e3%81%a6%e3%81%8d%e3%81%9f id=今の環境だと比較的プログラミングが得意かもしれないと思うようになってきた class=anchor aria-hidden=true>今の環境だと比較的プログラミングが得意かもしれないと思うようになってきた</a></h2><p>エンジニアリングの中ではプログラミングは割と得意なのかもしれないとここ１ヶ月くらいでなんとなく思うようになった。こういうプログラムの構成の方が良くない？みたいなことを理由込みでそれなりに説明・提案できることが周囲より多そうな気がしてきたので。</p><h2><a href=#%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%a0%e3%81%ae%e8%a8%ad%e8%a8%88 id=プログラムの設計 class=anchor aria-hidden=true>プログラムの設計</a></h2><p>失敗できないように作るとか（設計、型の宣言）、失敗には早く気がつけるようにするとか（リント、コントラクト、バリデーション）、プログラムのあるべき振る舞いをテストするとかは似たような話に思う。先に挙げたものほどフィードバックが早くて良い。リントとかテストはそのプログラムそのものの性質ではなくて外からどうこうする点が特殊。テストではこういうふうに使うと確かにこんな感じに振る舞う、みたいな確認をする。リントではこういう感じの使い方をするとやばいからやめておいて欲しい、と怒る（この観点では型と一緒）。リンターのライフサイクルは対象のソフトウェアと一緒とは限らないのが辛いところなのかな。型システムは言語の一部だし、設計はプログラムの一部。でもリンターは一部とは限らない。一部になっている奴はだいぶ使い勝手が良いが、そうでないやつはいろんな人が勝手気ままに思想を入れるし、それらの互換性は比較的真面目には考えられないだろうから品質が悪くなりそう。</p><p>そういうわけでリンター難しそう。</p></p></div><div class=post-footer><time>October 16, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-10-10/>2024-10-10</a></h2><div><p><ul><li><input disabled type=checkbox> protobufとかsqlcでファイル生成をするツールを使ってチーム開発をしているとすごくコンフリクトして辛い。生成するファイルを分割して、例えばrpcとかmessage単位にファイル（パッケージではない！）を分ければgitのコンフリクトは避けられる。パッケージも一緒なので振る舞いには影響しない。</li></ul></p></div><div class=post-footer><time>October 10, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-10-06/>2024-10-06</a></h2><div><p><h2><a href=#llm-%e3%82%92%e5%b0%82%e9%96%80%e5%ae%b6%e3%81%a0%e3%81%a8%e6%80%9d%e3%81%88%e3%81%aa%e3%81%84 id=llm-を専門家だと思えない class=anchor aria-hidden=true>LLM を専門家だと思えない</a></h2><p>LLMはコンパイラとかみたいに説明とか分析を出力してくれるものではあるけど、
LLMはコンパイラよりも人間に近いものだと思っている。コンパイラみたいな決定的な出力をするツールに対して良い入力を与えてその出力をそのまま共有することには価値がたくさんあるけれど、
LLMから得られた出力をそのまま「LLMに聞いたらこう返してくれました！」っていうのは（少なくとも現代使えるLLMのレベルでは）意味が薄いと感じる。</p><p>人間に対して質問して、その回答をそのまま人に共有することにも、場合によって価値がたくさんあったり薄かったり感じることがそれぞれある。質問を回答してくれる人間に対して信頼というか専門家としての信頼というかがあったら、そのまま回答を知りたいと思うが、その辺のただの人とか単に知識がたくさんあるだけな人だと、
（アンケート回答のデータとかなら別だけど）意見や情報としては価値を見出しにくい。そんな感じに、ぼくはLLMを専門家だとはまだ思えていない。単に知識がたくさんあってそれっぽい文章を生成するだけの（論理的思考の欠けた）出力をするやつだと思う。</p><p>とはいえ知識や経験がたくさんあれば結構な量の論理的思考は不要だろうことは段々わかってきた。なんのために考え事が必要なんだろうね。そして論理的思考とは何なのだろう。</p><h2><a href=#%e3%81%8a%e7%96%b2%e3%82%8c id=お疲れ class=anchor aria-hidden=true>お疲れ</a></h2><p>今週は疲れた。先週の金曜から毎日飲み会だとか人と会ったりだとかのイベントがあった。それぞれは楽しいのだけど全てに参加していると大変。昨日はずっと寝ていたし、今日は家事をしていた。本を読む気力もない。体としては寝ても良さそうなのだが頭は何かをしたがっているので文章を書いている。本を読みたい気持ちもあるが、落ち着いて考え事をしたい気持ちもある。今その本を本当に読みたいのだったか、とか。</p><h2><a href=#%e3%82%8f%e3%81%8b%e3%81%a3%e3%81%9f%e3%81%a4%e3%82%82%e3%82%8a-%e8%aa%ad%e8%a7%a3%e5%8a%9b%e3%81%8c%e3%81%a4%e3%81%8b%e3%81%aa%e3%81%84%e6%9c%ac%e5%bd%93%e3%81%ae%e5%8e%9f%e5%9b%a0-%e5%85%89%e6%96%87%e7%a4%be%e6%96%b0%e6%9b%b8-%e3%81%8c%e8%89%af%e3%81%84 id=わかったつもり-読解力がつかない本当の原因-光文社新書-が良い class=anchor aria-hidden=true>わかったつもり 読解力がつかない本当の原因 (光文社新書) が良い</a></h2><p><a href=https://amzn.asia/d/gd6e4f7>わかったつもり 読解力がつかない本当の原因 (光文社新書) </a>に本屋で出会って読んでいるのだが良い。わかるとか理解する、みたいなことは一体何なのかは高校生の頃からのぼくのテーマの一つなのだが、それを一段深めてくれている。</p><p>ぼくの中での「理解する」とは、説明をつけることとか腹落ちしていることであった。論理とかは客観的なアレとして社会的に認められていたり、自然科学は実際問題役に立っているので市民権を得ているが、そんなことは「理解している」とは関係ないと思っている。理解しているか否かは主観的な問題で、腹に落ちた感じがするなら自分はそれを理解していると思うし、自分が同意できる説明を他者がするなら他者はそれを理解しているように感じる。そういうものだと思っていたし、今も思っている。</p><p>この本の説明ではぼくの解釈と矛盾しない中で理解の程度を論じているように思う。文脈とそれに対する解釈を持っている人間は、文脈を新たに獲得し明らかにすることで対象の解釈をより鮮明にする、みたいな主張だと今のぼくは大体思っているはず。鮮明にするというか、よりわかるというか。</p><p>これまでのぼくの理解への価値観には抽象度の違いがなかった。抽象解釈をするときにどれだけfineに解釈するかの違いが認識する文脈の違いに依存することをこの本に解らさられた。</p><h2><a href=#%e5%85%ab%e7%99%be%e5%b1%8b id=八百屋 class=anchor aria-hidden=true>八百屋</a></h2><p>この前ご近所さんとお話した影響で今日は八百屋に行ってきた。はじめて行くタイプの八百屋で、なんとカゴとレジは存在しなくて、床に陳列されている野菜を見ながら店員さんに口頭で欲しい野菜をクエリするタイプの買い方だった。ちなみに野菜の品質はそんなに良くなかったので次は他のところかなと思っている。安くはあった。</p><h2><a href=#%e8%aa%ad%e6%9b%b8 id=読書 class=anchor aria-hidden=true>読書</a></h2><p>結局人は自分と近しい考えを読んでそれを楽しいと思うのだな、みたいなことを恩師が言っていたのを思い出した。ぼくもそう思う。そういう答え合わせみたいな読書は楽しい。</p><p>読書に限らずおしゃべりとかでもなんやかんや同調とか、似たような哲学のもとでの「議論」みたいなことをするときが楽しそう。「あいつはやばいから！」と嬉しそうに友達を紹介する人は、大体その友達と大差ないとかだとか。議論をするときに背景に共通点を見出して群れるのもそういうことだと思う。良し悪しは知らない。</p><h2><a href=#%e5%a5%bd%e3%81%8d%e3%81%aa%e6%a7%8b%e6%96%87 id=好きな構文 class=anchor aria-hidden=true>好きな構文</a></h2><p>named-letです。</p></p></div><div class=post-footer><time>October 6, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-09-18/>2024-09-18</a></h2><div><p><p>日記からtodo一覧を抽出して専用ページにtodoアイテムとその文脈を列挙する機能を実装した。この手の機能はtodoに限らず文章で考えや記録をつける人を幸せにするだろう。</p><p>例えば、読書メモをする場合、ぼくはそれを日記に書きたい。でもある本についての読書メモはまとめてみたい気持ちもある。そんなときに、その本に関する記述をまとめてみる機能があると幸せなはずだ。あくまでメモなので、その内容はその日の自分に依存する主張を持つ。なので、日記としての文脈は必要なはず。日記はぼくの考えたこととか記録を時系列でまとめたものであって、ぼくにまつわるいろんなものは時系列に沿って進んでいく。考えて、書くのも時間的な変化とともに進めていくものだし。なので書き出すフォーマットは日記が良い。楽だし、情報が失われにくそうなので。</p><p>その反面、読み方によっては他のアスペクトで抽出したりまとめたいこともある。それは日記を切りはりしたものとしてある程度表現できるはず。普通にぼくたちがあるアスペクトでまとまった記述をするときには、時間をかけて一つの側面から解釈しやすいようにする。文書を作成するときは反復して改善するものだし、推敲をするものでもある。では推敲をしない文書作成は、あるテーマについて日記を切り貼りしたものなのではないだろうか。</p><p>その切りはりをやるツールとしてtodo一覧の抽出みたいな機能を使えると思う。</p><p>セクションの単位でアスペクトを宣言できると良いだろうと思っている。あるいはAIでアスペクトを後付けしてもいいかもしれない。でも、どちらかというと、ぼくは普段の日記を書くときに後から見返す解釈を意識してかけたら楽しいだろうと思う。なのでアスペクトは明示的に日記を書く人が付けられるといいと思う。ふとアスペクトを思いついて、これまでの自分はどう思ってたんだっけと気になることもある。そのときには確かにAIに全部みていい感じにタグ付けしてほしい。</p><p>あと、今はunifiedを使って実装しているけど、pandocに移行しても楽しそう。型が辛いと思っているので。pandocはhaskell製なので型が弱くて文句を言いたくなることはないはず。</p></p></div><div class=post-footer><time>September 18, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-09-16/>2024-09-16</a></h2><div><p><h2><a href=#%e4%bb%8a%e6%97%a5%e3%82%84%e3%82%8b%e3%81%93%e3%81%a8 id=今日やること class=anchor aria-hidden=true>今日やること</a></h2><ul><li><input checked disabled type=checkbox> 掃除<ul><li>ルンバを起動したのでok</li></ul></li><li><input checked disabled type=checkbox> 外出<ul><li>電車乗るくらいの外出をする。秋物出たかな。あるいは外で使うと幸せになれるグッツを買うか。</li><li>ランニングパンツと靴下を買う。帰省でランニングのズボンを置いてきたのと、靴下が大体ボロボロになってきたので。</li><li>靴下は買った。ランニングパンツはまあいっかと思って買わず。そのほかに秋に向けて服を見たけどピンと来なかったので特に買わずだった。</li></ul></li><li><input checked disabled type=checkbox> 本読む。k8sのあれ。あとは認証の技術気になるので学ぶ。認可も気になる。<ul><li>SSL</li><li>ドメイン</li><li>k8sのRBAC</li><li>選ばれたのはカスタムコントローラでした。ググって見つけたyahooの人のスライドが概要を掴むのにいい感じだった。<ul><li><a href=https://speakerdeck.com/hhiroshell/platform-engineering-and-kubernetes>https://speakerdeck.com/hhiroshell/platform-engineering-and-kubernetes</a></li></ul></li></ul></li><li><input checked disabled type=checkbox> todoをリストアップする拡張の実装</li><li><del>todoの拡張、出先でチェック入れたくなりそうなので、githubでの編集へのリンクをつけたい</del><ul><li>やっぱりいいや。出先ではのんびりしよう。todoのことなんて忘れればいい。</li></ul></li></ul><h2><a href=#todo%e3%82%92%e3%83%aa%e3%82%b9%e3%83%88%e3%82%a2%e3%83%83%e3%83%97%e3%81%99%e3%82%8b%e3%83%9a%e3%83%bc%e3%82%b8%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%97%e3%81%9f id=todoをリストアップするページを実装した class=anchor aria-hidden=true>todoをリストアップするページを実装した</a></h2><p><a href=https://diary.nfurudono.com/todos/>https://diary.nfurudono.com/todos/</a>に実装した。これでもう過去のtodoを忘れない。収集とレンダリングの両方が必要でだるかった。特にレンダリングはunifiedのアーキテクチャを理解してなくて手間取った。今の実装がunifiedのアーキテクチャに沿っているか自信がない。</p><h2><a href=#%e6%ac%a1%e3%81%ae%e5%bc%95%e8%b6%8a%e3%81%97 id=次の引越し class=anchor aria-hidden=true>次の引越し</a></h2><p>本棚を作って設置したところ、そろそろキャパシティが限界だと気がついた。本棚を増やすためには引越しが必要。そろそろ減らしてもいい本も増えてきたので、
2年周期の引越しで問題ないとは思うが。今で3/4年か&mldr;、今年のうちに西側の探索をしたいな。今度友達とどこに行くか決めてないので、そっちの方に雑に行ってみて案内してもらおう。向こうが詳しいかは知らないけど。</p><h2><a href=#%e9%9b%bb%e8%bb%8a%e3%81%a7%e9%81%8e%e3%81%94%e3%81%99%e3%81%ae%e3%81%8c%e5%a5%bd%e3%81%8d id=電車で過ごすのが好き class=anchor aria-hidden=true>電車で過ごすのが好き</a></h2><p>寝たり本を読んだり景色をみたり、考え事をしたりする環境として電車で過ごすのが好き。年末は北国に電車に乗りに行きたいな。高校生の頃に一週間電車に乗りっぱなしの旅行をしたけど、あんな感じのことをまたやりたい。それでいうとシベリア鉄道は憧れる。</p><p>景色が変わるのがいいし、椅子しかないのも良い。なので新幹線みたいな机があるのはそれほど好きじゃない。横に細いサイドテーブルみたいなのはok。ものを置けるけどそこで何かやる感じではないのがいい。集中できるし、パッと休憩しようと思ったら外を見ればいい。なので電車に乗るのは日中がいい。夜は外が見えないので興醒めする。</p><p>家にいても景色が変わらなくてつまらない。外に出るのも良いが、それだと本読んだりできない。電車の中は家と同様に自分が暇なのに快適で、移動しているのがいい。</p><h2><a href=#3%e9%80%a3%e4%bc%91 id=3連休 class=anchor aria-hidden=true>3連休</a></h2><p>金曜日の昼過ぎに三連休だということを知った。なんと来週も三連休だということだった。この三連休は本棚を作り、あとは家でまったりした。こういうのもあり。</p></p></div><div class=post-footer><time>September 16, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-08-15/>2024-08-15</a></h2><div><p><p>日記をnextjsでビルドして、cloudflare pagesにデプロイするようにした。cnameの設定が効くようになれば、<a href=https://diary.nfurudono.com>https://diary.nfurudono.com</a>から見えるようになるはず。</p><p>cloudflareのアカウントを初めて作って設定したが、体験よかった。デプロイとか周りの開発のためにCLIツールやそれのgithub actionsバインディングが提供されていて、サクッとデプロイできた。記念すべき初デプロイの成功をメモしておく<a href=https://github.com/naoyafurudono/naoyafurudono.github.io/actions/runs/10399555684/job/28798614059>https://github.com/naoyafurudono/naoyafurudono.github.io/actions/runs/10399555684/job/28798614059</a></p><p>Hugoの設定をたくさん書いていても楽しくないのでNext.jsでなんでもやってみよう、というモチベーション。<a href=https://github.com/unifiedjs/unified>unified</a>がいい感じで楽しいので動くところまで持って来れた。</p><p>ソースコードは<a href=https://github.com/naoyafurudono/naoyafurudono.github.io/tree/main/tools/tt>https://github.com/naoyafurudono/naoyafurudono.github.io/tree/main/tools/tt</a>にある。</p></p></div><div class=post-footer><time>August 15, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-08-03/>2024-08-03</a></h2><div><p><h2><a href=#%e4%ba%8b%e6%a5%ad%e3%81%a7%e4%bd%bf%e3%81%86%e3%82%b7%e3%82%b9%e3%83%86%e3%83%a0%e3%82%92%e8%a8%ad%e8%a8%88%e3%81%99%e3%82%8b%e3%81%a8%e3%81%8d%e3%81%ae%e8%a9%b1 id=事業で使うシステムを設計するときの話 class=anchor aria-hidden=true>事業で使うシステムを設計するときの話</a></h2><p>ソフトウェアを設計するときにはどこを変えやすくしたいか（どんな変更をしやすくしたいか）を把握したい。
Expression probremは必ずしも解決しなくてよいと思っていて、変更に必要な気合がどれくらいかを把握したうえでそれを許容できるかが論点だと思う。</p><p>もちろん使う気合が小さいのに越したことはないのだが、コード読み書きするのはみんな好きだろうし、嫌いなひとは割とAIに任せられる世の中なのだから、小手先のテクニックでなんでもできる設計とかにしておくうまみはあまりないと思う。</p><h2><a href=#%e8%87%aa%e5%ae%85%e3%81%ae%e3%83%8e%e3%83%bc%e3%83%88pc id=自宅のノートpc class=anchor aria-hidden=true>自宅のノートPC</a></h2><p>会社ではmacbook proを使っていて、家ではmacbook airを使っている。使っているソフトウェアとか設定は大体同じにできていて便利ではあるのだけど、今日は手ぐせで会社でよく触っているリポジトリにcdしようとして失敗するのを何回もやってしまった。
lsのノリでそのディレクトリにcdすることに辛さを感じる。</p><h2><a href=#%e4%bb%8a%e6%97%a5%e3%82%84%e3%82%8a%e3%81%9f%e3%81%84%e3%81%93%e3%81%a8 id=今日やりたいこと class=anchor aria-hidden=true>今日やりたいこと</a></h2><ul><li>飲み会の場所を抑える<ul><li>ビールをたくさん飲めるところでそう遠くないところがいい</li></ul></li><li>健康料理<ul><li>野菜を食べたいです</li></ul></li><li>外出<ul><li>15:30を回ったが、まだ外に出ていない。お日様が欲しい</li></ul></li><li>洗濯<ul><li>あとは干すだけ</li></ul></li><li>運動</li><li>ルータを吊るす<ul><li>そういえば家の壁に釘打っても怒られなさそうな板が壁に付いているので、そこにルータをなんとかつけたい</li></ul></li></ul><h2><a href=#%e9%9b%91%e8%ab%87 id=雑談 class=anchor aria-hidden=true>雑談</a></h2><p>今日は小学校4年生の頃に転校してきた友達の誕生日。ブルーアイズホワイトドラゴンをくれた、寡黙なやつだった。元気だといいな。</p></p></div><div class=post-footer><time>August 3, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-05-16/>2024-05-12</a></h2><div><p><p>社内外のrubyistの人たちとたくさん喋れた。明日ruby.wasmの話を聞けるのが楽しみ。質問するぞ！！１</p></p></div><div class=post-footer><time>May 16, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-05-12/>2024-05-12</a></h2><div><p><h2><a href=#%e3%83%a9%e3%82%a4%e3%83%b3%e3%81%ae%e9%80%9f%e5%ba%a6%e3%81%ab%e3%81%82%e3%82%8f%e3%81%9b%e3%82%8b%e3%81%ae%e3%81%8c%e5%a4%a7%e5%a4%89 id=ラインの速度にあわせるのが大変 class=anchor aria-hidden=true>ラインの速度にあわせるのが大変</a></h2><p>チャットを読み書きするのが大変なのではなく、それらを始めるのが大変という話。ラインが嫌いとかでは全然ないし、会話が嫌いなわけでもない。</p><p>僕はラインを手紙くらいの速度でしか見たくないと思うような付き合い方をしてしまっている。議論とかすり合わせをガッとする文脈になれば集中して通知を気にするようにはなれるのだけど、そうではなくて雑談とか、会話ではなく外部の処理に時間のかかるイベントの後処理とかをする文脈だとなかなか通知を見れないというか、そこに意識と返信の気合を割けない。</p><p>そもそもラインとか会話に限らず、返信とかリアクションを外部からの割り込み契機で行うのに辛さを感じる気がしている。例えば宿題出されてそれをやるのがしんどいのと同じイメージ。自分からこの辺の分野・技術を学んでみようと思ってやるのは何も辛くないし、むしろ他の辛さを乗り越えてでもやろうと思うが、それが外部から要求されると辛くなる。</p><p>おそらく原因は人から指図されることではなく、自分がそれをやる体制に入っていない状態で、やる義務を感じてもやる気にならないことにあると思う。宿題はやり始めて意義を感じたり調子が出たりすることでやるのが辛くなくなる。それが2,3週間かかるものであったとしても、体制に入れると辛くなくなる。</p><p>ラインの件も同じだと思っていて、普段僕は会話や事務処理をするモードではない。そのタイミングで人からその依頼が飛んでくると、会話に返事する義務を感じはするものの、処理するやる気は出てこない。</p><p>雑談はしてると楽しいし、事務処理も乗ってくると楽しいものではあるのだが、それらを始めるのに時間がかかるし、大変なのだ。これは子供の頃から変わらない（なんなら全人類そういうものなのではないだろうか）ので受け入れて自分の問題として迂回するなり利用するなりしていこう。</p><p>ちなみに仕事でSlack使うのは全然苦ではない。仕事するためにSlackでコミュニケーション取るのは有効だと思っているし、始業はすでに始めるインセンティブを持てているので苦なくSlackコミュニケーションは取れる。プログラミング集中してるときとかは通知に気がついてもちょっと返信したくないときがあるにはあるが、それくらい。基本的に仕事するときにはリアクションを優先するモードになっているのだと思う。コードレビューと同じ意識を持っていて、普段のあれとは異なる。そして、仕事する時間は決めていて休日にSlackの通知は切っているがそれが他の人に対しても共通の認識になっているのは良い。</p><p>ラインでも時間決めてプロフィールに書くとかするか？（あまり書きたくないけど）。休日の作業しない時間とかになりそうではある。ちなみに今がほとんどそんな感じの運用になっている。</p><h2><a href=#%e6%84%9f%e8%ac%9d%e3%82%92%e4%bc%9d%e3%81%88%e3%82%8b%e3%81%ae%e3%82%82%e5%a4%a7%e5%a4%89 id=感謝を伝えるのも大変 class=anchor aria-hidden=true>感謝を伝えるのも大変</a></h2><p>感謝を伝えるのが苦手で、ご飯奢ってもらったりプレゼントをもらったときとかどういう顔をすれば良いかわからなくなる。</p><p>ラインでそれをやらないといけない状況ではなかなかヤバい。気がつくとなぜだかわからないが（ライン見ないからなのだが）伝えたい感謝が2,3個溜まり、ついでに謝りたいことも少しできてたりする。早めに、こまめに連絡するのが良いのだろうな。</p><p>感謝を伝えるのは単に技術の問題な気がするのでさっさと習得しよう。特に複数溜まった感謝の意を伝える能力が欲しい。</p><h2><a href=# class=anchor aria-hidden=true></a></h2><p>会話やチャットに文脈があるように、僕が日々過ごすことにも文脈というかモードというかがあるみたいだ。仕事、雑務、おしゃべり、勉強、家事、読書（小説）、読書（技術書）、外出、網羅的でも排他的でもないが、それぞれに飽きて数ヶ月やらなくなることはないが、数週間くらいならおろそかになるものが出てくる。</p><p>排他的ではない例として、仕事な雰囲気になっているときに雑務、おしゃべり、プログラミングは全然する。ただし、雑務やおしゃべりはプログラミングに集中しているときはできないし器用に行き来も無理。</p><p>このセクションは、だからどうというわけではないのだけど走っているときにそんなことを思ったのでメモ。</p></p></div><div class=post-footer><time>May 12, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-03-20/>2024-03-20</a></h2><div><p><p>Webアプリケーションのテストをどう実施したものかと最近考えることが多い。
Webアプリは雰囲気で変更したいはずで（ソフトウェアって大体そう？）、またテストは長持ちしてほしいと思う。</p><p>テストではなんらかの仮定のもとで実装がある条件を満たすことを検証する。その仮定を上手に置くことがテスト戦略を決める人の腕の見せどころだろう。</p><p>例えば関数の単体テストをする場合は、そこに渡す実引数を仮定して、その関数の出力が意図した通りになることを検証するし、モックを使うならそのモック対象の振る舞いを仮定することになる。
e2eではユーザの操作を仮定するのだろう。</p><p>いろんな仮定の置き方とその結果実現できる検証内容がある気がしていて、安定した仮定（覆るとテストを直さないといけない）を選びつつ、そこがクリアできれば安心と思える検証内容を取ることがテスト戦略の設計で目指すことなのだと朝の東横線で思ったのだった。</p><p>で、そういうお得さを出せるように実装するのも大事なんだろうなと思っています。</p></p></div><div class=post-footer><time>March 20, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-02-26/>2024-02-26</a></h2><div><p><h2><a href=#%e5%8f%a9%e3%81%8d%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%9f%e4%ba%ba%e3%81%8c%e5%81%89%e3%81%84%e8%a9%b1 id=叩きを作った人が偉い話 class=anchor aria-hidden=true>叩きを作った人が偉い話</a></h2><p>人間失格の主人公はそんな失格っていうほどやばい人には思えないというのはあるあるだと思っていて、そういう感想を抱いたことで自分を許せるようになったと思う。そういう人も結構いるんだろうと思う。</p><p>太宰修がまともじゃない人間について描写したおかげで、それを読んだぼくみたいな他人がもっと救いのある解釈を手に入れられたのだ。当の太宰修は自殺してしまった（理由をぼくは知らないけど）が、彼の残した解釈のおかげでぼくはそれなりに幸せに生きているのでなかなか感謝している。昔は太宰修は愚かだと思ったけど、たたきを作った人は偉いし、その恩恵を自分は受けているのだった。</p><h2><a href=#%e5%85%a5%e5%8a%9b%e3%81%8c%e3%82%ad%e3%83%93%e3%82%ad%e3%83%93%e3%81%97%e3%81%a6%e3%82%8b%e3%81%a8%e6%b0%97%e6%8c%81%e3%81%a1%e3%81%84%e3%81%84 id=入力がキビキビしてると気持ちいい class=anchor aria-hidden=true>入力がキビキビしてると気持ちいい</a></h2><p>久しぶりにUbuntuでブログを書いのだけど、入力がキビキビしていて気持ちがいい。最近は会社や私物のmacを使っていた。何が違うんだろう。</p></p></div><div class=post-footer><time>February 26, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2024-02-12/>2024-02-12</a></h2><div><p><h2><a href=#web%e3%82%a2%e3%83%97%e3%83%aa%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ae%e5%ae%9f%e8%a3%85%e6%96%b9%e9%87%9d%e3%82%92%e8%80%83%e3%81%88%e3%81%a6%e3%81%bf%e3%81%9f%e3%83%a1%e3%83%a2 id=webアプリケーションの実装方針を考えてみたメモ class=anchor aria-hidden=true>Webアプリケーションの実装方針を考えてみたメモ</a></h2><p>管理画面の設計について考えてみる。
Webアプリケーションでもろもろを設定する際のUI設計を考えている。</p><h3><a href=#%e3%82%b7%e3%83%b3%e3%82%b0%e3%83%ab%e3%83%a6%e3%83%bc%e3%82%b6%e3%81%ae%e8%a1%8c%e5%8b%95%e3%83%95%e3%83%ad%e3%83%bc id=シングルユーザの行動フロー class=anchor aria-hidden=true>シングルユーザの行動フロー</a></h3><p>設定の初期化時や更新時でフローが異なるはずだ。</p><p>初期化のタイミングでは、氏名やメールアドレスの設定・認証や、オプショナルな事項（決済情報とか追加の契約事項とか）の設定が挟まり、最後に確認してよければコミット、ダメなら修正する。</p><p>更新では最初の設定で気に食わなかったところを修正したり、追加の設定項目をいじったりするだろう。</p><p>それぞれのタイミングで何を設定させるかや、どれだけサクサク入力できるかによってユーザの体験が左右されそう。例えば初期では認証情報だけをコミットして、その他の情報は更新で登録する手もあれば、ファストバスを登録時に持ってきてしまって、8割のユーザが最短で使用を開始できるようにするパターンもあるだろう。</p><h3><a href=#%e3%83%95%e3%83%ad%e3%83%bc%e3%81%ae%e8%a7%a3%e9%87%88 id=フローの解釈 class=anchor aria-hidden=true>フローの解釈</a></h3><p>ユーザが行うそれぞれのフローはアプリケーションというかシステムにどのような影響を与えるだろうか。というよりも、ユーザがそれぞれのフローの結果及ぼせる作用をどのようにデザインすると良いだろうか。</p><p>この作用をデザインするにあたって、アプリケーションで表現するモデルがどんなであるかを明らかにしておくと良いはずで、そのモデルに対する作用の一つの実現方法としてユーザが操作するフローがある、と思えそう。</p><p>ユーザによる操作じゃない作用としては、決済が行われたとか権限が時間経過で失効したみたいな作用がありそう。</p><h3><a href=#%e3%83%87%e3%83%bc%e3%82%bf%e3%81%ae%e6%8c%81%e3%81%a1%e6%96%b9 id=データの持ち方 class=anchor aria-hidden=true>データの持ち方</a></h3><p>データにもいろいろありそう。モデルを表現するためのデータと、作用を実現するために一時的に保持するデータは異なる。</p><p>例えばユーザが登録されているか登録されていないかしかないモデルでは、メール認証中にはユーザが登録されていないけど、メール認証のためのトークンとかはサーバにデータとして持っていないといけない。</p><p>もちろん、そういう一時的な状態もモデルに含めるてもあるはず。RDBで実装する場合delete操作が激しくなりそうだけど。セッションキーもそうかな。セッションキーはモデルを表すデータに持つことは少なさそう。モデルの表現には含まれないログイン状態として扱われるイメージがある。揮発性のあるデータストアで保持しそう。</p><p>全部モデル化してしまうのが教科書的なんだろうな。汚いとわかるならあえて汚いことをやる必要はないだろう。</p><p>モデルではないけど、DBMSの都合について説明する記事があったので貼っとく<a href=https://jp.quora.com/%E3%82%BB%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E4%BF%9D%E5%AD%98%E3%81%AA%E3%81%A9%E3%81%ABRDBMS%E3%82%88%E3%82%8A%E3%82%82Redis%E3%82%84memcached%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA-NoSQL%E3%81%8C%E5%90%91>セッションの保存などにRDBMSよりもRedisやmemcachedのような、NoSQLが向いているのは何故ですか？他にNoSQLの用途として向いている(いない)処理にはどのようなものがありますか？ (Quora)</a></p><p>TTLが欲しいよね、という感じか。確かにそもそもセッションキーにはTTLが欲しい気がするし、モデルを考える上でTTLはあまり意識したくない気もする（頭弾けそう）。</p><p>反面、TTLもうまく表現したら面白そうな気もするし、割と欠かせないんじゃないかという気もする。そのときに普段のモデルを表現するのに使うDBとTTLを複雑さを吸い取らせるために導入したDBが異なると不必要な複雑さが生じたりするかもなと思った。</p><h2><a href=#%e5%ae%b6%e3%81%ae%e3%82%a4%e3%83%b3%e3%83%86%e3%83%aa%e3%82%a2 id=家のインテリア class=anchor aria-hidden=true>家のインテリア</a></h2><p>今日たくさん寝て軽くランニングしたらなかなか幸せな時間を過ごせた。ただいまはそのクオリティが持続していない。夕食の目処が立っていないこととか部屋がちょっと寒いこと、姿勢が微妙なことが原因だろう。軽く座って作業する空間はやはり欲しい。机にがっつり向かうか後傾でノートパソコンを叩くか、床で作業するかの三択でQOLっぽい作業時間を過ごす空間がない。コメダで作業する姿勢を家でも取れるようにしたいイメージ。やはりベンチソファだと思うんだよな。僕のユースケースだとソファだけでなく机も欲しいことに気がついたのが今週末の成果。</p><p>あとは壁が寂しいことにも気がついた。なんか怖くないすっきりとした絵とか飾ればいいんだろうな。めんどいので誰かに決めてほしい。ああいうのってどこで売ってるんでしょうね。</p></p></div><div class=post-footer><time>February 12, 2024</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2023-11-07/>2023-11-07</a></h2><div><p><p>ドキュメントを読むときに参考文献が適切に使われていないと辛い。ドキュメントには2種類あると思っている。</p><ol><li>水先案内</li><li>主張をするドキュメント</li></ol><p>主張をするタイプのドキュメントで参照先を読まないと主張を理解できない場合は辛い、というのが今回の主張。</p><p>水先案内のドキュメントとしては、wikipediaの水先案内ページやgoogle検索の結果ページが該当する。水先案内のドキュメント自体は主張をしておらず、その水先案内ページに辿り着いた読者が適切なドキュメントにたどり着くためのサポートをする役割を持つ。</p><p>主張をするドキュメントとしては、この記事やAPIの仕様を説明するページなどが該当する。参考文献とか例を上げる目的で引用とか他のドキュメントへの参照を持つことはあるけれでも、そのドキュメントを全く読まないでも主張を理解できることが期待される。もしも読まないと理解できないのであれば、その文章は主張をできていないんじゃないかと思う。サーベイ論文は主張をするドキュメントだと思う。参照を探す目的で使うこともできるけど、対象をサーベイしてこういう歴史があるとか界隈はこういう感じになっているよねといった主張をすることが目的なはずなので。論文のアーカイブページは水先案内。</p><p>ドキュメントはそれ自体で完結していて欲しいので、参照先に主張の内容が書かれているはドキュメントとして不十分で読むのが辛い。内容ではなく根拠を委譲するのは良いし、よくある引用のスタイルだと思う。</p></p></div><div class=post-footer><time>November 7, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2023-09-13/>2023-09-13</a></h2><div><p><h2><a href=#%e6%b0%97%e3%81%a5%e3%81%8d id=気づき class=anchor aria-hidden=true>気づき</a></h2><p>今家のトイレで気がついてんですが、冷蔵庫と自分の体にはどんな落書きしても人に迷惑かけないので落書きし放題です！！
何書こうかな&mldr;。</p><p>人生楽しくなってきた。今度人生つらそうな人を見たらこれを教えてあげつつ、鏡のある場所を教えつつ、マッキーをプレゼントしよう。</p><h2><a href=#%e3%82%a6%e3%82%a4%e3%82%b9%e3%82%ad%e3%83%bc%e3%81%86%e3%81%be%e3%81%84 id=ウイスキーうまい class=anchor aria-hidden=true>ウイスキーうまい</a></h2><p>ちょっと前に買ったbowmoreが美味しい。味の表現はさておき美味しいからそれでいいんです。テイスティンググラスでストレートで飲んでいます。
aged 12 yearsと書いてあります。</p><p>350ml瓶を買ったんですが、このサイズの便が一番かっこいいです。他のサイズでかっこいいのはフロムザバレルくらい？</p><p>350のbowmoreはリュックの横に挿してもいいかなというくらいかっこいい。</p><h2><a href=#%e4%b9%85%e3%81%97%e3%81%b6%e3%82%8a%e3%81%ae%e8%8b%97%e5%ad%97%e5%91%bc%e3%81%b3 id=久しぶりの苗字呼び class=anchor aria-hidden=true>久しぶりの苗字呼び</a></h2><p>会社ではあだ名で呼ぶ文化がある。それはなかなか楽しくて好きなんだけど、人生のほとんどを苗字呼びの文化で過ごしてきて、会社の飲み会で苗字よびをしてもらって、「ああ、こんな感じだったな」と昔の感覚を思い出した。新しく上の人から苗字呼びされる経験は僕にとって深いところに刻まれた体験なのかもしれない。</p><p>ホッピー師匠とも知り合えたことだし、今日の飲み会は僕にとっていいものだった。明日は走って帰るか。判断は夜にするとして、ランニングシューズを履いて、ジャージを持って出勤する。</p><h2><a href=#%e5%a4%a2%e8%8a%b1%e7%81%ab id=夢花火 class=anchor aria-hidden=true>夢花火</a></h2><p>まふまふの夢花火を久しぶりに聴いている。中学生に頃に友達にまふまふのCDを貸してもらって夢花火をしり、高校までめざましは夢花火だった。懐かしい思い出。</p><p>去年の暮れに会社の同僚がまふまふファンだと聞きちょっとテンションが上がったことを思い出した。今はまふまふの他にもdazbeeやado、co shu nieとかのアーティストが好き。オタクって感じがする。</p><p>オタクっぽくない歌手っているかと思うと、どのアーティストもそのアーティストが好きというと途端にオタクぽくなる気がするので気にすることではなさそう。
AKBもSMAPもheysayjumpも何もかも、アーティストが好きって言ったらおタックぽい気がする。</p><p>オタクっぽさを排除して「この曲が好き」みたいなことを表明しようと思うと、自身の音楽性に芯があるか流行りに乗っていくミーハーみたいになりそう。</p><p>そろそろ世間体について考えるのに疲れてきた。このくらいにしよう。僕がコモンセンスとして取れている自信を持っているのは、新劇場版のエヴァの最後のやつで「よかったねぇ」と思えたことです。ATフィールドは全ての人の間にあると思っているタイプの人間です。よろしくお願いします。</p><h2><a href=#%e3%82%aa%e3%83%95%e3%82%a3%e3%82%b9%e3%82%ab%e3%82%b8%e3%83%a5%e3%82%a2%e3%83%ab id=オフィスカジュアル class=anchor aria-hidden=true>オフィスカジュアル</a></h2><p>オフィスカジュアルっていうのやめません？
曖昧で、インターフェースで要求しているような感じがしつつ、実装する側にはその要件が伝わらない。コミュニケーションのための符号としてあまり良く機能していないように見える。</p><ul><li>ジャケット</li><li>シャツ</li><li>靴</li><li>パンツ</li></ul><p>以上の四つについての要求を書いて欲しい気持ちが芽生えた。これらが指定されない限りは、どれだけフォーマルに寄っても、喪服まで行かない限りは文句言えないと思うし、喪服まで行かなくても服を着てくる側に対して不親切だろう。</p></p></div><div class=post-footer><time>September 13, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/posts/divide-dev-posts/>ブログを分割したい</a></h2><div><p><p>このブログは日記も開発っぽいことも両方書いてある。これらを別のサイトに分けようと考えている。</p><ul><li>開発の記事が日記に埋もれるのが嫌だから</li><li>今の環境だと開発の記事を書きにくい・表現しにくいから<ul><li>コードや数式を書きにくい・表示が微妙など</li><li>madoko使いたい</li></ul></li></ul><p>そのための準備としてnetlifyを試しに使ってみた。このブログのリポジトリを登録したら、特に細かい設定をしないでもシュッとデプロイできてしまった。すごい。DNSとかSSLとかの設定を試していく。</p><p>ところでデプロイの設定は何もわからないのでチュートリアルが必要。madoko使うなら設定ちゃんとしないとだろうし。</p></p></div><div class=post-footer><time>September 6, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/posts/task-decomposition/>タスク分解と見積もり</a></h2><div><p><h2><a href=#%e8%a6%8b%e7%a9%8d%e3%82%82%e3%82%8a%e3%81%a8%e7%9b%ae%e6%a8%99 id=見積もりと目標 class=anchor aria-hidden=true>見積もりと目標</a></h2><p>見積もりとかについて真面目に考えてみる。</p><p>仕事をするときに、頑張ります！と意気込んで、目標を分解しひとつひとつこなしていくことはある程度できるし、途中で分解したタスクが違った方を向いていることに気がついて、自分がやることを軌道修正することもできる。</p><p>全部ではないけれど、ある程度のことは十分に時間があれば達成できるんじゃないかと思う。特に目標を具体的に描けていればできることは多い（できないことをなかなか目標として想像できないとか、そもそもできないことがある、みたいな話はそれはそうだけど一旦置いておく）。</p><p>仕事とかチームで動くときとかでは、歩みを揃えられることが大事なわけで、自分の好みで十分な時間を消費して良いわけではない。仕事では、目標に、達成する事項だけでなく期限がついてくる。目標を達成できそうかを判断するには、期限と見積もりを照らし合わせれば良い。</p><h2><a href=#%e3%82%bf%e3%82%b9%e3%82%af%e3%81%a8%e6%9c%9f%e9%99%90 id=タスクと期限 class=anchor aria-hidden=true>タスクと期限</a></h2><p><strong>目標</strong>は期限と達成する事項のペアだと思うことにして、達成する事項のことは<strong>タスク</strong>と呼ぶことにしよう。つまり、目標はタスクと期限のペア。今まではタスクを分解して一個ずつクリアしていけば良かったが、仕事では目標を分割して、タスクをクリアする中で期限も一緒に守らないといけない。次元が増えるのだから難しくなるのは当たり前だ。</p><p>タスクの分解は、タスクをよく観察して論理的に推論すれば割と上手くいく。それに対して期限を含めてうまく目標を細分化するには、つまり見積もりをするには、自分の能力や環境要因、タスクの達成の確実性などを含めて考慮しないと考え切ることはできない。</p><p>見積もりは曖昧さを伴ったものになるはず。そこが難しいのかな。また、タスクを分解して軌道修正をするとタスクはそれで洗練される一方で、期限の方は純粋に遅れが生じるのも難しい。時間は巻き戻らないのだ。</p><h2><a href=#%e8%a6%8b%e7%a9%8d%e3%82%82%e3%82%8a%e3%81%ae%e5%ae%89%e5%ae%9a id=見積もりの安定 class=anchor aria-hidden=true>見積もりの安定</a></h2><p>見積もりを安定させるには、このように生じる遅れの量を最小化すれば良い。そのためには目標の分解を小さくして、細かい粒度で軌道修正すれば安定するはず。あまり細かく分解しないでガッと取り組みうまくいけば最速だし、細かく分解して検討を繰り返して良さそう良さそうと確認をたくさんするのは時間がかかる。それでも確認することを込みで見積もることはできるので、安定性の面ではやはり有利に働くだろう。この辺りは最急降下法とかで、一回のイテレーションでどのくらい進むのが良いか、みたいな話と似ている。</p><p>なんにせよ、今の僕は安定した見積もりをできていないので学習の意味を込めて、細かすぎるくらいのタスクの分解をするのが良いのだろうなと思った。</p><p>自分の性格と合うだろうか。</p><h2><a href=#%e3%83%81%e3%83%bc%e3%83%a0%e3%81%a7%e3%81%ae%e4%bb%95%e4%ba%8b id=チームでの仕事 class=anchor aria-hidden=true>チームでの仕事</a></h2><p>先ほどの段落で、一発でガッと仕事して上手くいけばそれが最速、みたいなことを言った。これが実際にありうるのは個人で仕事をしているときであって、チームで仕事をするときには普通以心伝心というわけにはいかず、解釈違いやすり合わせ、議論に会話が必要だろうし、それができるのがチームの強みのはず。</p><p>これをこまめに行うことは、多くのチームにとって課題だろうし、僕がチームに参加するときに度々足りていないなと思うところでもある。</p><p>タスクの分解を細かくすることでコミュニケーションの機会を増やせるだろうから、チームでの仕事には細かいタスク分解がプラスに働きやすそう。</p></p></div><div class=post-footer><time>August 31, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/posts/dotfiles-setup/>dotfilesのセットアップスクリプトを書いた</a></h2><div><p><h2><a href=#%e5%8b%95%e6%a9%9f id=動機 class=anchor aria-hidden=true>動機</a></h2><p><a href=https://github.com/naoyafurudono/dotfiles/tree/main>dotfiles</a>をGitHubで管理しているのだが、今までは設定ファイルの管理だけで、インストールは手動で行なっていた。設定ファイルを使いまわせるだけでだいぶ便利なんだけど、コンテナ環境の中で作業したくなると、手動インストールに耐えられなくなる。そこで重い腰を上げてセットアップを自動化した。</p><h2><a href=#%e3%82%84%e3%81%a3%e3%81%9f%e3%81%93%e3%81%a8 id=やったこと class=anchor aria-hidden=true>やったこと</a></h2><h3><a href=#cli%e7%92%b0%e5%a2%83%e3%81%ae%e3%82%bb%e3%83%83%e3%83%88%e3%82%a2%e3%83%83%e3%83%97%e3%82%92%e7%b0%a1%e5%8d%98%e3%81%ab%e3%81%97%e3%81%9f id=cli環境のセットアップを簡単にした class=anchor aria-hidden=true>CLI環境のセットアップを簡単にした</a></h3><p><code>git</code> のインストールと以下の実行でok。
nvimとかfishとかcargoとかが入る。</p><pre><code class=language-sh>git clone https://github.com/naoyafurudono/dotfiles.git
bash dotfiles/setup.sh
</code></pre><h3><a href=#%e3%81%95%e3%82%89%e3%81%ab%e5%8b%95%e4%bd%9c%e7%a2%ba%e8%aa%8d%e3%81%ae%e3%81%9f%e3%82%81%e3%81%aedocker%e3%82%92%e7%94%a8%e3%81%84%e3%81%9f%e3%83%86%e3%82%b9%e3%83%88%e3%82%82%e6%9b%b8%e3%81%84%e3%81%9f id=さらに動作確認のためのdockerを用いたテストも書いた class=anchor aria-hidden=true>さらに動作確認のためのDockerを用いたテストも書いた</a></h3><p><a href=https://github.com/naoyafurudono/dotfiles/tree/main#test>test</a></p><p>arm環境かつubuntuだけでしか動かしていないが、dockerコンテナでセットアップスクリプトを動かして、正常に終了するかを確認するテストを書いた。</p><h2><a href=#%e6%b0%97%e3%81%ab%e3%81%aa%e3%82%8a%e3%81%94%e3%81%a8 id=気になりごと class=anchor aria-hidden=true>気になりごと</a></h2><p>この手のセットアップスクリプトのテストって、世の中ではどのようにテストしているんだろう。以下の難しさがテストを大変にしている気がする。</p><ul><li>環境依存な部分をうまく吸収する必要があること</li><li>インストール失敗の判定が難しいこと</li></ul></p></div><div class=post-footer><time>August 17, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2023-07-01/>2023-07-01</a></h2><div><p><h2><a href=#envsubst%e3%82%92%e7%9f%a5%e3%81%a3%e3%81%9f id=envsubstを知った class=anchor aria-hidden=true><code>envsubst</code>を知った</a></h2><p><code>envsubst</code>を使うと標準入力の環境変数の参照っぽいところに環境変数の値を埋め込んだテキストを吐ける。
readmeにコマンドのヘルプメッセージを載せたいときに便利。例: <a href=https://github.com/naoyafurudono/tools/tree/main/cl>https://github.com/naoyafurudono/tools/tree/main/cl</a></p><h2><a href=#git-ls-files id=git-ls-files class=anchor aria-hidden=true><code>git ls-files</code></a></h2><p>gitで管理しているファイルのパスが得られる。
git grepみたいに管理対象だけに興味があるときに便利そう。
fzfとの相性が良さげ。</p></p></div><div class=post-footer><time>July 1, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2023-05-04/>2023-05-04</a></h2><div><p><ul><li>昨日スクワットしてからランニングしたら、今日トレランに行った翌日みたいな感覚になっている。手軽に足の疲労感を感じられておとく。</li><li>この間オンライン飲み会をしたときに<a href=https://yfukuda4.wixsite.com/index/blank-2>秋吉台ロゲ</a>に参加することを決めてしまった。
5/21に5時間走る予定。競技エリアが「秋吉台山焼きの実施範囲」とされていて絶対楽しい。
5時間走って新幹線に飛び乗り、翌日仕事できる体力をつけないといけない。まずはたくさん走ることに慣れよう。5/6の午前中にたくさん走ることにする。ロゲイン的な走り方をしたい。平野ではないけど山でもないところをのっぺり走り続けるようなスタイルをイメージ。</li></ul></p></div><div class=post-footer><time>May 4, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2023-04-28/>2023-04-28</a></h2><div><p><h2><a href=#%e6%84%8f%e5%91%b3%e8%ab%96%e3%81%ae%e8%a9%b1 id=意味論の話 class=anchor aria-hidden=true>意味論の話</a></h2><p>今日は意味論の直感が少し生えたので機嫌がいい。寝て起きたらもう少しまじめに考えよう。</p><h3><a href=#%e8%bf%bd%e8%a8%98 id=追記 class=anchor aria-hidden=true>追記</a></h3><p>完全に忘れていた。一回捨てた継続渡しスタイルで考えるのがやはり良いだろうという直感のもとでの考えだった。細かいことは忘れてしまったが、少し考えれば再現できる程度だったと思う。継続フレームを生むときと、式を評価するタイミングを明示的にわけるとか、反対にそういうくくりで共通化することでこれまで見えていなかったアスペクトが表面化していい感じになりそう、みたいな直感だった気がする。</p></p></div><div class=post-footer><time>April 28, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2023-04-27/>2023-04-27</a></h2><div><p><h2><a href=#%e6%a5%bd%e3%81%97%e3%81%95 id=楽しさ class=anchor aria-hidden=true>楽しさ</a></h2><p>人と語るわけでもなければ、熱狂的に推すわけでもないのに、僕はなにのためにアニメを見たり、小説を読んだり、音楽を聞いたりするのだろうか。アニメはほぼ毎日みるし、小説は人並み以上に読むと思う。漫画もそれなりに読むし、音楽もなんやかんや毎日聞いている。これまでそういう作品の良さをまともに語ったことはないし、積極的に人と共有したりもしない。物語のキャラクターを推したいと思ったこともない。アーティストを好きになることはあっても、エッセイを読みたいとはあまり思わなくて、あくまでその人の作品が好きだからアーティストを好きになっているように思う。</p><p>アニメや漫画は単に面白いからだろうか。少なくとも日常的に触れる作品はそういう毛色が強い気がする。たとえば、鬼滅の刃やかぐや様のアニメはおもしろいから見ている。その一方で、ゾクゾクする経験があって、それが好きだという側面もある。たとえば91daysは面白かったがそれ以上にゾクゾクしたから記憶に残っている気がする。
Fate heaven&rsquo;s feelやヴァイオレット・エヴェーガーデンも僕にとってゾクゾク系。</p><p>音楽はゾクゾクするのを求める気持ちがより強い。Co shu nie には特にゾクゾクを求めている。その他アニソンやボカロ、ピアノ、その他jpopも、そのときの気分にあったゾクゾクを求めて聞いている気がする。横道だけど、900STを買ってから飛躍的に音楽を聞くのが楽しくなった。幸いなことにヘッドホンはまだこれしか買っていない。初手でいいものを買う戦略が功を奏した。昨日くらいから電車通勤で音楽を聞くことに良さを見出してしまい、ワイヤレスでノイキャンのついたいいヘッドホンが欲しくなってしまった。</p><p>話を戻そう。ふんわり楽しい時間を求めるのと、ゾクゾクするのを求めるのの、２つの欲求があってそれらを満たすためにアニメとか音楽とかを浴びているようだ。それらの限らず、僕の幸せはそのどちらかにあるような気がする。ゾクゾクするほうが刺激的で楽しいので、今後はそっち方面の体験を増やすために意思決定を進めようと思う。</p><h3><a href=#%e8%bf%bd%e8%a8%98 id=追記 class=anchor aria-hidden=true>追記</a></h3><p>散歩をしてきて、本当に音楽とかに限らない話だと思った。プログラミング言語や数学のことを考えたり、プログラミングをしたり、オリエンテーリングをするときに、僕が一番好きな瞬間でモチベーションになっている体験はやはりゾクゾクしたときのことだと思う。今挙げた分野でのゾクゾクは、ハイになって、理解のぎりぎりのところで間に合ってというか、手が届いて自分のものにできた感覚だ。それに対して音楽とかアニメとかでのゾクゾクは、与えられた気持ち良さですごく心地良い体験だったり、強く共感したり、よくそこまでいった！すごい！みたいな感動から来る気がする。どちらのゾクゾクも僕を幸せにしてくれるけど、なんとなくプログラミング言語と戯れているときみたいなゾクゾクのほうが欲しい気がする。</p></p></div><div class=post-footer><time>April 27, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2023-04-03/>2023-04-03</a></h2><div><p><p>オリエンテーリングの人たちと飲み会をした。社会人としての心構え（）を教えて頂いた。今日の入社式から頑張って行こうと思う。</p><p>こういう書き方をするとふざけているようにしか見えないだろうけど、内心ではそれなりに不安に思っているし、しっかりとしたフィードバックも受け取れたと思う。</p><p>今日、明日で良い出会いをできるといいな。</p></p></div><div class=post-footer><time>April 3, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/daily/2023-03-19/>2023-03-19</a></h2><div><p><p>最近AIが流行っていて、精度がすごいと話題で、生活が多かれ少なかれ変わっていくのだろうなという感じがする。ああいう機械学習ベースのAIは学習で直感を鍛えて、それに基づく出力をするものだと僕は解釈している。人間が頭を使うときには直感を論理とか議論で検証して、主張の穴を見つけて改善するサイクルを回すはずだ。今の機械学習っぽいAIは直感で得た主張を論理で解釈しないだろう（<a href=https://www.nec.com/en/global/rd/technologies/201807/index.html>NECがそういうことを考えていそう</a>。それができればAIはもっとつよくなるはずだし、そういうAIを見てみたい。</p><p>実現するためにはAIの入出力に使う「言語」に解釈を入れることと、それをもとにして論証を行うことが必要だろう。今のAIは抽象構文木を操作の対象にしていて、それを意味を解釈するようにしたらいいんじゃないかという想像だ。</p><p>今ある論理が世の中の事象を扱うのに十分かはわからないし、多分結構不足しているはずだ。機械学習AIのための論理体系の研究とかあったら楽しいだろう。NIIとかでやってないだろうか？</p><h2><a href=#big-peat%e3%81%8c%e3%81%99%e3%81%94%e3%81%8f%e3%81%8a%e3%81%84%e3%81%97%e3%81%84 id=big-peatがすごくおいしい class=anchor aria-hidden=true>Big Peatがすごくおいしい</a></h2><p>おととい届いた<a href=https://bigpeat.com/>Big Peat</a>がとてもおいしい。明日の研究室飲み会にもっていこう。ちょうど二年くらい前に部活の先輩に勧めていただいたのだが、懐具合の問題で飲めずにいた。少し無理してでも飲んでおいたほうが良かったかと思うくらいには好き。ストレートで飲んでもおいしいし、ハイボールにしてもおいしい。天才か？
ぼくはスコッチウイスキー？が好きなのかもしれない。</p><p>学部2年のころ、確率論基礎の試験の前日にウイスキーを飲む会に誘っていただいたとき、ラフロイグ・ロアを味見させていただいて半分感動したのを覚えている。あのころは二十歳になりたてでお酒のおいしさは今よりも分かっていなかったのだが、それでもいいかんじなことは分かった。それからラフロイグ・ロアには縁がなかったのだが今気になっている。数量限定なようで、毎年11月ころに発売されそうな雰囲気がある。今もアマゾンで売ってるが、転売価格に見えるので時期がくるまで我慢しよう。</p><p>ちなみにBig Peatと一緒に勧めていただいたジョニーウォーカーのグリーンラベルはすでに飲んでいて、 やはり好きな感じだった。</p></p></div><div class=post-footer><time>March 19, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/posts/window-manager/>使い勝手の良いデスクトップ向けウィンドウマネージャが欲しい</a></h2><div><p><p>使い勝手のよいウィンドウマネージャがWindowsとかMacに搭載されることはないだろう。使うアプリケーションやブラウザ、入力デバイスやその使い方によって使い勝手が大きく変わるだろうから。
OSが決め打ちで提供できるものでは無いんじゃないかと思う。なので自分でまじめに使い勝手の良いものを考える必要がある。</p><p>先日オリエンテーリングのインカレの配信のお手伝いをしたのだが、そこで使っていたスイッチャがなかなかデスクトップでのウィンドウマネージャの機能として魅力的に感じた。</p><p>スイッチャにはいろんなウィンドウ（カメラからの入力や、図、合成用のテロップなど）が接続されていて、すべてが画面の下部に控えめに表示される。それらを見ながらスイッチャのオペレータが放送するためのウィンドウを選択、合成する。放送されるウィンドウは画面上部に大きく表示される。放送されるウィンドウの右に同じサイズでプレビューウィンドウも表示される。これらの違いは放送されるか否かだけで、合成のテストとかに使える。</p><p>これを実現するためには操作用のデバイス（このデバイスをスイッチャというようだ）と、大きなモニタが必要だ。</p><p>デスクトップのウィンドウマネージャでもスイッチャのように</p><ul><li>すべてのウィンドウを表示しておいて</li><li>本番+alphaくらいのウィンドウをメインエリアに表示する</li></ul><p>と便利な気がする。単純にはいかないだろうけど、いい線行きそうだ。</p><p>懸念事項は以下の通り:</p><ul><li>ウィンドウの個数が多くなりそう</li><li>ウィンドウサイズが固定ではない（アスペクト比）</li><li>ウィンドウの動的な生成とその配置方法が非自明</li></ul></p></div><div class=post-footer><time>March 16, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/posts/effect-handlers-without-continuation/>エフェクトハンドラの良さと実用性について</a></h2><div><p><p>エフェクトハンドラで継続や代数的エフェクトを扱う必要性は一ミリもなくて、実用的にそれらが欲しくなることはないか、あるいは限られていてそこまで一般的な機能を提供する必要はないんじゃないかと感じている。</p><p>このあたりを議論するために</p><ol><li>エフェクトハンドラの嬉しさ</li><li>意味論の歴史的経緯</li><li>改善ポイント</li></ol><p>を考える。</p><p>なお、この記事はとくに裏付けもなく書いている。気が向いたら裏付けをしようと思っているが、この記事の目的は僕の考えの整理であって、世に主張をしたいわけではない。</p><p>記事の内容は不正確なことを留意されたい。</p><h2><a href=#%e3%82%a8%e3%83%95%e3%82%a7%e3%82%af%e3%83%88%e3%83%8f%e3%83%b3%e3%83%89%e3%83%a9%e3%81%ae%e5%ac%89%e3%81%97%e3%81%95 id=エフェクトハンドラの嬉しさ class=anchor aria-hidden=true>エフェクトハンドラの嬉しさ</a></h2><p>エフェクトハンドラが実際的 (practical) なプログラミング言語でエンドユーザに使わせたくなるのは</p><ul><li>エフェクトシステムと相性のよい意味論</li><li>動的束縛</li></ul><p>を提供したいからではないだろうか。エフェクトハンドラを言語に入れれば、それで表現できる操作は自動的にエフェクトシステムで追跡できるし、ハンドラを用いることでエフェクトをローカルに使えるのは特筆するべきだろう。汎用性とlocal reasoningのしやすさはエフェクトハンドラのもつ良い性質だと思う。</p><p>エフェクトハンドラで実現できる動的束縛はとても使い勝手が良い上に、エフェクトシステムで追跡することで使い勝手が上がりそうだ。動的束縛のためだけのエフェクトシステムではなく、もう少し凝ったことができるエフェクトシステムがつくとなお幸せだろうから、エフェクトハンドラみたいな抽象度の比較的高いフレームワークで実現するのは幸せなんじゃないかと感じる。</p><h2><a href=#%e6%84%8f%e5%91%b3%e8%ab%96%e3%81%ae%e6%ad%b4%e5%8f%b2%e7%9a%84%e7%b5%8c%e7%b7%af id=意味論の歴史的経緯 class=anchor aria-hidden=true>意味論の歴史的経緯</a></h2><p>エフェクトハンドラと呼ばずに &ldquo;algebraic effects&rdquo; とか &ldquo;algebraic effects and handlers&rdquo;
とか呼ぶ流派、時代がある。歴史的には</p><ul><li>algebraic effects</li><li>algebraic effects and handlers</li><li>effect handlers</li></ul><p>みたいな流れで登場したはずだ。最初はハンドラはなくて、モナドとかの話をするような人たちが副作用にモナドではない別の表現を与えようとしたんだったか。ここでいうモナドはモナド則とかを真面目に考えるような数学のモナド。代数的エフェクトもその流れの中に（このころは）あったはず。そもそも代数的エフェクトの代数とは、操作が（0だか1こ以上）あって、それらに等式制約を課す。それを満たすようなモデルを持つのが代数 (algebra) である、みたいな世界だっと思う。群とか環は代数だけど、体は代数じゃないみたいな話を聞いたことがある。そういうのりの代数として、エフェクトを表現したらモナドの合成みたいなことを考えるときに幸せだ、という主張がことの発端だった気がする。</p><p>ここまでは数学とかモデル理論？とかの話によっていて、あまりプログラミング言語っぽい雰囲気がしない。ハンドラとか継続が入ってきた経緯はしらないが、多分、プログラミング言語に代数的エフェクトを入れるにあたって、モナドのbindやreturnみたいなものを定義するように、エフェクトに意味を与える仕組みとしてハンドラが考えられたんじゃないかと思う。このあたりは論文をまじめに読めば分かるはず。これが確か2014年くらいのこと。</p><p>2000年くらいだったかから考えられていたエフェクトシステムとの相性に目をつけたからか知らないが、「代数的エフェクトとハンドラ」を取り入れた言語が2014年ころに登場し始める。2017年くらいにでてくる印象がある。
EffやKokaはこのへんな気がする。このあたりで、エフェクトが代数的であることはとくに気にされなくなっていき、エフェクトシステムと例外ハンドラがうまいこと組み合わさる限定継続演算子くらいの気持ちで代数的エフェクトとそのハンドラが捉えられて、やがて代数的ではないことが気になる人々がエフェクトハンドラと呼ぶようになったのではないかと思っている。</p><h2><a href=#%e6%94%b9%e5%96%84%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88 id=改善ポイント class=anchor aria-hidden=true>改善ポイント</a></h2><p>限定継続は本当に必要だろうか。もっとやさしい概念を提供するのにとどめるのはいかがだろうか。ワンショット継続とかに限定する言語もあるが、それは正しい方向性だろうか。</p><p>僕たちがほしかったものは、local reasoningしやすいエフェクトシステムとそれで健全に管理できる意味論なんじゃないかと思う。エフェクトハンドラはその条件を満たすけど、もっと使い心地のよい意味論があるはずだと思う。</p><h2><a href=#%e3%81%82%e3%81%a8%e3%81%8c%e3%81%8d id=あとがき class=anchor aria-hidden=true>あとがき</a></h2><p>最後の文をメモしたくてこの記事を書いた。それ以外は文脈である。</p></p></div><div class=post-footer><time>March 16, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/posts/print-docs/>軽いドキュメントを印刷するためのツールが欲しい</a></h2><div><p><p>さくっと書いた文書を印刷したいことがある。ビジネスライクな手紙とか、その日のTODOリストなんかがそうだ。
LaTeXやMadokoを使うのは大げさな感じがして、諦めて手書きするか、Google Docsで済ませることが多い。とはいえ手紙の書き方を毎回調べたり、フォーマットを調整したり、PCで打ち込んだデータを手書きするのはつらい。</p><p>テンプレートと変数の宣言、UIの調整と文書のまともな処理をして印刷（A4）できるものが欲しい。A4のPDFに変換できればよい。それぞれの文書のソースはマークダウンのちょっとした拡張くらいの文法で書きたい。エディタで編集したいのでGoogle Docsとかはなしで。テンプレートの作成方法はテキストにこだわらない。いじりやすいと嬉しい。</p><p>問題が以下のように分割できるはず。</p><ul><li>テンプレート作成</li><li>ソースの文法<ul><li>Markdown拡張</li></ul></li><li>テンプレートへのソースの埋め込み</li><li>PDFへの変換</li></ul><p>HTML/CSSやlatexを勉強してMadokoでくっつければなんとかできる気はするが、大変そうだしあまり楽しくない。文書作成ツールを自作するか？とりあえず、HTML/CSSで手紙を表現できるようになるところから始めるのが良さそうか。自作マークダウン拡張（というより処理系）はまれに欲しくなるのでやっても良いだろう。Hugoもそんなに快適じゃないし、Madokoはいじりにくいので。</p><ul><li>自分でコードをいじりやすいこと</li><li>メタな文書処理がしやすいこと<ul><li>識別子や文書の変数への束縛、正規表現やCFGベースのテキスト置換など</li><li>この辺はMadokoが強い</li></ul></li><li>そういえばMadokoはPDFの生成でHTMLを使わずにlatexを使っていたな&mldr;</li></ul><p>ここまで来て、<a href=https://github.com/cognitom/paper-css>Paper CSS</a>という良さげなリポジトリを見つけた。
Qitaでこのライブラリを使って<a href=https://qiita.com/cognitom/items/d39d5f19054c8c8fd592>帳票を作る例が解説されている</a>。</p><p>まだそれぞれをあまり読んでいないのであとで確認する。このあたりの技術に合うように出力することにして、それを生成するマークダウンエンジンを用意すればok?</p><p>やはりしんどい気がする。GUIでなんとかする方法を探すのが楽だろうか。あらためて考えよう。</p><h3><a href=#%e8%bf%bd%e8%a8%98-google-docs-api id=追記-google-docs-api class=anchor aria-hidden=true>追記: Google Docs API</a></h3><p><a href="https://developers.google.com/docs/api/reference/rest?hl=ja">Google Docs API</a>を利用するのはどうだろうか。
APIはあまりリッチではなくて、create, update, pullができるのみ。文書構造の編集はJSONをごりごりいじることで実現する。<a href="https://developers.google.com/docs/api/reference/rest/v1/documents?hl=ja">JSONスキーマが定義されている</a>ので、これを見ながら必要な変換を定義すればよい。</p><p>テンプレートをGoogle DocsのGUIで作成して、それをAPIでpullした上で、コンテンツを注入したドキュメントをcreateすれば、やりたかったことを実現できそうだ。テンプレートの置き換え箇所の指定方法はどうするのが良いだろうか。</p><p><code>(開始記号)名前(引数リスト)(終了記号)</code>を文書に埋め込む。これがひとかたまりの文書オブジェクトとして認識されることが必要。また、これにスタイリングを適用した場合、埋め込み後もそのスタイリングが保たれるようにする。引数に他の名前が出現しうることに注意する</p><p>テンプレに埋め込むテキストを定義する側では、埋め込み内容の定義リストを作成する:</p><pre><code class=language-python>def name(args: list[str]) -&gt; str:
  return f&quot;&quot;&quot;\
ここに置換後の文字列を書く。
ここにも埋め込みの出現を許す。
&quot;&quot;&quot;
</code></pre><p>埋め込み処理では、JSON形式のテンプレのすべてのテキストについてマクロ展開をすればよい。</p><h3><a href=#%e8%bf%bd%e8%a8%98-web%e6%8a%80%e8%a1%93%e3%81%a7%e6%9c%ac%e3%81%8c%e4%bd%9c%e3%82%8c%e3%82%8b- id=追記-web技術で本が作れる- class=anchor aria-hidden=true>追記: Web技術で「本」が作れる &mldr;</a></h3><p>リブロワークスからCSSで組版するノウハウをまとめた本が<a href="https://libroworks.co.jp/?p=6956">5/12に出るらしい</a>。途中までを<a href="https://libroworks.co.jp/csskumihan/viewer/#src=/csskumihan/0_frontmatter.html&amp;f=epubcfi%28/4!%29">オフィシャルが公開している</a>。
Vivliostyleというソフトを使って、MarkdownとCSSで書籍を作るらしい。その手のソフトは他にもあるようで、<a href=https://print-css.rocks/lessons>比較サイト</a>を先の書籍で紹介されていた。</p><p>こう思うとmadokoはだいぶ良いものだなと感じる。適用範囲を限定した置換とlatexはなかなか強い。
latexとcssを完全に理解すればmadokoが最高かもしれない。</p></p></div><div class=post-footer><time>February 24, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/posts/tips-for-tagging/>HugoでタグをつけるためのTips</a></h2><div><p><p>車輪の再発明ではあるだろうけどメモしておく。<code>archetypes/</code>に<code>hugo new</code>で生成する<code>.md</code>ファイルのテンプレを置くことができる。そこにありうるすべてのタグを書いておけば、記事を書くときに関係ないタグを消すことで、関連するタグを忘れずにつけることができる。</p><p>僕は以下のようにフロントマターを設定している。</p><pre><code>---
title: &quot;TODO&quot;
date: {{ .Date }}
author: &quot;Naoya Furudono&quot;
draft: true
tags: [
    &quot;daily&quot;
    ,&quot;PL&quot;
    ,&quot;tech&quot;
    ,&quot;ubuntu&quot;
    ,&quot;alexa&quot;
    ,&quot;book&quot;
    ,&quot;idea&quot;
    ,&quot;python&quot;
    ,&quot;tool&quot;
]
---
</code></pre></p></div><div class=post-footer><time>February 16, 2023</time></div></article><article><h2><a href=https://blog.nfurudono.com/posts/local-file-transfer/>Local File Transfer</a></h2><div><p><p>近距離でのファイル交換はあまり洗練されていない印象がある。
Apple製品間ではAirdropが使えるし、Windowsにも似たような機能があったはずだ。でも汎用的に（たとえばOSを気にせずに）使える機能は見かけない。そういうときにはGoogle DriveやDropBoxみたいなクラウドサービスを使うか、USBメモリを使うのが一般的だろう。
Slackとかメールに頼ることもある。</p><p>インターネットに頼るのは不便だし、USBメモリが刺さらないデバイスも多い。
Blootoothを基本の通信方式として、それが使えない場合にインターネットを経由するのはいかがだろうか。</p><p>通信技術は既存手法を組み合わせるだけで良いだろう。難しいことはないだろう。一方でアプリケーションのUIには工夫が必要なのではないだろうか。</p><ul><li>どこにファイルを保存するか</li><li>OS間でのファイルの互換性</li><li>送信先の選択</li><li>受信の制御</li></ul><p>これらの選択に一般的な回答は存在するだろうか？
他のアプリに組み込む形がよいかもしれない。例えばローカルの会議で各自が自身のPCで文書や画像、図面などを編集するアプリがあったとして、参加者間でのデータ共有のために今考えているものを使う。このときUIはアプリの特性から決まるだろう。</p><p>この例に対して、スマホやPCのファイルシステムは一般的すぎて設定を決め打ちできないのではないだろうか。そうすると、ファイル共有の実行時にユーザが設定をあたえることになる。大変不便だろう。</p><p>設定ファイルの編集やディスパッチの機能をつければ楽になるか？
ルールエンジンとかは大げさだろうか。</p></p></div><div class=post-footer><time>July 14, 2022</time></div></article></div><footer class=footer-mobile><div class=social-icons><a class=social-icon href=https://twitter.com/furudono2 target=_blank rel=noopener title=Twitter><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M8.991284 24.971612c10.189152.0 15.761088-8.441388 15.761088-15.761088C24.752372 8.970656 24.747512 8.731868 24.736496 8.494376 25.818008 7.712564 26.758256 6.737 27.5 5.62622c-.992628.440856-2.060748.738072-3.181248.871992 1.14372-.685584 2.02176-1.770768 2.435832-3.064176-1.070496.6345-2.25558 1.095984-3.517344 1.344492-1.010772-1.076652-2.450412-1.75014-4.043412-1.75014-3.059424.0-5.540292 2.480868-5.540292 5.539104.0.434808.0487079999999995.857412.14364 1.26306C9.19346 9.599108 5.11106 7.39472 2.3792 4.04294c-.476172.818424-.750168 1.769688-.750168 2.784132.0 1.921968.97794 3.61854 2.464992 4.61106C3.185528 11.41016 2.331788 11.160464 1.585184 10.745096 1.583888 10.768208 1.583888 10.791428 1.583888 10.815728c0 2.683152 1.909764 4.922856 4.4442 5.43078C5.562932 16.373084 5.07326 16.44134 4.56782 16.44134 4.210988 16.44134 3.863876 16.406024 3.526484 16.34144c.70524 2.200824 2.750112 3.802356 5.174928 3.8475-1.896264 1.485756-4.284576 2.37114-6.879924 2.37114C1.374476 22.56008.93362 22.534592.5 22.4834c2.451708 1.571076 5.362524 2.488212 8.491284 2.488212"/></svg>
</a><a class=social-icon href=https://www.instagram.com/donofuru/ target=_blank rel=noopener title=Instagram><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M14.0000238 2.00378571c3.2579524.0 3.6664762.0138095300000001 4.946.0721904800000002C20.222881 2.13421429 21.0949286 2.33702381 21.8579762 2.63359524 22.6468333 2.94011905 23.3158333 3.35030952 23.9827857 4.01721429 24.6496905 4.68416667 25.059881 5.35316667 25.3664524 6.14202381 25.6629762 6.90507143 25.8657857 7.77711905 25.9240238 9.05397619 25.9824048 10.3335 25.9962143 10.7420238 25.9962143 14.0000238 25.9962143 17.2579762 25.9824048 17.6665 25.9240238 18.9460238 25.8657857 20.222881 25.6629762 21.0949286 25.3664524 21.8579762 25.059881 22.6468333 24.6496905 23.3158333 23.9827857 23.9827857 23.3158333 24.6496905 22.6468333 25.059881 21.8579762 25.3664524 21.0949286 25.6629762 20.222881 25.8657857 18.9460238 25.9240238 17.6665 25.9824048 17.2579762 25.9962143 14.0000238 25.9962143 10.7420238 25.9962143 10.3335 25.9824048 9.05397619 25.9240238 7.77711905 25.8657857 6.90507143 25.6629762 6.14202381 25.3664524 5.35316667 25.059881 4.68416667 24.6496905 4.01721429 23.9827857c-.66690477-.6669524-1.07709524-1.3359524-1.38361905-2.1248095-.29657143-.7630476-.49938095-1.6350952-.55761905-2.9119524C2.01759524 17.6665 2.00378571 17.2579762 2.00378571 14.0000238 2.00378571 10.7420238 2.01759524 10.3335 2.07597619 9.05397619 2.13421429 7.77711905 2.33702381 6.90507143 2.63359524 6.14202381c.30652381-.78885714.71671428-1.45785714 1.38361905-2.12480952.66695238-.66690477 1.33595238-1.07709524 2.12480952-1.38361905C6.90507143 2.33702381 7.77711905 2.13421429 9.05397619 2.07597619 10.3335 2.01759524 10.7420238 2.00378571 14.0000238 2.00378571zm0 2.16147619C10.796881 4.1652619 10.4174524 4.1775 9.1525 4.23521429 7.98288095 4.28854762 7.34769048 4.48397619 6.92497619 4.6482619 6.36502381 4.86588095 5.96540476 5.12583333 5.54564286 5.54564286c-.41980953.4197619-.67976191.81938095-.89738096 1.37933333-.16428571.42271429-.35971428 1.05790476-.41304761 2.22752381C4.1775 10.4174524 4.1652619 10.796881 4.1652619 14.0000238 4.1652619 17.203119 4.1775 17.5825476 4.23521429 18.8475 4.28854762 20.017119 4.48397619 20.6523095 4.6482619 21.0750238 4.86588095 21.6349762 5.12588095 22.0345952 5.54564286 22.4543571 5.96540476 22.8741667 6.36502381 23.134119 6.92497619 23.3517381 7.34769048 23.5160238 7.98288095 23.7114524 9.1525 23.7647857 10.4173095 23.8225 10.7966429 23.8347381 14.0000238 23.8347381 17.2033571 23.8347381 17.5827381 23.8225 18.8475 23.7647857 20.017119 23.7114524 20.6523095 23.5160238 21.0750238 23.3517381 21.6349762 23.134119 22.0345952 22.8741667 22.4543571 22.4543571 22.8741667 22.0345952 23.134119 21.6349762 23.3517381 21.0750238 23.5160238 20.6523095 23.7114524 20.017119 23.7647857 18.8475 23.8225 17.5825476 23.8347381 17.203119 23.8347381 14.0000238 23.8347381 10.796881 23.8225 10.4174524 23.7647857 9.1525 23.7114524 7.98288095 23.5160238 7.34769048 23.3517381 6.92497619 23.134119 6.36502381 22.8741667 5.96540476 22.4543571 5.54564286 22.0345952 5.12583333 21.6349762 4.86588095 21.0750238 4.6482619 20.6523095 4.48397619 20.017119 4.28854762 18.8475 4.23521429 17.5825476 4.1775 17.203119 4.1652619 14.0000238 4.1652619zm0 13.8334762c2.2084286.0 3.9987143-1.7902857 3.9987143-3.9987143.0-2.2084762-1.7902857-3.9987619-3.9987143-3.9987619-2.2084762.0-3.9987619 1.7902857-3.9987619 3.9987619.0 2.2084286 1.7902857 3.9987143 3.9987619 3.9987143zm0-10.15895239c3.4021905.0 6.1601905 2.75799999 6.1601905 6.16023809.0 3.4021905-2.758 6.1601905-6.1601905 6.1601905-3.4022381.0-6.16023809-2.758-6.16023809-6.1601905.0-3.4022381 2.75799999-6.16023809 6.16023809-6.16023809zm7.8431429-.24338095c0 .79504762-.644523800000002 1.43952381-1.4395715 1.43952381C19.6085952 9.03592857 18.9640714 8.39145238 18.9640714 7.59640476S19.6085952 6.15683333 20.4035952 6.15683333c.795047699999998.0 1.4395715.64452381 1.4395715 1.43957143z"/></svg>
</a><a class=social-icon href=https://www.linkedin.com/in/naoya-furudono target=_blank rel=noopener title=LinkedIn><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M2 3.654102c0-.95502059.79442509-1.73012354 1.77383592-1.73012354H24.2261641C25.2058917 1.92397846 26 2.69908141 26 3.654102V24.3462148C26 25.3015521 25.2058917 26.0760215 24.2261641 26.0760215H3.77383592C2.79442509 26.0760215 2 25.3015521 2 24.3465315V3.65378524 3.654102zM9.27526132 22.1415901V11.2356668H5.65030092V22.1415901H9.27557808 9.27526132zM7.46341463 9.74691162c1.2638581.0 2.05068103-.83750395 2.05068103-1.88406715C9.49033893 6.79252455 8.72727273 5.97846056 7.48748812 5.97846056c-1.24073487.0-2.05099778.81406399-2.05099778 1.88438391.0 1.0465632.78650618 1.88406715 2.00316756 1.88406715h.02343998H7.46341463zM11.2815965 22.1415901h3.6246436v-6.089642C14.9062401 15.7263225 14.9299968 15.4000634 15.0256573 15.1675641c.261957499999999-.6515679.8584099-1.3259423 1.8599936-1.3259423 1.3113716.0 1.836237 1 1.836237 2.4662654v5.8337029h3.6246436V15.8885017c0-3.349699-1.7880899-4.9084574-4.172949-4.9084574-1.9553373.0-2.814064 1.0928097-3.2910991 1.8371872H14.9065569v-1.581248H11.2819132C11.3291099 12.2591067 11.2815965 22.1419069 11.2815965 22.1419069V22.1415901z"/></svg>
</a><a class=social-icon href=https://github.com/naoyafurudono target=_blank rel=noopener title=GitHub><svg width="28" height="28" viewBox="0 0 28 28" fill="#ABABAB" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M13.9988029 1.32087331C6.82105037 1.32087331 1 7.14112562 1 14.3212723c0 5.7436386 3.72454649 10.6157955 8.89038951 12.3348169C10.5408085 26.7757983 10.7778323 26.374374 10.7778323 26.0296121 10.7778323 25.7215609 10.7666595 24.9035493 10.760275 23.8189856 7.14426471 24.6042767 6.38131925 22.0760223 6.38131925 22.0760223c-.59136253-1.5019491-1.44369072-1.9017772-1.44369072-1.9017772C3.75729765 19.3682044 5.02701126 19.3841656 5.02701126 19.3841656 6.33183953 19.4759425 7.01817121 20.7241085 7.01817121 20.7241085c1.15958133 1.9863716 3.04300319 1.4125664 3.78360289 1.0797753.1181129-.8395592.4540962-1.4125663.8251942-1.7373768C8.74038491 19.7385043 5.70536235 18.6228163 5.70536235 13.6413251c0-1.4189508.50676816-2.5801283 1.33834679-3.4883207C6.90963504 9.82420367 6.46351945 8.50181809 7.17139875 6.71256734c0 0 1.09094816-.34955032 3.57451115 1.33276037C11.78259 7.75642995 12.8950858 7.61277914 14.000399 7.60719272 15.1049142 7.61277914 16.2166119 7.75642995 17.2548881 8.04532771c2.4819669-1.68231069 3.571319-1.33276037 3.571319-1.33276037C21.5356825 8.50181809 21.0895669 9.82420367 20.9562909 10.1530044 21.7894656 11.0611968 22.2922435 12.2223743 22.2922435 13.6413251c0 4.9942601-3.039811 6.0931889-5.935173 6.4148071.4660671.401424200000001.8818564 1.194696.8818564 2.4077473C17.2389269 24.2012564 17.2229657 25.603448 17.2229657 26.0296121 17.2229657 26.3775663 17.4575954 26.7821827 18.116793 26.6552912 23.2786458 24.9322794 27 20.0633148 27 14.3212723 27 7.14112562 21.1789496 1.32087331 13.9988029 1.32087331"/></svg></a></div><div class=footer-mobile-links><p><a href=https://github.com/naoyafurudono/naoyafurudono.github.io target=_blank rel=noopener>Source of
this site</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener></a></p><p>©2025 Naoya Furudono</p></div><script src=https://blog.nfurudono.com/js/main.min.a7205ef73b078c8daed6fe1b0826e8ba229ffabbb69d299d9446cf41f2c7d8aa.js integrity="sha256-pyBe9zsHjI2u1v4bCCbouiKf+ru2nSmdlEbPQfLH2Ko=" crossorigin=anonymous></script><a target=_blank rel="noopener noreferrer" href=https://github.com/naoyafurudono/naoyafurudono.github.io/actions><img src=https://github.com/naoyafurudono/naoyafurudono.github.io/actions/workflows/gh-pages.yml/badge.svg alt="github pages deploy status" style=max-width:100%></a><p><a href="https://www.amazon.jp/hz/wishlist/ls/1JBRXP4JZZ21T?ref_=wl_share">欲しい本リスト</a></p><p><a href="https://www.amazon.jp/hz/wishlist/ls/3TT5GR81VZPHP?ref_=wl_share">欲しいものリスト</a></p></footer></body></html>